// Package qdrant provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package qdrant

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"golang.org/x/exp/constraints"
)

// Defines values for CollectionStatus.
const (
	Green  CollectionStatus = "green"
	Red    CollectionStatus = "red"
	Yellow CollectionStatus = "yellow"
)

// Defines values for Distance.
const (
	Cosine Distance = "Cosine"
	Dot    Distance = "Dot"
	Euclid Distance = "Euclid"
)

// Defines values for OptimizersStatus0.
const (
	Ok OptimizersStatus0 = "ok"
)

// Defines values for PayloadSchemaType.
const (
	PayloadSchemaTypeFloat   PayloadSchemaType = "float"
	PayloadSchemaTypeGeo     PayloadSchemaType = "geo"
	PayloadSchemaTypeInteger PayloadSchemaType = "integer"
	PayloadSchemaTypeKeyword PayloadSchemaType = "keyword"
	PayloadSchemaTypeText    PayloadSchemaType = "text"
)

// Defines values for ReadConsistencyType.
const (
	All      ReadConsistencyType = "all"
	Majority ReadConsistencyType = "majority"
	Quorum   ReadConsistencyType = "quorum"
)

// Defines values for ReplicaState.
const (
	Active       ReplicaState = "Active"
	Dead         ReplicaState = "Dead"
	Initializing ReplicaState = "Initializing"
	Listener     ReplicaState = "Listener"
	Partial      ReplicaState = "Partial"
)

// Defines values for ScalarType.
const (
	Int8 ScalarType = "int8"
)

// Defines values for SegmentType.
const (
	Indexed SegmentType = "indexed"
	Plain   SegmentType = "plain"
	Special SegmentType = "special"
)

// Defines values for SnapshotPriority.
const (
	SnapshotPriorityReplica  SnapshotPriority = "replica"
	SnapshotPrioritySnapshot SnapshotPriority = "snapshot"
)

// Defines values for StateRole.
const (
	Candidate    StateRole = "Candidate"
	Follower     StateRole = "Follower"
	Leader       StateRole = "Leader"
	PreCandidate StateRole = "PreCandidate"
)

// Defines values for TextIndexType.
const (
	TextIndexTypeText TextIndexType = "text"
)

// Defines values for TokenizerType.
const (
	Prefix     TokenizerType = "prefix"
	Whitespace TokenizerType = "whitespace"
	Word       TokenizerType = "word"
)

// Defines values for UpdateStatus.
const (
	Acknowledged UpdateStatus = "acknowledged"
	Completed    UpdateStatus = "completed"
)

// Defines values for WriteOrdering.
const (
	Medium WriteOrdering = "medium"
	Strong WriteOrdering = "strong"
	Weak   WriteOrdering = "weak"
)

// AbortTransferOperation defines model for AbortTransferOperation.
type AbortTransferOperation struct {
	AbortTransfer MoveShard `json:"abort_transfer"`
}

// AliasDescription defines model for AliasDescription.
type AliasDescription struct {
	AliasName      string `json:"alias_name"`
	CollectionName string `json:"collection_name"`
}

// AliasOperations Group of all the possible operations related to collection aliases
type AliasOperations struct {
	union json.RawMessage
}

// AnyVariants defines model for AnyVariants.
type AnyVariants struct {
	union json.RawMessage
}

// AnyVariants0 defines model for .
type AnyVariants0 = []string

// AnyVariants1 defines model for .
type AnyVariants1 = []int64

// AppBuildTelemetry defines model for AppBuildTelemetry.
type AppBuildTelemetry struct {
	Features *AppBuildTelemetry_Features `json:"features,omitempty"`
	Name     string                      `json:"name"`
	System   *AppBuildTelemetry_System   `json:"system,omitempty"`
	Version  string                      `json:"version"`
}

// AppBuildTelemetryFeatures1 defines model for .
type AppBuildTelemetryFeatures1 = interface{}

// AppBuildTelemetry_Features defines model for AppBuildTelemetry.Features.
type AppBuildTelemetry_Features struct {
	union json.RawMessage
}

// AppBuildTelemetrySystem1 defines model for .
type AppBuildTelemetrySystem1 = interface{}

// AppBuildTelemetry_System defines model for AppBuildTelemetry.System.
type AppBuildTelemetry_System struct {
	union json.RawMessage
}

// AppFeaturesTelemetry defines model for AppFeaturesTelemetry.
type AppFeaturesTelemetry struct {
	Debug               bool `json:"debug"`
	ServiceDebugFeature bool `json:"service_debug_feature"`
	WebFeature          bool `json:"web_feature"`
}

// Batch defines model for Batch.
type Batch struct {
	Ids      []ExtendedPointId      `json:"ids"`
	Payloads *[]Batch_Payloads_Item `json:"payloads"`
	Vectors  BatchVectorStruct      `json:"vectors"`
}

// BatchPayloads1 defines model for .
type BatchPayloads1 = interface{}

// Batch_Payloads_Item defines model for Batch.payloads.Item.
type Batch_Payloads_Item struct {
	union json.RawMessage
}

// BatchVectorStruct defines model for BatchVectorStruct.
type BatchVectorStruct struct {
	union json.RawMessage
}

// BatchVectorStruct0 defines model for .
type BatchVectorStruct0 = [][]float32

// BatchVectorStruct1 defines model for .
type BatchVectorStruct1 map[string][][]float32

// ChangeAliasesOperation Operation for performing changes of collection aliases. Alias changes are atomic, meaning that no collection modifications can happen between alias operations.
type ChangeAliasesOperation struct {
	Actions []AliasOperations `json:"actions"`
}

// ClusterConfigTelemetry defines model for ClusterConfigTelemetry.
type ClusterConfigTelemetry struct {
	Consensus     ConsensusConfigTelemetry `json:"consensus"`
	GrpcTimeoutMs uint64                   `json:"grpc_timeout_ms"`
	P2p           P2pConfigTelemetry       `json:"p2p"`
}

// ClusterOperations defines model for ClusterOperations.
type ClusterOperations struct {
	union json.RawMessage
}

// ClusterStatus Information about current cluster status and structure
type ClusterStatus struct {
	union json.RawMessage
}

// ClusterStatus0 defines model for .
type ClusterStatus0 struct {
	Status ClusterStatus `json:"status"`
}

// ClusterStatus1 Description of enabled cluster
type ClusterStatus1 struct {
	// ConsensusThreadStatus Information about current consensus thread status
	ConsensusThreadStatus ConsensusThreadStatus `json:"consensus_thread_status"`

	// MessageSendFailures Consequent failures of message send operations in consensus by peer address. On the first success to send to that peer - entry is removed from this hashmap.
	MessageSendFailures map[string]MessageSendErrors `json:"message_send_failures"`

	// PeerId ID of this peer
	PeerId uint64 `json:"peer_id"`

	// Peers Peers composition of the cluster with main information
	Peers map[string]PeerInfo `json:"peers"`

	// RaftInfo Summary information about the current raft state
	RaftInfo RaftInfo            `json:"raft_info"`
	Status   ClusterStatus `json:"status"`
}

// ClusterStatusTelemetry defines model for ClusterStatusTelemetry.
type ClusterStatusTelemetry struct {
	Commit uint64 `json:"commit"`

	// ConsensusThreadStatus Information about current consensus thread status
	ConsensusThreadStatus ConsensusThreadStatus        `json:"consensus_thread_status"`
	IsVoter               bool                         `json:"is_voter"`
	NumberOfPeers         uint                         `json:"number_of_peers"`
	PeerId                *uint64                      `json:"peer_id"`
	PendingOperations     uint                         `json:"pending_operations"`
	Role                  *ClusterStatusTelemetry_Role `json:"role,omitempty"`
	Term                  uint64                       `json:"term"`
}

// ClusterStatusTelemetryRole1 defines model for .
type ClusterStatusTelemetryRole1 = interface{}

// ClusterStatusTelemetry_Role defines model for ClusterStatusTelemetry.Role.
type ClusterStatusTelemetry_Role struct {
	union json.RawMessage
}

// ClusterTelemetry defines model for ClusterTelemetry.
type ClusterTelemetry struct {
	Config  *ClusterTelemetry_Config `json:"config,omitempty"`
	Enabled bool                     `json:"enabled"`
	Status  *ClusterTelemetry_Status `json:"status,omitempty"`
}

// ClusterTelemetryConfig1 defines model for .
type ClusterTelemetryConfig1 = interface{}

// ClusterTelemetry_Config defines model for ClusterTelemetry.Config.
type ClusterTelemetry_Config struct {
	union json.RawMessage
}

// ClusterTelemetryStatus1 defines model for .
type ClusterTelemetryStatus1 = interface{}

// ClusterTelemetry_Status defines model for ClusterTelemetry.Status.
type ClusterTelemetry_Status struct {
	union json.RawMessage
}

// CollectionClusterInfo Current clustering distribution for the collection
type CollectionClusterInfo struct {
	// LocalShards Local shards
	LocalShards []LocalShardInfo `json:"local_shards"`

	// PeerId ID of this peer
	PeerId uint64 `json:"peer_id"`

	// RemoteShards Remote shards
	RemoteShards []RemoteShardInfo `json:"remote_shards"`

	// ShardCount Total number of shards
	ShardCount uint `json:"shard_count"`

	// ShardTransfers Shard transfers
	ShardTransfers []ShardTransferInfo `json:"shard_transfers"`
}

// CollectionConfig defines model for CollectionConfig.
type CollectionConfig struct {
	// HnswConfig Config of HNSW index
	HnswConfig         HnswConfig                           `json:"hnsw_config"`
	OptimizerConfig    OptimizersConfig                     `json:"optimizer_config"`
	Params             CollectionParams                     `json:"params"`
	QuantizationConfig *CollectionConfig_QuantizationConfig `json:"quantization_config,omitempty"`
	WalConfig          WalConfig                            `json:"wal_config"`
}

// CollectionConfigQuantizationConfig1 defines model for .
type CollectionConfigQuantizationConfig1 = interface{}

// CollectionConfig_QuantizationConfig defines model for CollectionConfig.QuantizationConfig.
type CollectionConfig_QuantizationConfig struct {
	union json.RawMessage
}

// CollectionDescription defines model for CollectionDescription.
type CollectionDescription struct {
	Name string `json:"name"`
}

// CollectionInfo Current statistics and configuration of the collection
type CollectionInfo struct {
	Config CollectionConfig `json:"config"`

	// IndexedVectorsCount Number of indexed vectors in the collection. Indexed vectors in large segments are faster to query, as it is stored in vector index (HNSW)
	IndexedVectorsCount uint `json:"indexed_vectors_count"`

	// OptimizerStatus Current state of the collection
	OptimizerStatus OptimizersStatus `json:"optimizer_status"`

	// PayloadSchema Types of stored payload
	PayloadSchema map[string]PayloadIndexInfo `json:"payload_schema"`

	// PointsCount Number of points (vectors + payloads) in collection Each point could be accessed by unique id
	PointsCount uint `json:"points_count"`

	// SegmentsCount Number of segments in collection. Each segment has independent vector as payload indexes
	SegmentsCount uint `json:"segments_count"`

	// Status Current state of the collection. `Green` - all good. `Yellow` - optimization is running, `Red` - some operations failed and was not recovered
	Status CollectionStatus `json:"status"`

	// VectorsCount Number of vectors in collection All vectors in collection are available for querying Calculated as `points_count x vectors_per_point` Where `vectors_per_point` is a number of named vectors in schema
	VectorsCount uint `json:"vectors_count"`
}

// CollectionParams defines model for CollectionParams.
type CollectionParams struct {
	// OnDiskPayload If true - point's payload will not be stored in memory. It will be read from the disk every time it is requested. This setting saves RAM by (slightly) increasing the response time. Note: those payload values that are involved in filtering and are indexed - remain in RAM.
	OnDiskPayload *bool `json:"on_disk_payload,omitempty"`

	// ReplicationFactor Number of replicas for each shard
	ReplicationFactor *uint32 `json:"replication_factor,omitempty"`

	// ShardNumber Number of shards the collection has
	ShardNumber *uint32 `json:"shard_number,omitempty"`

	// Vectors Vector params separator for single and multiple vector modes Single mode:
	//
	// { "size": 128, "distance": "Cosine" }
	//
	// or multiple mode:
	//
	// { "default": { "size": 128, "distance": "Cosine" } }
	Vectors VectorsConfig `json:"vectors"`

	// WriteConsistencyFactor Defines how many replicas should apply the operation for us to consider it successful. Increasing this number will make the collection more resilient to inconsistencies, but will also make it fail if not enough replicas are available. Does not have any performance impact.
	WriteConsistencyFactor *uint32 `json:"write_consistency_factor,omitempty"`
}

// CollectionParamsDiff defines model for CollectionParamsDiff.
type CollectionParamsDiff struct {
	// ReplicationFactor Number of replicas for each shard
	ReplicationFactor *uint32 `json:"replication_factor"`

	// WriteConsistencyFactor Minimal number successful responses from replicas to consider operation successful
	WriteConsistencyFactor *uint32 `json:"write_consistency_factor"`
}

// CollectionStatus Current state of the collection. `Green` - all good. `Yellow` - optimization is running, `Red` - some operations failed and was not recovered
type CollectionStatus string

// CollectionTelemetry defines model for CollectionTelemetry.
type CollectionTelemetry struct {
	Config     CollectionConfig      `json:"config"`
	Id         string                `json:"id"`
	InitTimeMs uint64                `json:"init_time_ms"`
	Shards     []ReplicaSetTelemetry `json:"shards"`
	Transfers  []ShardTransferInfo   `json:"transfers"`
}

// CollectionTelemetryEnum defines model for CollectionTelemetryEnum.
type CollectionTelemetryEnum struct {
	union json.RawMessage
}

// CollectionsAggregatedTelemetry defines model for CollectionsAggregatedTelemetry.
type CollectionsAggregatedTelemetry struct {
	// OptimizersStatus Current state of the collection
	OptimizersStatus OptimizersStatus `json:"optimizers_status"`
	Params           CollectionParams `json:"params"`
	Vectors          uint             `json:"vectors"`
}

// CollectionsAliasesResponse defines model for CollectionsAliasesResponse.
type CollectionsAliasesResponse struct {
	Aliases []AliasDescription `json:"aliases"`
}

// CollectionsResponse defines model for CollectionsResponse.
type CollectionsResponse struct {
	Collections []CollectionDescription `json:"collections"`
}

// CollectionsTelemetry defines model for CollectionsTelemetry.
type CollectionsTelemetry struct {
	Collections         *[]CollectionTelemetryEnum `json:"collections"`
	NumberOfCollections uint                       `json:"number_of_collections"`
}

// Condition defines model for Condition.
type Condition struct {
	union json.RawMessage
}

// ConsensusConfigTelemetry defines model for ConsensusConfigTelemetry.
type ConsensusConfigTelemetry struct {
	BootstrapTimeoutSec uint64 `json:"bootstrap_timeout_sec"`
	MaxMessageQueueSize uint   `json:"max_message_queue_size"`
	TickPeriodMs        uint64 `json:"tick_period_ms"`
}

// ConsensusThreadStatus Information about current consensus thread status
type ConsensusThreadStatus struct {
	union json.RawMessage
}

// ConsensusThreadStatus0 defines model for .
type ConsensusThreadStatus0 struct {
	ConsensusThreadStatus ConsensusThreadStatus `json:"consensus_thread_status"`
	LastUpdate            time.Time                                  `json:"last_update"`
}

// ConsensusThreadStatus1 defines model for .
type ConsensusThreadStatus1 struct {
	ConsensusThreadStatus ConsensusThreadStatus `json:"consensus_thread_status"`
}

// ConsensusThreadStatus2 defines model for .
type ConsensusThreadStatus2 struct {
	ConsensusThreadStatus ConsensusThreadStatus `json:"consensus_thread_status"`
	Err                   string                                     `json:"err"`
}

// CountRequest Count Request Counts the number of points which satisfy the given filter. If filter is not provided, the count of all points in the collection will be returned.
type CountRequest struct {
	// Exact If true, count exact number of points. If false, count approximate number of points faster. Approximate count might be unreliable during the indexing process. Default: true
	Exact *bool `json:"exact,omitempty"`

	// Filter Look only for points which satisfies this conditions
	Filter *SearchRequest_Filter `json:"filter,omitempty"`
}

// CountRequestFilter1 defines model for .
type CountRequestFilter1 = interface{}

// CountRequest_Filter Look only for points which satisfies this conditions
type CountRequest_Filter struct {
	union json.RawMessage
}

// CountResult defines model for CountResult.
type CountResult struct {
	// Count Number of points which satisfy the conditions
	Count uint `json:"count"`
}

// CreateAlias Create alternative name for a collection. Collection will be available under both names for search, retrieve,
type CreateAlias struct {
	AliasName      string `json:"alias_name"`
	CollectionName string `json:"collection_name"`
}

// CreateAliasOperation defines model for CreateAliasOperation.
type CreateAliasOperation struct {
	// CreateAlias Create alternative name for a collection. Collection will be available under both names for search, retrieve,
	CreateAlias CreateAlias `json:"create_alias"`
}

// CreateCollection Operation for creating new collection and (optionally) specify index params
type CreateCollection struct {
	// HnswConfig Custom params for HNSW index. If none - values from service configuration file are used.
	HnswConfig *CreateCollection_HnswConfig `json:"hnsw_config,omitempty"`

	// InitFrom Specify other collection to copy data from.
	InitFrom *CreateCollection_InitFrom `json:"init_from,omitempty"`

	// OnDiskPayload If true - point's payload will not be stored in memory. It will be read from the disk every time it is requested. This setting saves RAM by (slightly) increasing the response time. Note: those payload values that are involved in filtering and are indexed - remain in RAM.
	OnDiskPayload *bool `json:"on_disk_payload"`

	// OptimizersConfig Custom params for Optimizers.  If none - values from service configuration file are used.
	OptimizersConfig *CreateCollection_OptimizersConfig `json:"optimizers_config,omitempty"`

	// QuantizationConfig Quantization parameters. If none - quantization is disabled.
	QuantizationConfig *CreateCollection_QuantizationConfig `json:"quantization_config,omitempty"`

	// ReplicationFactor Number of shards replicas. Default is 1 Minimum is 1
	ReplicationFactor *uint32 `json:"replication_factor"`

	// ShardNumber Number of shards in collection. Default is 1 for standalone, otherwise equal to the number of nodes Minimum is 1
	ShardNumber *uint32 `json:"shard_number"`

	// Vectors Vector params separator for single and multiple vector modes Single mode:
	//
	// { "size": 128, "distance": "Cosine" }
	//
	// or multiple mode:
	//
	// { "default": { "size": 128, "distance": "Cosine" } }
	Vectors VectorsConfig `json:"vectors"`

	// WalConfig Custom params for WAL. If none - values from service configuration file are used.
	WalConfig *CreateCollection_WalConfig `json:"wal_config,omitempty"`

	// WriteConsistencyFactor Defines how many replicas should apply the operation for us to consider it successful. Increasing this number will make the collection more resilient to inconsistencies, but will also make it fail if not enough replicas are available. Does not have any performance impact.
	WriteConsistencyFactor *uint32 `json:"write_consistency_factor"`
}

// CreateCollectionHnswConfig1 defines model for .
type CreateCollectionHnswConfig1 = interface{}

// CreateCollection_HnswConfig Custom params for HNSW index. If none - values from service configuration file are used.
type CreateCollection_HnswConfig struct {
	union json.RawMessage
}

// CreateCollectionInitFrom1 defines model for .
type CreateCollectionInitFrom1 = interface{}

// CreateCollection_InitFrom Specify other collection to copy data from.
type CreateCollection_InitFrom struct {
	union json.RawMessage
}

// CreateCollectionOptimizersConfig1 defines model for .
type CreateCollectionOptimizersConfig1 = interface{}

// CreateCollection_OptimizersConfig Custom params for Optimizers.  If none - values from service configuration file are used.
type CreateCollection_OptimizersConfig struct {
	union json.RawMessage
}

// CreateCollectionQuantizationConfig1 defines model for .
type CreateCollectionQuantizationConfig1 = interface{}

// CreateCollection_QuantizationConfig Quantization parameters. If none - quantization is disabled.
type CreateCollection_QuantizationConfig struct {
	union json.RawMessage
}

// CreateCollectionWalConfig1 defines model for .
type CreateCollectionWalConfig1 = interface{}

// CreateCollection_WalConfig Custom params for WAL. If none - values from service configuration file are used.
type CreateCollection_WalConfig struct {
	union json.RawMessage
}

// CreateFieldIndex defines model for CreateFieldIndex.
type CreateFieldIndex struct {
	FieldName   string                        `json:"field_name"`
	FieldSchema *CreateFieldIndex_FieldSchema `json:"field_schema,omitempty"`
}

// CreateFieldIndexFieldSchema1 defines model for .
type CreateFieldIndexFieldSchema1 = interface{}

// CreateFieldIndex_FieldSchema defines model for CreateFieldIndex.FieldSchema.
type CreateFieldIndex_FieldSchema struct {
	union json.RawMessage
}

// DeleteAlias Delete alias if exists
type DeleteAlias struct {
	AliasName string `json:"alias_name"`
}

// DeleteAliasOperation Delete alias if exists
type DeleteAliasOperation struct {
	// DeleteAlias Delete alias if exists
	DeleteAlias DeleteAlias `json:"delete_alias"`
}

// DeletePayload defines model for DeletePayload.
type DeletePayload struct {
	// Filter Deletes values from points that satisfy this filter condition
	Filter *DeletePayload_Filter `json:"filter,omitempty"`

	// Keys List of payload keys to remove from payload
	Keys []string `json:"keys"`

	// Points Deletes values from each point in this list
	Points *[]ExtendedPointId `json:"points"`
}

// DeletePayloadFilter1 defines model for .
type DeletePayloadFilter1 = interface{}

// DeletePayload_Filter Deletes values from points that satisfy this filter condition
type DeletePayload_Filter struct {
	union json.RawMessage
}

// Distance Type of internal tags, build from payload Distance function types used to compare vectors
type Distance string

// DropReplicaOperation defines model for DropReplicaOperation.
type DropReplicaOperation struct {
	DropReplica Replica `json:"drop_replica"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Result *map[string]interface{} `json:"result"`
	Status *struct {
		// Error Description of the occurred error.
		Error *string `json:"error,omitempty"`
	} `json:"status,omitempty"`

	// Time Time spent to process this request
	Time *float32 `json:"time,omitempty"`
}

// ExtendedPointId Type, used for specifying point ID in user interface
type ExtendedPointId struct {
	union json.RawMessage
}

// ExtendedPointId0 defines model for .
type ExtendedPointId0 = uint64

// ExtendedPointId1 defines model for .
type ExtendedPointId1 = openapi_types.UUID

// FieldCondition All possible payload filtering conditions
type FieldCondition struct {
	// GeoBoundingBox Check if points geo location lies in a given area
	GeoBoundingBox *FieldCondition_GeoBoundingBox `json:"geo_bounding_box,omitempty"`

	// GeoRadius Check if geo point is within a given radius
	GeoRadius *FieldCondition_GeoRadius `json:"geo_radius,omitempty"`

	// Key Payload key
	Key string `json:"key"`

	// Match Check if point has field with a given value
	Match *FieldCondition_Match `json:"match,omitempty"`

	// Range Check if points value lies in a given range
	Range *FieldCondition_Range `json:"range,omitempty"`

	// ValuesCount Check number of values of the field
	ValuesCount *FieldCondition_ValuesCount `json:"values_count,omitempty"`
}

// FieldConditionGeoBoundingBox1 defines model for .
type FieldConditionGeoBoundingBox1 = interface{}

// FieldCondition_GeoBoundingBox Check if points geo location lies in a given area
type FieldCondition_GeoBoundingBox struct {
	union json.RawMessage
}

// FieldConditionGeoRadius1 defines model for .
type FieldConditionGeoRadius1 = interface{}

// FieldCondition_GeoRadius Check if geo point is within a given radius
type FieldCondition_GeoRadius struct {
	union json.RawMessage
}

// FieldConditionMatch1 defines model for .
type FieldConditionMatch1 = interface{}

// FieldCondition_Match Check if point has field with a given value
type FieldCondition_Match struct {
	union json.RawMessage
}

// FieldConditionRange1 defines model for .
type FieldConditionRange1 = interface{}

// FieldCondition_Range Check if points value lies in a given range
type FieldCondition_Range struct {
	union json.RawMessage
}

// FieldConditionValuesCount1 defines model for .
type FieldConditionValuesCount1 = interface{}

// FieldCondition_ValuesCount Check number of values of the field
type FieldCondition_ValuesCount struct {
	union json.RawMessage
}

// Filter defines model for Filter.
type Filter struct {
	// Must All conditions must match
	Must *[]Condition `json:"must"`

	// MustNot All conditions must NOT match
	MustNot *[]Condition `json:"must_not"`

	// Should At least one of those conditions should match
	Should *[]Condition `json:"should"`
}

// FilterSelector defines model for FilterSelector.
type FilterSelector struct {
	Filter Filter `json:"filter"`
}

// GeoBoundingBox Geo filter request
//
// Matches coordinates inside the rectangle, described by coordinates of lop-left and bottom-right edges
type GeoBoundingBox struct {
	// BottomRight Geo point payload schema
	BottomRight GeoPoint `json:"bottom_right"`

	// TopLeft Geo point payload schema
	TopLeft GeoPoint `json:"top_left"`
}

// GeoPoint Geo point payload schema
type GeoPoint struct {
	Lat float64 `json:"lat"`
	Lon float64 `json:"lon"`
}

// GeoRadius Geo filter request
//
// Matches coordinates inside the circle of `radius` and center with coordinates `center`
type GeoRadius struct {
	// Center Geo point payload schema
	Center GeoPoint `json:"center"`

	// Radius Radius of the area in meters
	Radius float64 `json:"radius"`
}

// GrpcTelemetry defines model for GrpcTelemetry.
type GrpcTelemetry struct {
	Responses map[string]OperationDurationStatistics `json:"responses"`
}

// HasIdCondition ID-based filtering condition
type HasIdCondition struct {
	HasId []ExtendedPointId `json:"has_id"`
}

// HnswConfig Config of HNSW index
type HnswConfig struct {
	// EfConstruct Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build index.
	EfConstruct uint `json:"ef_construct"`

	// FullScanThreshold Minimal size (in KiloBytes) of vectors for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold_kb` additional indexing won't be used - in this case full-scan search should be preferred by query planner and additional indexing is not required. Note: 1Kb = 1 vector of size 256
	FullScanThreshold uint `json:"full_scan_threshold"`

	// M Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.
	M uint `json:"m"`

	// MaxIndexingThreads Number of parallel threads used for background index building. If 0 - auto selection.
	MaxIndexingThreads *uint `json:"max_indexing_threads,omitempty"`

	// OnDisk Store HNSW index on disk. If set to false, index will be stored in RAM. Default: false
	OnDisk *bool `json:"on_disk"`

	// PayloadM Custom M param for hnsw graph built for payload index. If not set, default M will be used.
	PayloadM *uint `json:"payload_m"`
}

// HnswConfigDiff defines model for HnswConfigDiff.
type HnswConfigDiff struct {
	// EfConstruct Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build index.
	EfConstruct *uint `json:"ef_construct"`

	// FullScanThreshold Minimal size (in KiloBytes) of vectors for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold_kb` additional indexing won't be used - in this case full-scan search should be preferred by query planner and additional indexing is not required. Note: 1Kb = 1 vector of size 256
	FullScanThreshold *uint `json:"full_scan_threshold"`

	// M Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.
	M *uint `json:"m"`

	// MaxIndexingThreads Number of parallel threads used for background index building. If 0 - auto selection.
	MaxIndexingThreads *uint `json:"max_indexing_threads"`

	// OnDisk Store HNSW index on disk. If set to false, index will be stored in RAM. Default: false
	OnDisk *bool `json:"on_disk"`

	// PayloadM Custom M param for additional payload-aware HNSW links. If not set, default M will be used.
	PayloadM *uint `json:"payload_m"`
}

// Indexes Vector index configuration of the segment
type Indexes struct {
	union json.RawMessage
}

// Indexes0 Do not use any index, scan whole vector collection during search. Guarantee 100% precision, but may be time consuming on large collections.
type Indexes0 struct {
	Options map[string]interface{} `json:"options"`
	Type    Indexes            `json:"type"`
}

// Indexes1 Use filterable HNSW index for approximate search. Is very fast even on a very huge collections, but require additional space to store index and additional time to build it.
type Indexes1 struct {
	// Options Config of HNSW index
	Options HnswConfig  `json:"options"`
	Type    Indexes `json:"type"`
}

// InitFrom Operation for creating new collection and (optionally) specify index params
type InitFrom struct {
	Collection string `json:"collection"`
}

// IsEmptyCondition Select points with empty payload for a specified field
type IsEmptyCondition struct {
	// IsEmpty Payload field
	IsEmpty PayloadField `json:"is_empty"`
}

// LocalShardInfo defines model for LocalShardInfo.
type LocalShardInfo struct {
	// PointsCount Number of points in the shard
	PointsCount uint `json:"points_count"`

	// ShardId Local shard id
	ShardId uint32 `json:"shard_id"`

	// State State of the single shard within a replica set.
	State ReplicaState `json:"state"`
}

// LocalShardTelemetry defines model for LocalShardTelemetry.
type LocalShardTelemetry struct {
	Optimizations OptimizerTelemetry `json:"optimizations"`
	Segments      []SegmentTelemetry `json:"segments"`
	VariantName   *string            `json:"variant_name"`
}

// LocksOption defines model for LocksOption.
type LocksOption struct {
	ErrorMessage *string `json:"error_message"`
	Write        bool    `json:"write"`
}

// LookupLocation Defines a location to use for looking up the vector. Specifies collection and vector field name.
type LookupLocation struct {
	// Collection Name of the collection used for lookup
	Collection string `json:"collection"`

	// Vector Optional name of the vector field within the collection. If not provided, the default vector field will be used.
	Vector *string `json:"vector"`
}

// Match Match filter request
type Match struct {
	union json.RawMessage
}

// MatchAny Exact match on any of the given values
type MatchAny struct {
	Any AnyVariants `json:"any"`
}

// MatchText Full-text match of the strings.
type MatchText struct {
	Text string `json:"text"`
}

// MatchValue Exact match of the given value
type MatchValue struct {
	Value ValueVariants `json:"value"`
}

// MessageSendErrors Message send failures for a particular peer
type MessageSendErrors struct {
	Count       uint    `json:"count"`
	LatestError *string `json:"latest_error"`
}

// MoveShard defines model for MoveShard.
type MoveShard struct {
	FromPeerId uint64 `json:"from_peer_id"`
	ShardId    uint32 `json:"shard_id"`
	ToPeerId   uint64 `json:"to_peer_id"`
}

// MoveShardOperation defines model for MoveShardOperation.
type MoveShardOperation struct {
	MoveShard MoveShard `json:"move_shard"`
}

// NamedVector Vector data with name
type NamedVector struct {
	// Name Name of vector data
	Name string `json:"name"`

	// Vector Vector data
	Vector []float32 `json:"vector"`
}

// NamedVectorStruct Vector data separator for named and unnamed modes Unanmed mode:
//
// { "vector": [1.0, 2.0, 3.0] }
//
// or named mode:
//
// { "vector": { "vector": [1.0, 2.0, 3.0], "name": "image-embeddings" } }
type NamedVectorStruct struct {
	union json.RawMessage
}

// NamedVectorStruct0 defines model for .
type NamedVectorStruct0 = []float32

// OperationDurationStatistics defines model for OperationDurationStatistics.
type OperationDurationStatistics struct {
	AvgDurationMicros *float32 `json:"avg_duration_micros"`
	Count             uint     `json:"count"`
	FailCount         *uint    `json:"fail_count,omitempty"`
	MaxDurationMicros *float32 `json:"max_duration_micros"`
	MinDurationMicros *float32 `json:"min_duration_micros"`
}

// OptimizerTelemetry defines model for OptimizerTelemetry.
type OptimizerTelemetry struct {
	Optimizations OperationDurationStatistics `json:"optimizations"`

	// Status Current state of the collection
	Status OptimizersStatus `json:"status"`
}

// OptimizersConfig defines model for OptimizersConfig.
type OptimizersConfig struct {
	// DefaultSegmentNumber Target amount of segments optimizer will try to keep. Real amount of segments may vary depending on multiple parameters: - Amount of stored points - Current write RPS
	//
	// It is recommended to select default number of segments as a factor of the number of search threads, so that each segment would be handled evenly by one of the threads If `default_segment_number = 0`, will be automatically selected by the number of available CPUs
	DefaultSegmentNumber uint `json:"default_segment_number"`

	// DeletedThreshold The minimal fraction of deleted vectors in a segment, required to perform segment optimization
	DeletedThreshold float64 `json:"deleted_threshold"`

	// FlushIntervalSec Minimum interval between forced flushes.
	FlushIntervalSec uint64 `json:"flush_interval_sec"`

	// IndexingThreshold Maximum size (in KiloBytes) of vectors allowed for plain index. Default value based on <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md> Note: 1Kb = 1 vector of size 256
	IndexingThreshold uint `json:"indexing_threshold"`

	// MaxOptimizationThreads Maximum available threads for optimization workers
	MaxOptimizationThreads uint `json:"max_optimization_threads"`

	// MaxSegmentSize Do not create segments larger this size (in KiloBytes). Large segments might require disproportionately long indexation times, therefore it makes sense to limit the size of segments.
	//
	// If indexation speed have more priority for your - make this parameter lower. If search speed is more important - make this parameter higher. Note: 1Kb = 1 vector of size 256 If not set, will be automatically selected considering the number of available CPUs.
	MaxSegmentSize *uint `json:"max_segment_size"`

	// MemmapThreshold Maximum size (in KiloBytes) of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file. To enable memmap storage, lower the threshold Note: 1Kb = 1 vector of size 256 If not set, mmap will not be used.
	MemmapThreshold *uint `json:"memmap_threshold"`

	// VacuumMinVectorNumber The minimal number of vectors in a segment, required to perform segment optimization
	VacuumMinVectorNumber uint `json:"vacuum_min_vector_number"`
}

// OptimizersConfigDiff defines model for OptimizersConfigDiff.
type OptimizersConfigDiff struct {
	// DefaultSegmentNumber Target amount of segments optimizer will try to keep. Real amount of segments may vary depending on multiple parameters: - Amount of stored points - Current write RPS
	//
	// It is recommended to select default number of segments as a factor of the number of search threads, so that each segment would be handled evenly by one of the threads If `default_segment_number = 0`, will be automatically selected by the number of available CPUs
	DefaultSegmentNumber *uint `json:"default_segment_number"`

	// DeletedThreshold The minimal fraction of deleted vectors in a segment, required to perform segment optimization
	DeletedThreshold *float64 `json:"deleted_threshold"`

	// FlushIntervalSec Minimum interval between forced flushes.
	FlushIntervalSec *uint64 `json:"flush_interval_sec"`

	// IndexingThreshold Maximum size (in KiloBytes) of vectors allowed for plain index. Default value based on <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md> Note: 1Kb = 1 vector of size 256
	IndexingThreshold *uint `json:"indexing_threshold"`

	// MaxOptimizationThreads Maximum available threads for optimization workers
	MaxOptimizationThreads *uint `json:"max_optimization_threads"`

	// MaxSegmentSize Do not create segments larger this size (in KiloBytes). Large segments might require disproportionately long indexation times, therefore it makes sense to limit the size of segments.
	//
	// If indexation speed have more priority for your - make this parameter lower. If search speed is more important - make this parameter higher. Note: 1Kb = 1 vector of size 256
	MaxSegmentSize *uint `json:"max_segment_size"`

	// MemmapThreshold Maximum size (in KiloBytes) of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file. To enable memmap storage, lower the threshold Note: 1Kb = 1 vector of size 256
	MemmapThreshold *uint `json:"memmap_threshold"`

	// VacuumMinVectorNumber The minimal number of vectors in a segment, required to perform segment optimization
	VacuumMinVectorNumber *uint `json:"vacuum_min_vector_number"`
}

// OptimizersStatus Current state of the collection
type OptimizersStatus struct {
	union json.RawMessage
}

// OptimizersStatus0 Optimizers are reporting as expected
type OptimizersStatus0 string

// OptimizersStatus1 Something wrong happened with optimizers
type OptimizersStatus1 struct {
	Error string `json:"error"`
}

// P2pConfigTelemetry defines model for P2pConfigTelemetry.
type P2pConfigTelemetry struct {
	ConnectionPoolSize uint `json:"connection_pool_size"`
}

// Payload defines model for Payload.
type Payload map[string]interface{}

// PayloadField Payload field
type PayloadField struct {
	// Key Payload field name
	Key string `json:"key"`
}

// PayloadFieldSchema defines model for PayloadFieldSchema.
type PayloadFieldSchema struct {
	union json.RawMessage
}

// PayloadIndexInfo Display payload field type & index information
type PayloadIndexInfo struct {
	// DataType All possible names of payload types
	DataType PayloadSchemaType        `json:"data_type"`
	Params   *PayloadIndexInfo_Params `json:"params,omitempty"`

	// Points Number of points indexed with this index
	Points uint `json:"points"`
}

// PayloadIndexInfoParams1 defines model for .
type PayloadIndexInfoParams1 = interface{}

// PayloadIndexInfo_Params defines model for PayloadIndexInfo.Params.
type PayloadIndexInfo_Params struct {
	union json.RawMessage
}

// PayloadIndexTelemetry defines model for PayloadIndexTelemetry.
type PayloadIndexTelemetry struct {
	FieldName           *string `json:"field_name"`
	HistogramBucketSize *uint   `json:"histogram_bucket_size"`
	PointsCount         uint    `json:"points_count"`
	PointsValuesCount   uint    `json:"points_values_count"`
}

// PayloadSchemaParams Payload type with parameters
type PayloadSchemaParams struct {
	union json.RawMessage
}

// PayloadSchemaType All possible names of payload types
type PayloadSchemaType string

// PayloadSelector Specifies how to treat payload selector
type PayloadSelector struct {
	union json.RawMessage
}

// PayloadSelectorExclude defines model for PayloadSelectorExclude.
type PayloadSelectorExclude struct {
	// Exclude Exclude this fields from returning payload
	Exclude []string `json:"exclude"`
}

// PayloadSelectorInclude defines model for PayloadSelectorInclude.
type PayloadSelectorInclude struct {
	// Include Only include this payload keys
	Include []string `json:"include"`
}

// PayloadStorageType Type of payload storage
type PayloadStorageType struct {
	union json.RawMessage
}

// PayloadStorageType0 defines model for .
type PayloadStorageType0 struct {
	Type PayloadStorageType `json:"type"`
}

// PayloadStorageType1 defines model for .
type PayloadStorageType1 struct {
	Type PayloadStorageType `json:"type"`
}

// PeerInfo Information of a peer in the cluster
type PeerInfo struct {
	Uri string `json:"uri"`
}

// PointIdsList defines model for PointIdsList.
type PointIdsList struct {
	Points []ExtendedPointId `json:"points"`
}

// PointInsertOperations defines model for PointInsertOperations.
type PointInsertOperations struct {
	union json.RawMessage
}

// PointRequest defines model for PointRequest.
type PointRequest struct {
	// Ids Look for points with ids
	Ids []ExtendedPointId `json:"ids"`

	// WithPayload Select which payload to return with the response. Default: All
	WithPayload *PointRequest_WithPayload `json:"with_payload,omitempty"`

	// WithVector Options for specifying which vector to include
	WithVector *WithVector `json:"with_vector,omitempty"`
}

// PointRequestWithPayload1 defines model for .
type PointRequestWithPayload1 = interface{}

// PointRequest_WithPayload Select which payload to return with the response. Default: All
type PointRequest_WithPayload struct {
	union json.RawMessage
}

// PointStruct defines model for PointStruct.
type PointStruct struct {
	// Id Type, used for specifying point ID in user interface
	Id ExtendedPointId `json:"id"`

	// Payload Payload values (optional)
	Payload *PointStruct_Payload `json:"payload,omitempty"`

	// Vector Full vector data per point separator with single and multiple vector modes
	Vector VectorStruct `json:"vector"`
}

// PointStructPayload1 defines model for .
type PointStructPayload1 = interface{}

// PointStruct_Payload Payload values (optional)
type PointStruct_Payload struct {
	union json.RawMessage
}

// PointsBatch defines model for PointsBatch.
type PointsBatch struct {
	Batch Batch `json:"batch"`
}

// PointsList defines model for PointsList.
type PointsList struct {
	Points []PointStruct `json:"points"`
}

// PointsSelector defines model for PointsSelector.
type PointsSelector struct {
	union json.RawMessage
}

// QuantizationConfig defines model for QuantizationConfig.
type QuantizationConfig struct {
	union json.RawMessage
}

// QuantizationSearchParams Additional parameters of the search
type QuantizationSearchParams struct {
	// Ignore If true, quantized vectors are ignored. Default is false.
	Ignore *bool `json:"ignore,omitempty"`

	// Rescore If true, use original vectors to re-score top-k results. Might require more time in case if original vectors are stored on disk. Default is false.
	Rescore *bool `json:"rescore,omitempty"`
}

// RaftInfo Summary information about the current raft state
type RaftInfo struct {
	// Commit The index of the latest committed (finalized) operation that this peer is aware of.
	Commit uint64 `json:"commit"`

	// IsVoter Is this peer a voter or a learner
	IsVoter bool `json:"is_voter"`

	// Leader Leader of the current term
	Leader *uint64 `json:"leader"`

	// PendingOperations Number of consensus operations pending to be applied on this peer
	PendingOperations uint `json:"pending_operations"`

	// Role Role of this peer in the current term
	Role *RaftInfo_Role `json:"role,omitempty"`

	// Term Raft divides time into terms of arbitrary length, each beginning with an election. If a candidate wins the election, it remains the leader for the rest of the term. The term number increases monotonically. Each server stores the current term number which is also exchanged in every communication.
	Term uint64 `json:"term"`
}

// RaftInfoRole1 defines model for .
type RaftInfoRole1 = interface{}

// RaftInfo_Role Role of this peer in the current term
type RaftInfo_Role struct {
	union json.RawMessage
}

// Range Range filter request
type Range struct {
	// Gt point.key > range.gt
	Gt *float64 `json:"gt"`

	// Gte point.key >= range.gte
	Gte *float64 `json:"gte"`

	// Lt point.key < range.lt
	Lt *float64 `json:"lt"`

	// Lte point.key <= range.lte
	Lte *float64 `json:"lte"`
}

// ReadConsistency Read consistency parameter
//
// # Defines how many replicas should be queried to get the result
//
// * `N` - send N random request and return points, which present on all of them
//
// * `majority` - send N/2+1 random request and return points, which present on all of them
//
// * `quorum` - send requests to all nodes and return points which present on majority of them
//
// * `all` - send requests to all nodes and return points which present on all of them
//
// Default value is `Factor(1)`
type ReadConsistency struct {
	union json.RawMessage
}

// ReadConsistency0 defines model for .
type ReadConsistency0 = uint

// ReadConsistencyType * `majority` - send N/2+1 random request and return points, which present on all of them
//
// * `quorum` - send requests to all nodes and return points which present on majority of nodes
//
// * `all` - send requests to all nodes and return points which present on all nodes
type ReadConsistencyType string

// RecommendRequest Recommendation request. Provides positive and negative examples of the vectors, which are already stored in the collection.
//
// Service should look for the points which are closer to positive examples and at the same time further to negative examples. The concrete way of how to compare negative and positive distances is up to implementation in `segment` crate.
type RecommendRequest struct {
	// Filter Look only for points which satisfies this conditions
	Filter *RecommendRequest_Filter `json:"filter,omitempty"`

	// Limit Max number of result to return
	Limit uint `json:"limit"`

	// LookupFrom The location used to lookup vectors. If not specified - use current collection. Note: the other collection should have the same vector size as the current collection
	LookupFrom *RecommendRequest_LookupFrom `json:"lookup_from,omitempty"`

	// Negative Try to avoid vectors like this
	Negative *[]ExtendedPointId `json:"negative,omitempty"`

	// Offset Offset of the first result to return. May be used to paginate results. Note: large offset values may cause performance issues.
	Offset *uint `json:"offset,omitempty"`

	// Params Additional search params
	Params *RecommendRequest_Params `json:"params,omitempty"`

	// Positive Look for vectors closest to those
	Positive []ExtendedPointId `json:"positive"`

	// ScoreThreshold Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.
	ScoreThreshold *float32 `json:"score_threshold"`

	// Using Define which vector to use for recommendation, if not specified - try to use default vector
	Using *RecommendRequest_Using `json:"using,omitempty"`

	// WithPayload Select which payload to return with the response. Default: None
	WithPayload *RecommendRequest_WithPayload `json:"with_payload,omitempty"`

	// WithVector Whether to return the point vector with the result?
	WithVector *RecommendRequest_WithVector `json:"with_vector,omitempty"`
}

// RecommendRequestFilter1 defines model for .
type RecommendRequestFilter1 = interface{}

// RecommendRequest_Filter Look only for points which satisfies this conditions
type RecommendRequest_Filter struct {
	union json.RawMessage
}

// RecommendRequestLookupFrom1 defines model for .
type RecommendRequestLookupFrom1 = interface{}

// RecommendRequest_LookupFrom The location used to lookup vectors. If not specified - use current collection. Note: the other collection should have the same vector size as the current collection
type RecommendRequest_LookupFrom struct {
	union json.RawMessage
}

// RecommendRequestParams1 defines model for .
type RecommendRequestParams1 = interface{}

// RecommendRequest_Params Additional search params
type RecommendRequest_Params struct {
	union json.RawMessage
}

// RecommendRequestUsing1 defines model for .
type RecommendRequestUsing1 = interface{}

// RecommendRequest_Using Define which vector to use for recommendation, if not specified - try to use default vector
type RecommendRequest_Using struct {
	union json.RawMessage
}

// RecommendRequestWithPayload1 defines model for .
type RecommendRequestWithPayload1 = interface{}

// RecommendRequest_WithPayload Select which payload to return with the response. Default: None
type RecommendRequest_WithPayload struct {
	union json.RawMessage
}

// RecommendRequestWithVector1 defines model for .
type RecommendRequestWithVector1 = interface{}

// RecommendRequest_WithVector Whether to return the point vector with the result?
type RecommendRequest_WithVector struct {
	union json.RawMessage
}

// RecommendRequestBatch defines model for RecommendRequestBatch.
type RecommendRequestBatch struct {
	Searches []RecommendRequest `json:"searches"`
}

// Record Point data
type Record struct {
	// Id Type, used for specifying point ID in user interface
	Id ExtendedPointId `json:"id"`

	// Payload Payload - values assigned to the point
	Payload *Record_Payload `json:"payload,omitempty"`

	// Vector Vector of the point
	Vector *Record_Vector `json:"vector,omitempty"`
}

// RecordPayload1 defines model for .
type RecordPayload1 = interface{}

// Record_Payload Payload - values assigned to the point
type Record_Payload struct {
	union json.RawMessage
}

// RecordVector1 defines model for .
type RecordVector1 = interface{}

// Record_Vector Vector of the point
type Record_Vector struct {
	union json.RawMessage
}

// RemoteShardInfo defines model for RemoteShardInfo.
type RemoteShardInfo struct {
	// PeerId Remote peer id
	PeerId uint64 `json:"peer_id"`

	// ShardId Remote shard id
	ShardId uint32 `json:"shard_id"`

	// State State of the single shard within a replica set.
	State ReplicaState `json:"state"`
}

// RemoteShardTelemetry defines model for RemoteShardTelemetry.
type RemoteShardTelemetry struct {
	PeerId   *uint64                     `json:"peer_id"`
	Searches OperationDurationStatistics `json:"searches"`
	ShardId  uint32                      `json:"shard_id"`
	Updates  OperationDurationStatistics `json:"updates"`
}

// RenameAlias Change alias to a new one
type RenameAlias struct {
	NewAliasName string `json:"new_alias_name"`
	OldAliasName string `json:"old_alias_name"`
}

// RenameAliasOperation Change alias to a new one
type RenameAliasOperation struct {
	// RenameAlias Change alias to a new one
	RenameAlias RenameAlias `json:"rename_alias"`
}

// Replica defines model for Replica.
type Replica struct {
	PeerId  uint64 `json:"peer_id"`
	ShardId uint32 `json:"shard_id"`
}

// ReplicaSetTelemetry defines model for ReplicaSetTelemetry.
type ReplicaSetTelemetry struct {
	Id              uint32                     `json:"id"`
	Local           *ReplicaSetTelemetry_Local `json:"local,omitempty"`
	Remote          []RemoteShardTelemetry     `json:"remote"`
	ReplicateStates map[string]ReplicaState    `json:"replicate_states"`
}

// ReplicaSetTelemetryLocal1 defines model for .
type ReplicaSetTelemetryLocal1 = interface{}

// ReplicaSetTelemetry_Local defines model for ReplicaSetTelemetry.Local.
type ReplicaSetTelemetry_Local struct {
	union json.RawMessage
}

// ReplicaState State of the single shard within a replica set.
type ReplicaState string

// ReplicateShardOperation defines model for ReplicateShardOperation.
type ReplicateShardOperation struct {
	ReplicateShard MoveShard `json:"replicate_shard"`
}

// RequestsTelemetry defines model for RequestsTelemetry.
type RequestsTelemetry struct {
	Grpc GrpcTelemetry   `json:"grpc"`
	Rest WebApiTelemetry `json:"rest"`
}

// RunningEnvironmentTelemetry defines model for RunningEnvironmentTelemetry.
type RunningEnvironmentTelemetry struct {
	Cores               *uint   `json:"cores"`
	CpuFlags            string  `json:"cpu_flags"`
	DiskSize            *uint   `json:"disk_size"`
	Distribution        *string `json:"distribution"`
	DistributionVersion *string `json:"distribution_version"`
	IsDocker            bool    `json:"is_docker"`
	RamSize             *uint   `json:"ram_size"`
}

// ScalarQuantization defines model for ScalarQuantization.
type ScalarQuantization struct {
	Scalar ScalarQuantizationConfig `json:"scalar"`
}

// ScalarQuantizationConfig defines model for ScalarQuantizationConfig.
type ScalarQuantizationConfig struct {
	// AlwaysRam If true - quantized vectors always will be stored in RAM, ignoring the config of main storage
	AlwaysRam *bool `json:"always_ram"`

	// Quantile Quantile for quantization. Expected value range in (0, 1.0]. If not set - use the whole range of values
	Quantile *float32   `json:"quantile"`
	Type     ScalarType `json:"type"`
}

// ScalarType defines model for ScalarType.
type ScalarType string

// ScoredPoint Search result
type ScoredPoint struct {
	// Id Type, used for specifying point ID in user interface
	Id ExtendedPointId `json:"id"`

	// Payload Payload - values assigned to the point
	Payload *ScoredPoint_Payload `json:"payload,omitempty"`

	// Score Points vector distance to the query vector
	Score float32 `json:"score"`

	// Vector Vector of the point
	Vector *ScoredPoint_Vector `json:"vector,omitempty"`

	// Version Point version
	Version uint64 `json:"version"`
}

// ScoredPointPayload1 defines model for .
type ScoredPointPayload1 = interface{}

// ScoredPoint_Payload Payload - values assigned to the point
type ScoredPoint_Payload struct {
	union json.RawMessage
}

// ScoredPointVector1 defines model for .
type ScoredPointVector1 = interface{}

// ScoredPoint_Vector Vector of the point
type ScoredPoint_Vector struct {
	union json.RawMessage
}

// ScrollRequest Scroll request - paginate over all points which matches given condition
type ScrollRequest struct {
	// Filter Look only for points which satisfies this conditions. If not provided - all points.
	Filter *ScrollRequest_Filter `json:"filter,omitempty"`

	// Limit Page size. Default: 10
	Limit *uint `json:"limit"`

	// Offset Start ID to read points from.
	Offset *ScrollRequest_Offset `json:"offset,omitempty"`

	// WithPayload Select which payload to return with the response. Default: All
	WithPayload *ScrollRequest_WithPayload `json:"with_payload,omitempty"`

	// WithVector Options for specifying which vector to include
	WithVector *WithVector `json:"with_vector,omitempty"`
}

// ScrollRequestFilter1 defines model for .
type ScrollRequestFilter1 = interface{}

// ScrollRequest_Filter Look only for points which satisfies this conditions. If not provided - all points.
type ScrollRequest_Filter struct {
	union json.RawMessage
}

// ScrollRequestOffset1 defines model for .
type ScrollRequestOffset1 = interface{}

// ScrollRequest_Offset Start ID to read points from.
type ScrollRequest_Offset struct {
	union json.RawMessage
}

// ScrollRequestWithPayload1 defines model for .
type ScrollRequestWithPayload1 = interface{}

// ScrollRequest_WithPayload Select which payload to return with the response. Default: All
type ScrollRequest_WithPayload struct {
	union json.RawMessage
}

// ScrollResult Result of the points read request
type ScrollResult struct {
	// NextPageOffset Offset which should be used to retrieve a next page result
	NextPageOffset *ScrollResult_NextPageOffset `json:"next_page_offset,omitempty"`

	// Points List of retrieved points
	Points []Record `json:"points"`
}

// ScrollResultNextPageOffset1 defines model for .
type ScrollResultNextPageOffset1 = interface{}

// ScrollResult_NextPageOffset Offset which should be used to retrieve a next page result
type ScrollResult_NextPageOffset struct {
	union json.RawMessage
}

// SearchParams Additional parameters of the search
type SearchParams struct {
	// Exact Search without approximation. If set to true, search may run long but with exact results.
	Exact *bool `json:"exact,omitempty"`

	// HnswEf Params relevant to HNSW index /// Size of the beam in a beam-search. Larger the value - more accurate the result, more time required for search.
	HnswEf *uint `json:"hnsw_ef"`

	// Quantization Quantization params
	Quantization *SearchParams_Quantization `json:"quantization,omitempty"`
}

// SearchParamsQuantization1 defines model for .
type SearchParamsQuantization1 = interface{}

// SearchParams_Quantization Quantization params
type SearchParams_Quantization struct {
	union json.RawMessage
}

// SearchRequest Search request. Holds all conditions and parameters for the search of most similar points by vector similarity given the filtering restrictions.
type SearchRequest struct {
	// Filter Look only for points which satisfies this conditions
	Filter *SearchRequest_Filter `json:"filter,omitempty"`

	// Limit Max number of result to return
	Limit uint `json:"limit"`

	// Offset Offset of the first result to return. May be used to paginate results. Note: large offset values may cause performance issues.
	Offset *uint `json:"offset,omitempty"`

	// Params Additional search params
	Params *SearchRequest_Params `json:"params,omitempty"`

	// ScoreThreshold Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.
	ScoreThreshold *float32 `json:"score_threshold"`

	// Vector Vector data separator for named and unnamed modes Unanmed mode:
	//
	// { "vector": [1.0, 2.0, 3.0] }
	//
	// or named mode:
	//
	// { "vector": { "vector": [1.0, 2.0, 3.0], "name": "image-embeddings" } }
	Vector NamedVectorStruct `json:"vector"`

	// WithPayload Select which payload to return with the response. Default: None
	WithPayload bool `json:"with_payload,omitempty"`

	// WithVector Whether to return the point vector with the result?
	WithVector *SearchRequest_WithVector `json:"with_vector,omitempty"`
}

// SearchRequestFilter1 defines model for .
type SearchRequestFilter1 = interface{}

// SearchRequest_Filter Look only for points which satisfies this conditions
type SCValue struct {
	Value interface{} `json:"value"`
}
type SCIsEmpty struct {
	Key string `json:"key,omitempty"`
}

type Number interface {
	constraints.Integer | constraints.Float
}

type SCRange[T Number] struct {
	Key string `json:"key,omitempty"`
	Gt *T `json:"gt,omitempty"`
	Gte *T `json:"gte,omitempty"`
	Lt *T `json:"lt,omitempty"`
	Lte *T `json:"lte,omitempty"`
}
type SCMatchCondition struct {
	Key  string `json:"key,omitempty"`
	Match *SCValue `json:"match,omitempty"`
	IsEmpty *SCIsEmpty `json:"is_empty,omitempty"`
	// ! TODO Interface since we can't embed a generic struct?
	Range interface{} `json:"range,omitempty"`
}

type SearchRequest_Filter struct {
	Must []SCMatchCondition `json:"must,omitempty"`
	MustNot []SCMatchCondition `json:"must_not,omitempty"`
	Should []SCMatchCondition `json:"should,omitempty"`
}

// SearchRequestParams1 defines model for .
type SearchRequestParams1 = interface{}

// SearchRequest_Params Additional search params
type SearchRequest_Params struct {
	union json.RawMessage
}

// SearchRequestWithPayload1 defines model for .
type SearchRequestWithPayload1 = interface{}

// SearchRequest_WithPayload Select which payload to return with the response. Default: None
type SearchRequest_WithPayload struct {
	union json.RawMessage
}

// SearchRequestWithVector1 defines model for .
type SearchRequestWithVector1 = interface{}

// SearchRequest_WithVector Whether to return the point vector with the result?
type SearchRequest_WithVector struct {
	union json.RawMessage
}

// SearchRequestBatch defines model for SearchRequestBatch.
type SearchRequestBatch struct {
	Searches []SearchRequest `json:"searches"`
}

// SegmentConfig defines model for SegmentConfig.
type SegmentConfig struct {
	// Index Vector index configuration of the segment
	Index Indexes `json:"index"`

	// PayloadStorageType Type of payload storage
	PayloadStorageType *PayloadStorageType `json:"payload_storage_type,omitempty"`

	// QuantizationConfig Quantization parameters. If none - quantization is disabled.
	QuantizationConfig *SegmentConfig_QuantizationConfig `json:"quantization_config,omitempty"`

	// StorageType Type of vector storage
	StorageType StorageType                 `json:"storage_type"`
	VectorData  map[string]VectorDataConfig `json:"vector_data"`
}

// SegmentConfigQuantizationConfig1 defines model for .
type SegmentConfigQuantizationConfig1 = interface{}

// SegmentConfig_QuantizationConfig Quantization parameters. If none - quantization is disabled.
type SegmentConfig_QuantizationConfig struct {
	union json.RawMessage
}

// SegmentInfo Aggregated information about segment
type SegmentInfo struct {
	DiskUsageBytes    uint                        `json:"disk_usage_bytes"`
	IndexSchema       map[string]PayloadIndexInfo `json:"index_schema"`
	IsAppendable      bool                        `json:"is_appendable"`
	NumDeletedVectors uint                        `json:"num_deleted_vectors"`
	NumPoints         uint                        `json:"num_points"`
	NumVectors        uint                        `json:"num_vectors"`
	RamUsageBytes     uint                        `json:"ram_usage_bytes"`

	// SegmentType Type of segment
	SegmentType SegmentType `json:"segment_type"`
}

// SegmentTelemetry defines model for SegmentTelemetry.
type SegmentTelemetry struct {
	Config SegmentConfig `json:"config"`

	// Info Aggregated information about segment
	Info                SegmentInfo                    `json:"info"`
	PayloadFieldIndices []PayloadIndexTelemetry        `json:"payload_field_indices"`
	VectorIndexSearches []VectorIndexSearchesTelemetry `json:"vector_index_searches"`
}

// SegmentType Type of segment
type SegmentType string

// SetPayload defines model for SetPayload.
type SetPayload struct {
	// Filter Assigns payload to each point that satisfy this filter condition
	Filter  *SetPayload_Filter `json:"filter,omitempty"`
	Payload Payload            `json:"payload"`

	// Points Assigns payload to each point in this list
	Points *[]ExtendedPointId `json:"points"`
}

// SetPayloadFilter1 defines model for .
type SetPayloadFilter1 = interface{}

// SetPayload_Filter Assigns payload to each point that satisfy this filter condition
type SetPayload_Filter struct {
	union json.RawMessage
}

// ShardTransferInfo defines model for ShardTransferInfo.
type ShardTransferInfo struct {
	From    uint64 `json:"from"`
	ShardId uint32 `json:"shard_id"`

	// Sync If `true` transfer is a synchronization of a replicas If `false` transfer is a moving of a shard from one peer to another
	Sync bool   `json:"sync"`
	To   uint64 `json:"to"`
}

// SnapshotDescription defines model for SnapshotDescription.
type SnapshotDescription struct {
	CreationTime *string `json:"creation_time"`
	Name         string  `json:"name"`
	Size         uint64  `json:"size"`
}

// SnapshotPriority Defines source of truth for snapshot recovery `Snapshot` means - prefer snapshot data over the current state `Replica` means - prefer existing data over the snapshot
type SnapshotPriority string

// SnapshotRecover defines model for SnapshotRecover.
type SnapshotRecover struct {
	// Location Examples: - URL `http://localhost:8080/collections/my_collection/snapshots/my_snapshot` - Local path `file:///qdrant/snapshots/test_collection-2022-08-04-10-49-10.snapshot`
	Location string `json:"location"`

	// Priority Defines which data should be used as a source of truth if there are other replicas in the cluster. If set to `Snapshot`, the snapshot will be used as a source of truth, and the current state will be overwritten. If set to `Replica`, the current state will be used as a source of truth, and after recovery if will be synchronized with the snapshot.
	Priority *SnapshotRecover_Priority `json:"priority,omitempty"`
}

// SnapshotRecoverPriority1 defines model for .
type SnapshotRecoverPriority1 = interface{}

// SnapshotRecover_Priority Defines which data should be used as a source of truth if there are other replicas in the cluster. If set to `Snapshot`, the snapshot will be used as a source of truth, and the current state will be overwritten. If set to `Replica`, the current state will be used as a source of truth, and after recovery if will be synchronized with the snapshot.
type SnapshotRecover_Priority struct {
	union json.RawMessage
}

// StateRole Role of the peer in the consensus
type StateRole string

// StorageType Type of vector storage
type StorageType struct {
	union json.RawMessage
}

// StorageType0 defines model for .
type StorageType0 struct {
	Type StorageType `json:"type"`
}

// StorageType1 defines model for .
type StorageType1 struct {
	Type StorageType `json:"type"`
}

// TelemetryData defines model for TelemetryData.
type TelemetryData struct {
	App         AppBuildTelemetry    `json:"app"`
	Cluster     ClusterTelemetry     `json:"cluster"`
	Collections CollectionsTelemetry `json:"collections"`
	Id          string               `json:"id"`
	Requests    RequestsTelemetry    `json:"requests"`
}

// TextIndexParams defines model for TextIndexParams.
type TextIndexParams struct {
	// Lowercase If true, lowercase all tokens. Default: true
	Lowercase   *bool          `json:"lowercase"`
	MaxTokenLen *uint          `json:"max_token_len"`
	MinTokenLen *uint          `json:"min_token_len"`
	Tokenizer   *TokenizerType `json:"tokenizer,omitempty"`
	Type        TextIndexType  `json:"type"`
}

// TextIndexType defines model for TextIndexType.
type TextIndexType string

// TokenizerType defines model for TokenizerType.
type TokenizerType string

// UpdateCollection Operation for updating parameters of the existing collection
type UpdateCollection struct {
	// OptimizersConfig Custom params for Optimizers.  If none - values from service configuration file are used. This operation is blocking, it will only proceed ones all current optimizations are complete
	OptimizersConfig *UpdateCollection_OptimizersConfig `json:"optimizers_config,omitempty"`

	// Params Collection base params.  If none - values from service configuration file are used.
	Params *UpdateCollection_Params `json:"params,omitempty"`
}

// UpdateCollectionOptimizersConfig1 defines model for .
type UpdateCollectionOptimizersConfig1 = interface{}

// UpdateCollection_OptimizersConfig Custom params for Optimizers.  If none - values from service configuration file are used. This operation is blocking, it will only proceed ones all current optimizations are complete
type UpdateCollection_OptimizersConfig struct {
	union json.RawMessage
}

// UpdateCollectionParams1 defines model for .
type UpdateCollectionParams1 = interface{}

// UpdateCollection_Params Collection base params.  If none - values from service configuration file are used.
type UpdateCollection_Params struct {
	union json.RawMessage
}

// UpdateResult defines model for UpdateResult.
type UpdateResult struct {
	// OperationId Sequential number of the operation
	OperationId uint64 `json:"operation_id"`

	// Status `Acknowledged` - Request is saved to WAL and will be process in a queue. `Completed` - Request is completed, changes are actual.
	Status UpdateStatus `json:"status"`
}

// UpdateStatus `Acknowledged` - Request is saved to WAL and will be process in a queue. `Completed` - Request is completed, changes are actual.
type UpdateStatus string

// UsingVector defines model for UsingVector.
type UsingVector struct {
	union json.RawMessage
}

// UsingVector0 defines model for .
type UsingVector0 = string

// ValueVariants defines model for ValueVariants.
type ValueVariants struct {
	union json.RawMessage
}

// ValueVariants0 defines model for .
type ValueVariants0 = string

// ValueVariants1 defines model for .
type ValueVariants1 = int64

// ValueVariants2 defines model for .
type ValueVariants2 = bool

// ValuesCount Values count filter request
type ValuesCount struct {
	// Gt point.key.length() > values_count.gt
	Gt *uint `json:"gt"`

	// Gte point.key.length() >= values_count.gte
	Gte *uint `json:"gte"`

	// Lt point.key.length() < values_count.lt
	Lt *uint `json:"lt"`

	// Lte point.key.length() <= values_count.lte
	Lte *uint `json:"lte"`
}

// VectorDataConfig Config of single vector data storage
type VectorDataConfig struct {
	// Distance Type of internal tags, build from payload Distance function types used to compare vectors
	Distance Distance `json:"distance"`

	// Size Size of a vectors used
	Size uint `json:"size"`
}

// VectorIndexSearchesTelemetry defines model for VectorIndexSearchesTelemetry.
type VectorIndexSearchesTelemetry struct {
	FilteredExact            OperationDurationStatistics `json:"filtered_exact"`
	FilteredLargeCardinality OperationDurationStatistics `json:"filtered_large_cardinality"`
	FilteredPlain            OperationDurationStatistics `json:"filtered_plain"`
	FilteredSmallCardinality OperationDurationStatistics `json:"filtered_small_cardinality"`
	IndexName                *string                     `json:"index_name"`
	UnfilteredExact          OperationDurationStatistics `json:"unfiltered_exact"`
	UnfilteredHnsw           OperationDurationStatistics `json:"unfiltered_hnsw"`
	UnfilteredPlain          OperationDurationStatistics `json:"unfiltered_plain"`
}

// VectorParams Params of single vector data storage
type VectorParams struct {
	// Distance Type of internal tags, build from payload Distance function types used to compare vectors
	Distance Distance `json:"distance"`

	// Size Size of a vectors used
	Size uint64 `json:"size"`
}

// VectorStruct Full vector data per point separator with single and multiple vector modes
type VectorStruct struct {
	union json.RawMessage
}

// VectorStruct0 defines model for .
type VectorStruct0 = []float32

// VectorStruct1 defines model for .
type VectorStruct1 map[string][]float32

// VectorsConfig Vector params separator for single and multiple vector modes Single mode:
//
// { "size": 128, "distance": "Cosine" }
//
// or multiple mode:
//
// { "default": { "size": 128, "distance": "Cosine" } }
type VectorsConfig struct {
	union json.RawMessage
}

// VectorsConfig1 defines model for .
type VectorsConfig1 map[string]VectorParams

// WalConfig defines model for WalConfig.
type WalConfig struct {
	// WalCapacityMb Size of a single WAL segment in MB
	WalCapacityMb uint `json:"wal_capacity_mb"`

	// WalSegmentsAhead Number of WAL segments to create ahead of actually used ones
	WalSegmentsAhead uint `json:"wal_segments_ahead"`
}

// WalConfigDiff defines model for WalConfigDiff.
type WalConfigDiff struct {
	// WalCapacityMb Size of a single WAL segment in MB
	WalCapacityMb *uint `json:"wal_capacity_mb"`

	// WalSegmentsAhead Number of WAL segments to create ahead of actually used ones
	WalSegmentsAhead *uint `json:"wal_segments_ahead"`
}

// WebApiTelemetry defines model for WebApiTelemetry.
type WebApiTelemetry struct {
	Responses map[string]map[string]OperationDurationStatistics `json:"responses"`
}

// WithPayloadInterface Options for specifying which payload to include or not
type WithPayloadInterface struct {
	union json.RawMessage
}

// WithPayloadInterface0 If `true` - return all payload, If `false` - do not return payload
type WithPayloadInterface0 = bool

// WithPayloadInterface1 Specify which fields to return
type WithPayloadInterface1 = []string

// WithVector Options for specifying which vector to include
type WithVector struct {
	union json.RawMessage
}

// WithVector0 If `true` - return all vector, If `false` - do not return vector
type WithVector0 = bool

// WithVector1 Specify which vector to return
type WithVector1 = []string

// WriteOrdering Defines write ordering guarantees for collection operations
//
// * `weak` - write operations may be reordered, works faster, default
//
// * `medium` - write operations go through dynamically selected leader, may be inconsistent for a short period of time in case of leader change
//
// * `strong` - Write operations go through the permanent leader, consistent, but may be unavailable if leader is down
type WriteOrdering string

// RemovePeerParams defines parameters for RemovePeer.
type RemovePeerParams struct {
	// Force If true - removes peer even if it has shards/replicas on it.
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// UpdateAliasesParams defines parameters for UpdateAliases.
type UpdateAliasesParams struct {
	// Timeout Wait for operation commit timeout in seconds.
	// If timeout is reached - request will return with service error.
	Timeout *int `form:"timeout,omitempty" json:"timeout,omitempty"`
}

// DeleteCollectionParams defines parameters for DeleteCollection.
type DeleteCollectionParams struct {
	// Timeout Wait for operation commit timeout in seconds.
	// If timeout is reached - request will return with service error.
	Timeout *int `form:"timeout,omitempty" json:"timeout,omitempty"`
}

// UpdateCollectionParams defines parameters for UpdateCollection.
type UpdateCollectionParams struct {
	// Timeout Wait for operation commit timeout in seconds.
	// If timeout is reached - request will return with service error.
	Timeout *int `form:"timeout,omitempty" json:"timeout,omitempty"`
}

// CreateCollectionParams defines parameters for CreateCollection.
type CreateCollectionParams struct {
	// Timeout Wait for operation commit timeout in seconds.
	// If timeout is reached - request will return with service error.
	Timeout *int `form:"timeout,omitempty" json:"timeout,omitempty"`
}

// UpdateCollectionClusterParams defines parameters for UpdateCollectionCluster.
type UpdateCollectionClusterParams struct {
	// Timeout Wait for operation commit timeout in seconds.
	// If timeout is reached - request will return with service error.
	Timeout *int `form:"timeout,omitempty" json:"timeout,omitempty"`
}

// CreateFieldIndexParams defines parameters for CreateFieldIndex.
type CreateFieldIndexParams struct {
	// Wait If true, wait for changes to actually happen
	Wait *bool `form:"wait,omitempty" json:"wait,omitempty"`

	// Ordering define ordering guarantees for the operation
	Ordering *WriteOrdering `form:"ordering,omitempty" json:"ordering,omitempty"`
}

// DeleteFieldIndexParams defines parameters for DeleteFieldIndex.
type DeleteFieldIndexParams struct {
	// Wait If true, wait for changes to actually happen
	Wait *bool `form:"wait,omitempty" json:"wait,omitempty"`

	// Ordering define ordering guarantees for the operation
	Ordering *WriteOrdering `form:"ordering,omitempty" json:"ordering,omitempty"`
}

// GetPointsParams defines parameters for GetPoints.
type GetPointsParams struct {
	// Consistency Define read consistency guarantees for the operation
	Consistency *ReadConsistency `form:"consistency,omitempty" json:"consistency,omitempty"`
}

// UpsertPointsParams defines parameters for UpsertPoints.
type UpsertPointsParams struct {
	// Wait If true, wait for changes to actually happen
	Wait *bool `form:"wait,omitempty" json:"wait,omitempty"`

	// Ordering define ordering guarantees for the operation
	Ordering *WriteOrdering `form:"ordering,omitempty" json:"ordering,omitempty"`
}

// DeletePointsParams defines parameters for DeletePoints.
type DeletePointsParams struct {
	// Wait If true, wait for changes to actually happen
	Wait *bool `form:"wait,omitempty" json:"wait,omitempty"`

	// Ordering define ordering guarantees for the operation
	Ordering *WriteOrdering `form:"ordering,omitempty" json:"ordering,omitempty"`
}

// SetPayloadParams defines parameters for SetPayload.
type SetPayloadParams struct {
	// Wait If true, wait for changes to actually happen
	Wait *bool `form:"wait,omitempty" json:"wait,omitempty"`

	// Ordering define ordering guarantees for the operation
	Ordering *WriteOrdering `form:"ordering,omitempty" json:"ordering,omitempty"`
}

// OverwritePayloadParams defines parameters for OverwritePayload.
type OverwritePayloadParams struct {
	// Wait If true, wait for changes to actually happen
	Wait *bool `form:"wait,omitempty" json:"wait,omitempty"`

	// Ordering define ordering guarantees for the operation
	Ordering *WriteOrdering `form:"ordering,omitempty" json:"ordering,omitempty"`
}

// ClearPayloadParams defines parameters for ClearPayload.
type ClearPayloadParams struct {
	// Wait If true, wait for changes to actually happen
	Wait *bool `form:"wait,omitempty" json:"wait,omitempty"`

	// Ordering define ordering guarantees for the operation
	Ordering *WriteOrdering `form:"ordering,omitempty" json:"ordering,omitempty"`
}

// DeletePayloadParams defines parameters for DeletePayload.
type DeletePayloadParams struct {
	// Wait If true, wait for changes to actually happen
	Wait *bool `form:"wait,omitempty" json:"wait,omitempty"`

	// Ordering define ordering guarantees for the operation
	Ordering *WriteOrdering `form:"ordering,omitempty" json:"ordering,omitempty"`
}

// RecommendPointsParams defines parameters for RecommendPoints.
type RecommendPointsParams struct {
	// Consistency Define read consistency guarantees for the operation
	Consistency *ReadConsistency `form:"consistency,omitempty" json:"consistency,omitempty"`
}

// RecommendBatchPointsParams defines parameters for RecommendBatchPoints.
type RecommendBatchPointsParams struct {
	// Consistency Define read consistency guarantees for the operation
	Consistency *ReadConsistency `form:"consistency,omitempty" json:"consistency,omitempty"`
}

// ScrollPointsParams defines parameters for ScrollPoints.
type ScrollPointsParams struct {
	// Consistency Define read consistency guarantees for the operation
	Consistency *ReadConsistency `form:"consistency,omitempty" json:"consistency,omitempty"`
}

// SearchPointsParams defines parameters for SearchPoints.
type SearchPointsParams struct {
	// Consistency Define read consistency guarantees for the operation
	Consistency *ReadConsistency `form:"consistency,omitempty" json:"consistency,omitempty"`
}

// SearchBatchPointsParams defines parameters for SearchBatchPoints.
type SearchBatchPointsParams struct {
	// Consistency Define read consistency guarantees for the operation
	Consistency *ReadConsistency `form:"consistency,omitempty" json:"consistency,omitempty"`
}

// GetPointParams defines parameters for GetPoint.
type GetPointParams struct {
	// Consistency Define read consistency guarantees for the operation
	Consistency *ReadConsistency `form:"consistency,omitempty" json:"consistency,omitempty"`
}

// RecoverFromSnapshotParams defines parameters for RecoverFromSnapshot.
type RecoverFromSnapshotParams struct {
	// Wait If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
	Wait *bool `form:"wait,omitempty" json:"wait,omitempty"`
}

// MetricsParams defines parameters for Metrics.
type MetricsParams struct {
	// Anonymize If true, anonymize result
	Anonymize *bool `form:"anonymize,omitempty" json:"anonymize,omitempty"`
}

// TelemetryParams defines parameters for Telemetry.
type TelemetryParams struct {
	// Anonymize If true, anonymize result
	Anonymize *bool `form:"anonymize,omitempty" json:"anonymize,omitempty"`
}

// UpdateAliasesJSONRequestBody defines body for UpdateAliases for application/json ContentType.
type UpdateAliasesJSONRequestBody = ChangeAliasesOperation

// UpdateCollectionJSONRequestBody defines body for UpdateCollection for application/json ContentType.
type UpdateCollectionJSONRequestBody = UpdateCollection

// CreateCollectionJSONRequestBody defines body for CreateCollection for application/json ContentType.
type CreateCollectionJSONRequestBody = CreateCollection

// UpdateCollectionClusterJSONRequestBody defines body for UpdateCollectionCluster for application/json ContentType.
type UpdateCollectionClusterJSONRequestBody = ClusterOperations

// CreateFieldIndexJSONRequestBody defines body for CreateFieldIndex for application/json ContentType.
type CreateFieldIndexJSONRequestBody = CreateFieldIndex

// GetPointsJSONRequestBody defines body for GetPoints for application/json ContentType.
type GetPointsJSONRequestBody = PointRequest

// UpsertPointsJSONRequestBody defines body for UpsertPoints for application/json ContentType.
type UpsertPointsJSONRequestBody = PointInsertOperations

// CountPointsJSONRequestBody defines body for CountPoints for application/json ContentType.
type CountPointsJSONRequestBody = CountRequest

// DeletePointsJSONRequestBody defines body for DeletePoints for application/json ContentType.
type DeletePointsJSONRequestBody = PointsSelector

// SetPayloadJSONRequestBody defines body for SetPayload for application/json ContentType.
type SetPayloadJSONRequestBody = SetPayload

// OverwritePayloadJSONRequestBody defines body for OverwritePayload for application/json ContentType.
type OverwritePayloadJSONRequestBody = SetPayload

// ClearPayloadJSONRequestBody defines body for ClearPayload for application/json ContentType.
type ClearPayloadJSONRequestBody = PointsSelector

// DeletePayloadJSONRequestBody defines body for DeletePayload for application/json ContentType.
type DeletePayloadJSONRequestBody = DeletePayload

// RecommendPointsJSONRequestBody defines body for RecommendPoints for application/json ContentType.
type RecommendPointsJSONRequestBody = RecommendRequest

// RecommendBatchPointsJSONRequestBody defines body for RecommendBatchPoints for application/json ContentType.
type RecommendBatchPointsJSONRequestBody = RecommendRequestBatch

// ScrollPointsJSONRequestBody defines body for ScrollPoints for application/json ContentType.
type ScrollPointsJSONRequestBody = ScrollRequest

// SearchPointsJSONRequestBody defines body for SearchPoints for application/json ContentType.
type SearchPointsJSONRequestBody = SearchRequest

// SearchBatchPointsJSONRequestBody defines body for SearchBatchPoints for application/json ContentType.
type SearchBatchPointsJSONRequestBody = SearchRequestBatch

// RecoverFromSnapshotJSONRequestBody defines body for RecoverFromSnapshot for application/json ContentType.
type RecoverFromSnapshotJSONRequestBody = SnapshotRecover

// PostLocksJSONRequestBody defines body for PostLocks for application/json ContentType.
type PostLocksJSONRequestBody = LocksOption

// AsCreateAliasOperation returns the union data inside the AliasOperations as a CreateAliasOperation
func (t AliasOperations) AsCreateAliasOperation() (CreateAliasOperation, error) {
	var body CreateAliasOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAliasOperation overwrites any union data inside the AliasOperations as the provided CreateAliasOperation
func (t *AliasOperations) FromCreateAliasOperation(v CreateAliasOperation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAliasOperation performs a merge with any union data inside the AliasOperations, using the provided CreateAliasOperation
func (t *AliasOperations) MergeCreateAliasOperation(v CreateAliasOperation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsDeleteAliasOperation returns the union data inside the AliasOperations as a DeleteAliasOperation
func (t AliasOperations) AsDeleteAliasOperation() (DeleteAliasOperation, error) {
	var body DeleteAliasOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeleteAliasOperation overwrites any union data inside the AliasOperations as the provided DeleteAliasOperation
func (t *AliasOperations) FromDeleteAliasOperation(v DeleteAliasOperation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeleteAliasOperation performs a merge with any union data inside the AliasOperations, using the provided DeleteAliasOperation
func (t *AliasOperations) MergeDeleteAliasOperation(v DeleteAliasOperation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRenameAliasOperation returns the union data inside the AliasOperations as a RenameAliasOperation
func (t AliasOperations) AsRenameAliasOperation() (RenameAliasOperation, error) {
	var body RenameAliasOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRenameAliasOperation overwrites any union data inside the AliasOperations as the provided RenameAliasOperation
func (t *AliasOperations) FromRenameAliasOperation(v RenameAliasOperation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRenameAliasOperation performs a merge with any union data inside the AliasOperations, using the provided RenameAliasOperation
func (t *AliasOperations) MergeRenameAliasOperation(v RenameAliasOperation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t AliasOperations) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AliasOperations) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAnyVariants0 returns the union data inside the AnyVariants as a AnyVariants0
func (t AnyVariants) AsAnyVariants0() (AnyVariants0, error) {
	var body AnyVariants0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnyVariants0 overwrites any union data inside the AnyVariants as the provided AnyVariants0
func (t *AnyVariants) FromAnyVariants0(v AnyVariants0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnyVariants0 performs a merge with any union data inside the AnyVariants, using the provided AnyVariants0
func (t *AnyVariants) MergeAnyVariants0(v AnyVariants0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAnyVariants1 returns the union data inside the AnyVariants as a AnyVariants1
func (t AnyVariants) AsAnyVariants1() (AnyVariants1, error) {
	var body AnyVariants1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnyVariants1 overwrites any union data inside the AnyVariants as the provided AnyVariants1
func (t *AnyVariants) FromAnyVariants1(v AnyVariants1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnyVariants1 performs a merge with any union data inside the AnyVariants, using the provided AnyVariants1
func (t *AnyVariants) MergeAnyVariants1(v AnyVariants1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t AnyVariants) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AnyVariants) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAppFeaturesTelemetry returns the union data inside the AppBuildTelemetry_Features as a AppFeaturesTelemetry
func (t AppBuildTelemetry_Features) AsAppFeaturesTelemetry() (AppFeaturesTelemetry, error) {
	var body AppFeaturesTelemetry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppFeaturesTelemetry overwrites any union data inside the AppBuildTelemetry_Features as the provided AppFeaturesTelemetry
func (t *AppBuildTelemetry_Features) FromAppFeaturesTelemetry(v AppFeaturesTelemetry) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppFeaturesTelemetry performs a merge with any union data inside the AppBuildTelemetry_Features, using the provided AppFeaturesTelemetry
func (t *AppBuildTelemetry_Features) MergeAppFeaturesTelemetry(v AppFeaturesTelemetry) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAppBuildTelemetryFeatures1 returns the union data inside the AppBuildTelemetry_Features as a AppBuildTelemetryFeatures1
func (t AppBuildTelemetry_Features) AsAppBuildTelemetryFeatures1() (AppBuildTelemetryFeatures1, error) {
	var body AppBuildTelemetryFeatures1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppBuildTelemetryFeatures1 overwrites any union data inside the AppBuildTelemetry_Features as the provided AppBuildTelemetryFeatures1
func (t *AppBuildTelemetry_Features) FromAppBuildTelemetryFeatures1(v AppBuildTelemetryFeatures1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppBuildTelemetryFeatures1 performs a merge with any union data inside the AppBuildTelemetry_Features, using the provided AppBuildTelemetryFeatures1
func (t *AppBuildTelemetry_Features) MergeAppBuildTelemetryFeatures1(v AppBuildTelemetryFeatures1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t AppBuildTelemetry_Features) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AppBuildTelemetry_Features) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRunningEnvironmentTelemetry returns the union data inside the AppBuildTelemetry_System as a RunningEnvironmentTelemetry
func (t AppBuildTelemetry_System) AsRunningEnvironmentTelemetry() (RunningEnvironmentTelemetry, error) {
	var body RunningEnvironmentTelemetry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunningEnvironmentTelemetry overwrites any union data inside the AppBuildTelemetry_System as the provided RunningEnvironmentTelemetry
func (t *AppBuildTelemetry_System) FromRunningEnvironmentTelemetry(v RunningEnvironmentTelemetry) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunningEnvironmentTelemetry performs a merge with any union data inside the AppBuildTelemetry_System, using the provided RunningEnvironmentTelemetry
func (t *AppBuildTelemetry_System) MergeRunningEnvironmentTelemetry(v RunningEnvironmentTelemetry) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAppBuildTelemetrySystem1 returns the union data inside the AppBuildTelemetry_System as a AppBuildTelemetrySystem1
func (t AppBuildTelemetry_System) AsAppBuildTelemetrySystem1() (AppBuildTelemetrySystem1, error) {
	var body AppBuildTelemetrySystem1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppBuildTelemetrySystem1 overwrites any union data inside the AppBuildTelemetry_System as the provided AppBuildTelemetrySystem1
func (t *AppBuildTelemetry_System) FromAppBuildTelemetrySystem1(v AppBuildTelemetrySystem1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppBuildTelemetrySystem1 performs a merge with any union data inside the AppBuildTelemetry_System, using the provided AppBuildTelemetrySystem1
func (t *AppBuildTelemetry_System) MergeAppBuildTelemetrySystem1(v AppBuildTelemetrySystem1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t AppBuildTelemetry_System) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AppBuildTelemetry_System) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPayload returns the union data inside the Batch_Payloads_Item as a Payload
func (t Batch_Payloads_Item) AsPayload() (Payload, error) {
	var body Payload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayload overwrites any union data inside the Batch_Payloads_Item as the provided Payload
func (t *Batch_Payloads_Item) FromPayload(v Payload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayload performs a merge with any union data inside the Batch_Payloads_Item, using the provided Payload
func (t *Batch_Payloads_Item) MergePayload(v Payload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsBatchPayloads1 returns the union data inside the Batch_Payloads_Item as a BatchPayloads1
func (t Batch_Payloads_Item) AsBatchPayloads1() (BatchPayloads1, error) {
	var body BatchPayloads1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchPayloads1 overwrites any union data inside the Batch_Payloads_Item as the provided BatchPayloads1
func (t *Batch_Payloads_Item) FromBatchPayloads1(v BatchPayloads1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchPayloads1 performs a merge with any union data inside the Batch_Payloads_Item, using the provided BatchPayloads1
func (t *Batch_Payloads_Item) MergeBatchPayloads1(v BatchPayloads1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Batch_Payloads_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Batch_Payloads_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBatchVectorStruct0 returns the union data inside the BatchVectorStruct as a BatchVectorStruct0
func (t BatchVectorStruct) AsBatchVectorStruct0() (BatchVectorStruct0, error) {
	var body BatchVectorStruct0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchVectorStruct0 overwrites any union data inside the BatchVectorStruct as the provided BatchVectorStruct0
func (t *BatchVectorStruct) FromBatchVectorStruct0(v BatchVectorStruct0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchVectorStruct0 performs a merge with any union data inside the BatchVectorStruct, using the provided BatchVectorStruct0
func (t *BatchVectorStruct) MergeBatchVectorStruct0(v BatchVectorStruct0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsBatchVectorStruct1 returns the union data inside the BatchVectorStruct as a BatchVectorStruct1
func (t BatchVectorStruct) AsBatchVectorStruct1() (BatchVectorStruct1, error) {
	var body BatchVectorStruct1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchVectorStruct1 overwrites any union data inside the BatchVectorStruct as the provided BatchVectorStruct1
func (t *BatchVectorStruct) FromBatchVectorStruct1(v BatchVectorStruct1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchVectorStruct1 performs a merge with any union data inside the BatchVectorStruct, using the provided BatchVectorStruct1
func (t *BatchVectorStruct) MergeBatchVectorStruct1(v BatchVectorStruct1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t BatchVectorStruct) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BatchVectorStruct) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMoveShardOperation returns the union data inside the ClusterOperations as a MoveShardOperation
func (t ClusterOperations) AsMoveShardOperation() (MoveShardOperation, error) {
	var body MoveShardOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMoveShardOperation overwrites any union data inside the ClusterOperations as the provided MoveShardOperation
func (t *ClusterOperations) FromMoveShardOperation(v MoveShardOperation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMoveShardOperation performs a merge with any union data inside the ClusterOperations, using the provided MoveShardOperation
func (t *ClusterOperations) MergeMoveShardOperation(v MoveShardOperation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsReplicateShardOperation returns the union data inside the ClusterOperations as a ReplicateShardOperation
func (t ClusterOperations) AsReplicateShardOperation() (ReplicateShardOperation, error) {
	var body ReplicateShardOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReplicateShardOperation overwrites any union data inside the ClusterOperations as the provided ReplicateShardOperation
func (t *ClusterOperations) FromReplicateShardOperation(v ReplicateShardOperation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReplicateShardOperation performs a merge with any union data inside the ClusterOperations, using the provided ReplicateShardOperation
func (t *ClusterOperations) MergeReplicateShardOperation(v ReplicateShardOperation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAbortTransferOperation returns the union data inside the ClusterOperations as a AbortTransferOperation
func (t ClusterOperations) AsAbortTransferOperation() (AbortTransferOperation, error) {
	var body AbortTransferOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbortTransferOperation overwrites any union data inside the ClusterOperations as the provided AbortTransferOperation
func (t *ClusterOperations) FromAbortTransferOperation(v AbortTransferOperation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbortTransferOperation performs a merge with any union data inside the ClusterOperations, using the provided AbortTransferOperation
func (t *ClusterOperations) MergeAbortTransferOperation(v AbortTransferOperation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsDropReplicaOperation returns the union data inside the ClusterOperations as a DropReplicaOperation
func (t ClusterOperations) AsDropReplicaOperation() (DropReplicaOperation, error) {
	var body DropReplicaOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropReplicaOperation overwrites any union data inside the ClusterOperations as the provided DropReplicaOperation
func (t *ClusterOperations) FromDropReplicaOperation(v DropReplicaOperation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropReplicaOperation performs a merge with any union data inside the ClusterOperations, using the provided DropReplicaOperation
func (t *ClusterOperations) MergeDropReplicaOperation(v DropReplicaOperation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ClusterOperations) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ClusterOperations) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsClusterStatus0 returns the union data inside the ClusterStatus as a ClusterStatus0
func (t ClusterStatus) AsClusterStatus0() (ClusterStatus0, error) {
	var body ClusterStatus0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClusterStatus0 overwrites any union data inside the ClusterStatus as the provided ClusterStatus0
func (t *ClusterStatus) FromClusterStatus0(v ClusterStatus0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClusterStatus0 performs a merge with any union data inside the ClusterStatus, using the provided ClusterStatus0
func (t *ClusterStatus) MergeClusterStatus0(v ClusterStatus0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsClusterStatus1 returns the union data inside the ClusterStatus as a ClusterStatus1
func (t ClusterStatus) AsClusterStatus1() (ClusterStatus1, error) {
	var body ClusterStatus1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClusterStatus1 overwrites any union data inside the ClusterStatus as the provided ClusterStatus1
func (t *ClusterStatus) FromClusterStatus1(v ClusterStatus1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClusterStatus1 performs a merge with any union data inside the ClusterStatus, using the provided ClusterStatus1
func (t *ClusterStatus) MergeClusterStatus1(v ClusterStatus1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ClusterStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ClusterStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStateRole returns the union data inside the ClusterStatusTelemetry_Role as a StateRole
func (t ClusterStatusTelemetry_Role) AsStateRole() (StateRole, error) {
	var body StateRole
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStateRole overwrites any union data inside the ClusterStatusTelemetry_Role as the provided StateRole
func (t *ClusterStatusTelemetry_Role) FromStateRole(v StateRole) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStateRole performs a merge with any union data inside the ClusterStatusTelemetry_Role, using the provided StateRole
func (t *ClusterStatusTelemetry_Role) MergeStateRole(v StateRole) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsClusterStatusTelemetryRole1 returns the union data inside the ClusterStatusTelemetry_Role as a ClusterStatusTelemetryRole1
func (t ClusterStatusTelemetry_Role) AsClusterStatusTelemetryRole1() (ClusterStatusTelemetryRole1, error) {
	var body ClusterStatusTelemetryRole1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClusterStatusTelemetryRole1 overwrites any union data inside the ClusterStatusTelemetry_Role as the provided ClusterStatusTelemetryRole1
func (t *ClusterStatusTelemetry_Role) FromClusterStatusTelemetryRole1(v ClusterStatusTelemetryRole1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClusterStatusTelemetryRole1 performs a merge with any union data inside the ClusterStatusTelemetry_Role, using the provided ClusterStatusTelemetryRole1
func (t *ClusterStatusTelemetry_Role) MergeClusterStatusTelemetryRole1(v ClusterStatusTelemetryRole1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ClusterStatusTelemetry_Role) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ClusterStatusTelemetry_Role) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsClusterConfigTelemetry returns the union data inside the ClusterTelemetry_Config as a ClusterConfigTelemetry
func (t ClusterTelemetry_Config) AsClusterConfigTelemetry() (ClusterConfigTelemetry, error) {
	var body ClusterConfigTelemetry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClusterConfigTelemetry overwrites any union data inside the ClusterTelemetry_Config as the provided ClusterConfigTelemetry
func (t *ClusterTelemetry_Config) FromClusterConfigTelemetry(v ClusterConfigTelemetry) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClusterConfigTelemetry performs a merge with any union data inside the ClusterTelemetry_Config, using the provided ClusterConfigTelemetry
func (t *ClusterTelemetry_Config) MergeClusterConfigTelemetry(v ClusterConfigTelemetry) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsClusterTelemetryConfig1 returns the union data inside the ClusterTelemetry_Config as a ClusterTelemetryConfig1
func (t ClusterTelemetry_Config) AsClusterTelemetryConfig1() (ClusterTelemetryConfig1, error) {
	var body ClusterTelemetryConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClusterTelemetryConfig1 overwrites any union data inside the ClusterTelemetry_Config as the provided ClusterTelemetryConfig1
func (t *ClusterTelemetry_Config) FromClusterTelemetryConfig1(v ClusterTelemetryConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClusterTelemetryConfig1 performs a merge with any union data inside the ClusterTelemetry_Config, using the provided ClusterTelemetryConfig1
func (t *ClusterTelemetry_Config) MergeClusterTelemetryConfig1(v ClusterTelemetryConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ClusterTelemetry_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ClusterTelemetry_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsClusterStatusTelemetry returns the union data inside the ClusterTelemetry_Status as a ClusterStatusTelemetry
func (t ClusterTelemetry_Status) AsClusterStatusTelemetry() (ClusterStatusTelemetry, error) {
	var body ClusterStatusTelemetry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClusterStatusTelemetry overwrites any union data inside the ClusterTelemetry_Status as the provided ClusterStatusTelemetry
func (t *ClusterTelemetry_Status) FromClusterStatusTelemetry(v ClusterStatusTelemetry) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClusterStatusTelemetry performs a merge with any union data inside the ClusterTelemetry_Status, using the provided ClusterStatusTelemetry
func (t *ClusterTelemetry_Status) MergeClusterStatusTelemetry(v ClusterStatusTelemetry) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsClusterTelemetryStatus1 returns the union data inside the ClusterTelemetry_Status as a ClusterTelemetryStatus1
func (t ClusterTelemetry_Status) AsClusterTelemetryStatus1() (ClusterTelemetryStatus1, error) {
	var body ClusterTelemetryStatus1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClusterTelemetryStatus1 overwrites any union data inside the ClusterTelemetry_Status as the provided ClusterTelemetryStatus1
func (t *ClusterTelemetry_Status) FromClusterTelemetryStatus1(v ClusterTelemetryStatus1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClusterTelemetryStatus1 performs a merge with any union data inside the ClusterTelemetry_Status, using the provided ClusterTelemetryStatus1
func (t *ClusterTelemetry_Status) MergeClusterTelemetryStatus1(v ClusterTelemetryStatus1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ClusterTelemetry_Status) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ClusterTelemetry_Status) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantizationConfig returns the union data inside the CollectionConfig_QuantizationConfig as a QuantizationConfig
func (t CollectionConfig_QuantizationConfig) AsQuantizationConfig() (QuantizationConfig, error) {
	var body QuantizationConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantizationConfig overwrites any union data inside the CollectionConfig_QuantizationConfig as the provided QuantizationConfig
func (t *CollectionConfig_QuantizationConfig) FromQuantizationConfig(v QuantizationConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantizationConfig performs a merge with any union data inside the CollectionConfig_QuantizationConfig, using the provided QuantizationConfig
func (t *CollectionConfig_QuantizationConfig) MergeQuantizationConfig(v QuantizationConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCollectionConfigQuantizationConfig1 returns the union data inside the CollectionConfig_QuantizationConfig as a CollectionConfigQuantizationConfig1
func (t CollectionConfig_QuantizationConfig) AsCollectionConfigQuantizationConfig1() (CollectionConfigQuantizationConfig1, error) {
	var body CollectionConfigQuantizationConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCollectionConfigQuantizationConfig1 overwrites any union data inside the CollectionConfig_QuantizationConfig as the provided CollectionConfigQuantizationConfig1
func (t *CollectionConfig_QuantizationConfig) FromCollectionConfigQuantizationConfig1(v CollectionConfigQuantizationConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCollectionConfigQuantizationConfig1 performs a merge with any union data inside the CollectionConfig_QuantizationConfig, using the provided CollectionConfigQuantizationConfig1
func (t *CollectionConfig_QuantizationConfig) MergeCollectionConfigQuantizationConfig1(v CollectionConfigQuantizationConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CollectionConfig_QuantizationConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CollectionConfig_QuantizationConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCollectionTelemetry returns the union data inside the CollectionTelemetryEnum as a CollectionTelemetry
func (t CollectionTelemetryEnum) AsCollectionTelemetry() (CollectionTelemetry, error) {
	var body CollectionTelemetry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCollectionTelemetry overwrites any union data inside the CollectionTelemetryEnum as the provided CollectionTelemetry
func (t *CollectionTelemetryEnum) FromCollectionTelemetry(v CollectionTelemetry) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCollectionTelemetry performs a merge with any union data inside the CollectionTelemetryEnum, using the provided CollectionTelemetry
func (t *CollectionTelemetryEnum) MergeCollectionTelemetry(v CollectionTelemetry) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCollectionsAggregatedTelemetry returns the union data inside the CollectionTelemetryEnum as a CollectionsAggregatedTelemetry
func (t CollectionTelemetryEnum) AsCollectionsAggregatedTelemetry() (CollectionsAggregatedTelemetry, error) {
	var body CollectionsAggregatedTelemetry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCollectionsAggregatedTelemetry overwrites any union data inside the CollectionTelemetryEnum as the provided CollectionsAggregatedTelemetry
func (t *CollectionTelemetryEnum) FromCollectionsAggregatedTelemetry(v CollectionsAggregatedTelemetry) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCollectionsAggregatedTelemetry performs a merge with any union data inside the CollectionTelemetryEnum, using the provided CollectionsAggregatedTelemetry
func (t *CollectionTelemetryEnum) MergeCollectionsAggregatedTelemetry(v CollectionsAggregatedTelemetry) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CollectionTelemetryEnum) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CollectionTelemetryEnum) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFieldCondition returns the union data inside the Condition as a FieldCondition
func (t Condition) AsFieldCondition() (FieldCondition, error) {
	var body FieldCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldCondition overwrites any union data inside the Condition as the provided FieldCondition
func (t *Condition) FromFieldCondition(v FieldCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldCondition performs a merge with any union data inside the Condition, using the provided FieldCondition
func (t *Condition) MergeFieldCondition(v FieldCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsIsEmptyCondition returns the union data inside the Condition as a IsEmptyCondition
func (t Condition) AsIsEmptyCondition() (IsEmptyCondition, error) {
	var body IsEmptyCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIsEmptyCondition overwrites any union data inside the Condition as the provided IsEmptyCondition
func (t *Condition) FromIsEmptyCondition(v IsEmptyCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIsEmptyCondition performs a merge with any union data inside the Condition, using the provided IsEmptyCondition
func (t *Condition) MergeIsEmptyCondition(v IsEmptyCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsHasIdCondition returns the union data inside the Condition as a HasIdCondition
func (t Condition) AsHasIdCondition() (HasIdCondition, error) {
	var body HasIdCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHasIdCondition overwrites any union data inside the Condition as the provided HasIdCondition
func (t *Condition) FromHasIdCondition(v HasIdCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHasIdCondition performs a merge with any union data inside the Condition, using the provided HasIdCondition
func (t *Condition) MergeHasIdCondition(v HasIdCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsFilter returns the union data inside the Condition as a Filter
func (t Condition) AsFilter() (Filter, error) {
	var body Filter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFilter overwrites any union data inside the Condition as the provided Filter
func (t *Condition) FromFilter(v Filter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFilter performs a merge with any union data inside the Condition, using the provided Filter
func (t *Condition) MergeFilter(v Filter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Condition) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Condition) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsConsensusThreadStatus0 returns the union data inside the ConsensusThreadStatus as a ConsensusThreadStatus0
func (t ConsensusThreadStatus) AsConsensusThreadStatus0() (ConsensusThreadStatus0, error) {
	var body ConsensusThreadStatus0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsensusThreadStatus0 overwrites any union data inside the ConsensusThreadStatus as the provided ConsensusThreadStatus0
func (t *ConsensusThreadStatus) FromConsensusThreadStatus0(v ConsensusThreadStatus0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsensusThreadStatus0 performs a merge with any union data inside the ConsensusThreadStatus, using the provided ConsensusThreadStatus0
func (t *ConsensusThreadStatus) MergeConsensusThreadStatus0(v ConsensusThreadStatus0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsConsensusThreadStatus1 returns the union data inside the ConsensusThreadStatus as a ConsensusThreadStatus1
func (t ConsensusThreadStatus) AsConsensusThreadStatus1() (ConsensusThreadStatus1, error) {
	var body ConsensusThreadStatus1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsensusThreadStatus1 overwrites any union data inside the ConsensusThreadStatus as the provided ConsensusThreadStatus1
func (t *ConsensusThreadStatus) FromConsensusThreadStatus1(v ConsensusThreadStatus1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsensusThreadStatus1 performs a merge with any union data inside the ConsensusThreadStatus, using the provided ConsensusThreadStatus1
func (t *ConsensusThreadStatus) MergeConsensusThreadStatus1(v ConsensusThreadStatus1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsConsensusThreadStatus2 returns the union data inside the ConsensusThreadStatus as a ConsensusThreadStatus2
func (t ConsensusThreadStatus) AsConsensusThreadStatus2() (ConsensusThreadStatus2, error) {
	var body ConsensusThreadStatus2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsensusThreadStatus2 overwrites any union data inside the ConsensusThreadStatus as the provided ConsensusThreadStatus2
func (t *ConsensusThreadStatus) FromConsensusThreadStatus2(v ConsensusThreadStatus2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsensusThreadStatus2 performs a merge with any union data inside the ConsensusThreadStatus, using the provided ConsensusThreadStatus2
func (t *ConsensusThreadStatus) MergeConsensusThreadStatus2(v ConsensusThreadStatus2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ConsensusThreadStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConsensusThreadStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFilter returns the union data inside the CountRequest_Filter as a Filter
func (t CountRequest_Filter) AsFilter() (Filter, error) {
	var body Filter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFilter overwrites any union data inside the CountRequest_Filter as the provided Filter
func (t *CountRequest_Filter) FromFilter(v Filter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFilter performs a merge with any union data inside the CountRequest_Filter, using the provided Filter
func (t *CountRequest_Filter) MergeFilter(v Filter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCountRequestFilter1 returns the union data inside the CountRequest_Filter as a CountRequestFilter1
func (t CountRequest_Filter) AsCountRequestFilter1() (CountRequestFilter1, error) {
	var body CountRequestFilter1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCountRequestFilter1 overwrites any union data inside the CountRequest_Filter as the provided CountRequestFilter1
func (t *CountRequest_Filter) FromCountRequestFilter1(v CountRequestFilter1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCountRequestFilter1 performs a merge with any union data inside the CountRequest_Filter, using the provided CountRequestFilter1
func (t *CountRequest_Filter) MergeCountRequestFilter1(v CountRequestFilter1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CountRequest_Filter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CountRequest_Filter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHnswConfigDiff returns the union data inside the CreateCollection_HnswConfig as a HnswConfigDiff
func (t CreateCollection_HnswConfig) AsHnswConfigDiff() (HnswConfigDiff, error) {
	var body HnswConfigDiff
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHnswConfigDiff overwrites any union data inside the CreateCollection_HnswConfig as the provided HnswConfigDiff
func (t *CreateCollection_HnswConfig) FromHnswConfigDiff(v HnswConfigDiff) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHnswConfigDiff performs a merge with any union data inside the CreateCollection_HnswConfig, using the provided HnswConfigDiff
func (t *CreateCollection_HnswConfig) MergeHnswConfigDiff(v HnswConfigDiff) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCreateCollectionHnswConfig1 returns the union data inside the CreateCollection_HnswConfig as a CreateCollectionHnswConfig1
func (t CreateCollection_HnswConfig) AsCreateCollectionHnswConfig1() (CreateCollectionHnswConfig1, error) {
	var body CreateCollectionHnswConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCollectionHnswConfig1 overwrites any union data inside the CreateCollection_HnswConfig as the provided CreateCollectionHnswConfig1
func (t *CreateCollection_HnswConfig) FromCreateCollectionHnswConfig1(v CreateCollectionHnswConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCollectionHnswConfig1 performs a merge with any union data inside the CreateCollection_HnswConfig, using the provided CreateCollectionHnswConfig1
func (t *CreateCollection_HnswConfig) MergeCreateCollectionHnswConfig1(v CreateCollectionHnswConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CreateCollection_HnswConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCollection_HnswConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInitFrom returns the union data inside the CreateCollection_InitFrom as a InitFrom
func (t CreateCollection_InitFrom) AsInitFrom() (InitFrom, error) {
	var body InitFrom
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInitFrom overwrites any union data inside the CreateCollection_InitFrom as the provided InitFrom
func (t *CreateCollection_InitFrom) FromInitFrom(v InitFrom) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInitFrom performs a merge with any union data inside the CreateCollection_InitFrom, using the provided InitFrom
func (t *CreateCollection_InitFrom) MergeInitFrom(v InitFrom) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCreateCollectionInitFrom1 returns the union data inside the CreateCollection_InitFrom as a CreateCollectionInitFrom1
func (t CreateCollection_InitFrom) AsCreateCollectionInitFrom1() (CreateCollectionInitFrom1, error) {
	var body CreateCollectionInitFrom1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCollectionInitFrom1 overwrites any union data inside the CreateCollection_InitFrom as the provided CreateCollectionInitFrom1
func (t *CreateCollection_InitFrom) FromCreateCollectionInitFrom1(v CreateCollectionInitFrom1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCollectionInitFrom1 performs a merge with any union data inside the CreateCollection_InitFrom, using the provided CreateCollectionInitFrom1
func (t *CreateCollection_InitFrom) MergeCreateCollectionInitFrom1(v CreateCollectionInitFrom1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CreateCollection_InitFrom) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCollection_InitFrom) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOptimizersConfigDiff returns the union data inside the CreateCollection_OptimizersConfig as a OptimizersConfigDiff
func (t CreateCollection_OptimizersConfig) AsOptimizersConfigDiff() (OptimizersConfigDiff, error) {
	var body OptimizersConfigDiff
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOptimizersConfigDiff overwrites any union data inside the CreateCollection_OptimizersConfig as the provided OptimizersConfigDiff
func (t *CreateCollection_OptimizersConfig) FromOptimizersConfigDiff(v OptimizersConfigDiff) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOptimizersConfigDiff performs a merge with any union data inside the CreateCollection_OptimizersConfig, using the provided OptimizersConfigDiff
func (t *CreateCollection_OptimizersConfig) MergeOptimizersConfigDiff(v OptimizersConfigDiff) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCreateCollectionOptimizersConfig1 returns the union data inside the CreateCollection_OptimizersConfig as a CreateCollectionOptimizersConfig1
func (t CreateCollection_OptimizersConfig) AsCreateCollectionOptimizersConfig1() (CreateCollectionOptimizersConfig1, error) {
	var body CreateCollectionOptimizersConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCollectionOptimizersConfig1 overwrites any union data inside the CreateCollection_OptimizersConfig as the provided CreateCollectionOptimizersConfig1
func (t *CreateCollection_OptimizersConfig) FromCreateCollectionOptimizersConfig1(v CreateCollectionOptimizersConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCollectionOptimizersConfig1 performs a merge with any union data inside the CreateCollection_OptimizersConfig, using the provided CreateCollectionOptimizersConfig1
func (t *CreateCollection_OptimizersConfig) MergeCreateCollectionOptimizersConfig1(v CreateCollectionOptimizersConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CreateCollection_OptimizersConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCollection_OptimizersConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantizationConfig returns the union data inside the CreateCollection_QuantizationConfig as a QuantizationConfig
func (t CreateCollection_QuantizationConfig) AsQuantizationConfig() (QuantizationConfig, error) {
	var body QuantizationConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantizationConfig overwrites any union data inside the CreateCollection_QuantizationConfig as the provided QuantizationConfig
func (t *CreateCollection_QuantizationConfig) FromQuantizationConfig(v QuantizationConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantizationConfig performs a merge with any union data inside the CreateCollection_QuantizationConfig, using the provided QuantizationConfig
func (t *CreateCollection_QuantizationConfig) MergeQuantizationConfig(v QuantizationConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCreateCollectionQuantizationConfig1 returns the union data inside the CreateCollection_QuantizationConfig as a CreateCollectionQuantizationConfig1
func (t CreateCollection_QuantizationConfig) AsCreateCollectionQuantizationConfig1() (CreateCollectionQuantizationConfig1, error) {
	var body CreateCollectionQuantizationConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCollectionQuantizationConfig1 overwrites any union data inside the CreateCollection_QuantizationConfig as the provided CreateCollectionQuantizationConfig1
func (t *CreateCollection_QuantizationConfig) FromCreateCollectionQuantizationConfig1(v CreateCollectionQuantizationConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCollectionQuantizationConfig1 performs a merge with any union data inside the CreateCollection_QuantizationConfig, using the provided CreateCollectionQuantizationConfig1
func (t *CreateCollection_QuantizationConfig) MergeCreateCollectionQuantizationConfig1(v CreateCollectionQuantizationConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CreateCollection_QuantizationConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCollection_QuantizationConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWalConfigDiff returns the union data inside the CreateCollection_WalConfig as a WalConfigDiff
func (t CreateCollection_WalConfig) AsWalConfigDiff() (WalConfigDiff, error) {
	var body WalConfigDiff
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWalConfigDiff overwrites any union data inside the CreateCollection_WalConfig as the provided WalConfigDiff
func (t *CreateCollection_WalConfig) FromWalConfigDiff(v WalConfigDiff) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWalConfigDiff performs a merge with any union data inside the CreateCollection_WalConfig, using the provided WalConfigDiff
func (t *CreateCollection_WalConfig) MergeWalConfigDiff(v WalConfigDiff) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCreateCollectionWalConfig1 returns the union data inside the CreateCollection_WalConfig as a CreateCollectionWalConfig1
func (t CreateCollection_WalConfig) AsCreateCollectionWalConfig1() (CreateCollectionWalConfig1, error) {
	var body CreateCollectionWalConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCollectionWalConfig1 overwrites any union data inside the CreateCollection_WalConfig as the provided CreateCollectionWalConfig1
func (t *CreateCollection_WalConfig) FromCreateCollectionWalConfig1(v CreateCollectionWalConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCollectionWalConfig1 performs a merge with any union data inside the CreateCollection_WalConfig, using the provided CreateCollectionWalConfig1
func (t *CreateCollection_WalConfig) MergeCreateCollectionWalConfig1(v CreateCollectionWalConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CreateCollection_WalConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCollection_WalConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPayloadFieldSchema returns the union data inside the CreateFieldIndex_FieldSchema as a PayloadFieldSchema
func (t CreateFieldIndex_FieldSchema) AsPayloadFieldSchema() (PayloadFieldSchema, error) {
	var body PayloadFieldSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayloadFieldSchema overwrites any union data inside the CreateFieldIndex_FieldSchema as the provided PayloadFieldSchema
func (t *CreateFieldIndex_FieldSchema) FromPayloadFieldSchema(v PayloadFieldSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayloadFieldSchema performs a merge with any union data inside the CreateFieldIndex_FieldSchema, using the provided PayloadFieldSchema
func (t *CreateFieldIndex_FieldSchema) MergePayloadFieldSchema(v PayloadFieldSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCreateFieldIndexFieldSchema1 returns the union data inside the CreateFieldIndex_FieldSchema as a CreateFieldIndexFieldSchema1
func (t CreateFieldIndex_FieldSchema) AsCreateFieldIndexFieldSchema1() (CreateFieldIndexFieldSchema1, error) {
	var body CreateFieldIndexFieldSchema1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateFieldIndexFieldSchema1 overwrites any union data inside the CreateFieldIndex_FieldSchema as the provided CreateFieldIndexFieldSchema1
func (t *CreateFieldIndex_FieldSchema) FromCreateFieldIndexFieldSchema1(v CreateFieldIndexFieldSchema1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateFieldIndexFieldSchema1 performs a merge with any union data inside the CreateFieldIndex_FieldSchema, using the provided CreateFieldIndexFieldSchema1
func (t *CreateFieldIndex_FieldSchema) MergeCreateFieldIndexFieldSchema1(v CreateFieldIndexFieldSchema1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CreateFieldIndex_FieldSchema) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateFieldIndex_FieldSchema) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFilter returns the union data inside the DeletePayload_Filter as a Filter
func (t DeletePayload_Filter) AsFilter() (Filter, error) {
	var body Filter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFilter overwrites any union data inside the DeletePayload_Filter as the provided Filter
func (t *DeletePayload_Filter) FromFilter(v Filter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFilter performs a merge with any union data inside the DeletePayload_Filter, using the provided Filter
func (t *DeletePayload_Filter) MergeFilter(v Filter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsDeletePayloadFilter1 returns the union data inside the DeletePayload_Filter as a DeletePayloadFilter1
func (t DeletePayload_Filter) AsDeletePayloadFilter1() (DeletePayloadFilter1, error) {
	var body DeletePayloadFilter1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeletePayloadFilter1 overwrites any union data inside the DeletePayload_Filter as the provided DeletePayloadFilter1
func (t *DeletePayload_Filter) FromDeletePayloadFilter1(v DeletePayloadFilter1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeletePayloadFilter1 performs a merge with any union data inside the DeletePayload_Filter, using the provided DeletePayloadFilter1
func (t *DeletePayload_Filter) MergeDeletePayloadFilter1(v DeletePayloadFilter1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t DeletePayload_Filter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DeletePayload_Filter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsExtendedPointId0 returns the union data inside the ExtendedPointId as a ExtendedPointId0
func (t ExtendedPointId) AsExtendedPointId0() (ExtendedPointId0, error) {
	var body ExtendedPointId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExtendedPointId0 overwrites any union data inside the ExtendedPointId as the provided ExtendedPointId0
func (t *ExtendedPointId) FromExtendedPointId0(v ExtendedPointId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExtendedPointId0 performs a merge with any union data inside the ExtendedPointId, using the provided ExtendedPointId0
func (t *ExtendedPointId) MergeExtendedPointId0(v ExtendedPointId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsExtendedPointId1 returns the union data inside the ExtendedPointId as a ExtendedPointId1
func (t ExtendedPointId) AsExtendedPointId1() (ExtendedPointId1, error) {
	var body ExtendedPointId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExtendedPointId1 overwrites any union data inside the ExtendedPointId as the provided ExtendedPointId1
func (t *ExtendedPointId) FromExtendedPointId1(v ExtendedPointId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExtendedPointId1 performs a merge with any union data inside the ExtendedPointId, using the provided ExtendedPointId1
func (t *ExtendedPointId) MergeExtendedPointId1(v ExtendedPointId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ExtendedPointId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExtendedPointId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGeoBoundingBox returns the union data inside the FieldCondition_GeoBoundingBox as a GeoBoundingBox
func (t FieldCondition_GeoBoundingBox) AsGeoBoundingBox() (GeoBoundingBox, error) {
	var body GeoBoundingBox
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoBoundingBox overwrites any union data inside the FieldCondition_GeoBoundingBox as the provided GeoBoundingBox
func (t *FieldCondition_GeoBoundingBox) FromGeoBoundingBox(v GeoBoundingBox) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoBoundingBox performs a merge with any union data inside the FieldCondition_GeoBoundingBox, using the provided GeoBoundingBox
func (t *FieldCondition_GeoBoundingBox) MergeGeoBoundingBox(v GeoBoundingBox) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsFieldConditionGeoBoundingBox1 returns the union data inside the FieldCondition_GeoBoundingBox as a FieldConditionGeoBoundingBox1
func (t FieldCondition_GeoBoundingBox) AsFieldConditionGeoBoundingBox1() (FieldConditionGeoBoundingBox1, error) {
	var body FieldConditionGeoBoundingBox1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldConditionGeoBoundingBox1 overwrites any union data inside the FieldCondition_GeoBoundingBox as the provided FieldConditionGeoBoundingBox1
func (t *FieldCondition_GeoBoundingBox) FromFieldConditionGeoBoundingBox1(v FieldConditionGeoBoundingBox1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldConditionGeoBoundingBox1 performs a merge with any union data inside the FieldCondition_GeoBoundingBox, using the provided FieldConditionGeoBoundingBox1
func (t *FieldCondition_GeoBoundingBox) MergeFieldConditionGeoBoundingBox1(v FieldConditionGeoBoundingBox1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t FieldCondition_GeoBoundingBox) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FieldCondition_GeoBoundingBox) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGeoRadius returns the union data inside the FieldCondition_GeoRadius as a GeoRadius
func (t FieldCondition_GeoRadius) AsGeoRadius() (GeoRadius, error) {
	var body GeoRadius
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoRadius overwrites any union data inside the FieldCondition_GeoRadius as the provided GeoRadius
func (t *FieldCondition_GeoRadius) FromGeoRadius(v GeoRadius) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoRadius performs a merge with any union data inside the FieldCondition_GeoRadius, using the provided GeoRadius
func (t *FieldCondition_GeoRadius) MergeGeoRadius(v GeoRadius) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsFieldConditionGeoRadius1 returns the union data inside the FieldCondition_GeoRadius as a FieldConditionGeoRadius1
func (t FieldCondition_GeoRadius) AsFieldConditionGeoRadius1() (FieldConditionGeoRadius1, error) {
	var body FieldConditionGeoRadius1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldConditionGeoRadius1 overwrites any union data inside the FieldCondition_GeoRadius as the provided FieldConditionGeoRadius1
func (t *FieldCondition_GeoRadius) FromFieldConditionGeoRadius1(v FieldConditionGeoRadius1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldConditionGeoRadius1 performs a merge with any union data inside the FieldCondition_GeoRadius, using the provided FieldConditionGeoRadius1
func (t *FieldCondition_GeoRadius) MergeFieldConditionGeoRadius1(v FieldConditionGeoRadius1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t FieldCondition_GeoRadius) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FieldCondition_GeoRadius) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMatch returns the union data inside the FieldCondition_Match as a Match
func (t FieldCondition_Match) AsMatch() (Match, error) {
	var body Match
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatch overwrites any union data inside the FieldCondition_Match as the provided Match
func (t *FieldCondition_Match) FromMatch(v Match) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatch performs a merge with any union data inside the FieldCondition_Match, using the provided Match
func (t *FieldCondition_Match) MergeMatch(v Match) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsFieldConditionMatch1 returns the union data inside the FieldCondition_Match as a FieldConditionMatch1
func (t FieldCondition_Match) AsFieldConditionMatch1() (FieldConditionMatch1, error) {
	var body FieldConditionMatch1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldConditionMatch1 overwrites any union data inside the FieldCondition_Match as the provided FieldConditionMatch1
func (t *FieldCondition_Match) FromFieldConditionMatch1(v FieldConditionMatch1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldConditionMatch1 performs a merge with any union data inside the FieldCondition_Match, using the provided FieldConditionMatch1
func (t *FieldCondition_Match) MergeFieldConditionMatch1(v FieldConditionMatch1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t FieldCondition_Match) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FieldCondition_Match) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRange returns the union data inside the FieldCondition_Range as a Range
func (t FieldCondition_Range) AsRange() (Range, error) {
	var body Range
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRange overwrites any union data inside the FieldCondition_Range as the provided Range
func (t *FieldCondition_Range) FromRange(v Range) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRange performs a merge with any union data inside the FieldCondition_Range, using the provided Range
func (t *FieldCondition_Range) MergeRange(v Range) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsFieldConditionRange1 returns the union data inside the FieldCondition_Range as a FieldConditionRange1
func (t FieldCondition_Range) AsFieldConditionRange1() (FieldConditionRange1, error) {
	var body FieldConditionRange1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldConditionRange1 overwrites any union data inside the FieldCondition_Range as the provided FieldConditionRange1
func (t *FieldCondition_Range) FromFieldConditionRange1(v FieldConditionRange1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldConditionRange1 performs a merge with any union data inside the FieldCondition_Range, using the provided FieldConditionRange1
func (t *FieldCondition_Range) MergeFieldConditionRange1(v FieldConditionRange1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t FieldCondition_Range) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FieldCondition_Range) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsValuesCount returns the union data inside the FieldCondition_ValuesCount as a ValuesCount
func (t FieldCondition_ValuesCount) AsValuesCount() (ValuesCount, error) {
	var body ValuesCount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValuesCount overwrites any union data inside the FieldCondition_ValuesCount as the provided ValuesCount
func (t *FieldCondition_ValuesCount) FromValuesCount(v ValuesCount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValuesCount performs a merge with any union data inside the FieldCondition_ValuesCount, using the provided ValuesCount
func (t *FieldCondition_ValuesCount) MergeValuesCount(v ValuesCount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsFieldConditionValuesCount1 returns the union data inside the FieldCondition_ValuesCount as a FieldConditionValuesCount1
func (t FieldCondition_ValuesCount) AsFieldConditionValuesCount1() (FieldConditionValuesCount1, error) {
	var body FieldConditionValuesCount1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldConditionValuesCount1 overwrites any union data inside the FieldCondition_ValuesCount as the provided FieldConditionValuesCount1
func (t *FieldCondition_ValuesCount) FromFieldConditionValuesCount1(v FieldConditionValuesCount1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldConditionValuesCount1 performs a merge with any union data inside the FieldCondition_ValuesCount, using the provided FieldConditionValuesCount1
func (t *FieldCondition_ValuesCount) MergeFieldConditionValuesCount1(v FieldConditionValuesCount1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t FieldCondition_ValuesCount) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FieldCondition_ValuesCount) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIndexes0 returns the union data inside the Indexes as a Indexes0
func (t Indexes) AsIndexes0() (Indexes0, error) {
	var body Indexes0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexes0 overwrites any union data inside the Indexes as the provided Indexes0
func (t *Indexes) FromIndexes0(v Indexes0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexes0 performs a merge with any union data inside the Indexes, using the provided Indexes0
func (t *Indexes) MergeIndexes0(v Indexes0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsIndexes1 returns the union data inside the Indexes as a Indexes1
func (t Indexes) AsIndexes1() (Indexes1, error) {
	var body Indexes1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexes1 overwrites any union data inside the Indexes as the provided Indexes1
func (t *Indexes) FromIndexes1(v Indexes1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexes1 performs a merge with any union data inside the Indexes, using the provided Indexes1
func (t *Indexes) MergeIndexes1(v Indexes1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Indexes) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Indexes) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMatchValue returns the union data inside the Match as a MatchValue
func (t Match) AsMatchValue() (MatchValue, error) {
	var body MatchValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatchValue overwrites any union data inside the Match as the provided MatchValue
func (t *Match) FromMatchValue(v MatchValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatchValue performs a merge with any union data inside the Match, using the provided MatchValue
func (t *Match) MergeMatchValue(v MatchValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMatchText returns the union data inside the Match as a MatchText
func (t Match) AsMatchText() (MatchText, error) {
	var body MatchText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatchText overwrites any union data inside the Match as the provided MatchText
func (t *Match) FromMatchText(v MatchText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatchText performs a merge with any union data inside the Match, using the provided MatchText
func (t *Match) MergeMatchText(v MatchText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMatchAny returns the union data inside the Match as a MatchAny
func (t Match) AsMatchAny() (MatchAny, error) {
	var body MatchAny
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatchAny overwrites any union data inside the Match as the provided MatchAny
func (t *Match) FromMatchAny(v MatchAny) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatchAny performs a merge with any union data inside the Match, using the provided MatchAny
func (t *Match) MergeMatchAny(v MatchAny) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Match) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Match) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNamedVectorStruct0 returns the union data inside the NamedVectorStruct as a NamedVectorStruct0
func (t NamedVectorStruct) AsNamedVectorStruct0() (NamedVectorStruct0, error) {
	var body NamedVectorStruct0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNamedVectorStruct0 overwrites any union data inside the NamedVectorStruct as the provided NamedVectorStruct0
func (t *NamedVectorStruct) FromNamedVectorStruct0(v NamedVectorStruct0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNamedVectorStruct0 performs a merge with any union data inside the NamedVectorStruct, using the provided NamedVectorStruct0
func (t *NamedVectorStruct) MergeNamedVectorStruct0(v NamedVectorStruct0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsNamedVector returns the union data inside the NamedVectorStruct as a NamedVector
func (t NamedVectorStruct) AsNamedVector() (NamedVector, error) {
	var body NamedVector
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNamedVector overwrites any union data inside the NamedVectorStruct as the provided NamedVector
func (t *NamedVectorStruct) FromNamedVector(v NamedVector) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNamedVector performs a merge with any union data inside the NamedVectorStruct, using the provided NamedVector
func (t *NamedVectorStruct) MergeNamedVector(v NamedVector) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t NamedVectorStruct) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NamedVectorStruct) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOptimizersStatus0 returns the union data inside the OptimizersStatus as a OptimizersStatus0
func (t OptimizersStatus) AsOptimizersStatus0() (OptimizersStatus0, error) {
	var body OptimizersStatus0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOptimizersStatus0 overwrites any union data inside the OptimizersStatus as the provided OptimizersStatus0
func (t *OptimizersStatus) FromOptimizersStatus0(v OptimizersStatus0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOptimizersStatus0 performs a merge with any union data inside the OptimizersStatus, using the provided OptimizersStatus0
func (t *OptimizersStatus) MergeOptimizersStatus0(v OptimizersStatus0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsOptimizersStatus1 returns the union data inside the OptimizersStatus as a OptimizersStatus1
func (t OptimizersStatus) AsOptimizersStatus1() (OptimizersStatus1, error) {
	var body OptimizersStatus1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOptimizersStatus1 overwrites any union data inside the OptimizersStatus as the provided OptimizersStatus1
func (t *OptimizersStatus) FromOptimizersStatus1(v OptimizersStatus1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOptimizersStatus1 performs a merge with any union data inside the OptimizersStatus, using the provided OptimizersStatus1
func (t *OptimizersStatus) MergeOptimizersStatus1(v OptimizersStatus1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t OptimizersStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OptimizersStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPayloadSchemaType returns the union data inside the PayloadFieldSchema as a PayloadSchemaType
func (t PayloadFieldSchema) AsPayloadSchemaType() (PayloadSchemaType, error) {
	var body PayloadSchemaType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayloadSchemaType overwrites any union data inside the PayloadFieldSchema as the provided PayloadSchemaType
func (t *PayloadFieldSchema) FromPayloadSchemaType(v PayloadSchemaType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayloadSchemaType performs a merge with any union data inside the PayloadFieldSchema, using the provided PayloadSchemaType
func (t *PayloadFieldSchema) MergePayloadSchemaType(v PayloadSchemaType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPayloadSchemaParams returns the union data inside the PayloadFieldSchema as a PayloadSchemaParams
func (t PayloadFieldSchema) AsPayloadSchemaParams() (PayloadSchemaParams, error) {
	var body PayloadSchemaParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayloadSchemaParams overwrites any union data inside the PayloadFieldSchema as the provided PayloadSchemaParams
func (t *PayloadFieldSchema) FromPayloadSchemaParams(v PayloadSchemaParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayloadSchemaParams performs a merge with any union data inside the PayloadFieldSchema, using the provided PayloadSchemaParams
func (t *PayloadFieldSchema) MergePayloadSchemaParams(v PayloadSchemaParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PayloadFieldSchema) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PayloadFieldSchema) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPayloadSchemaParams returns the union data inside the PayloadIndexInfo_Params as a PayloadSchemaParams
func (t PayloadIndexInfo_Params) AsPayloadSchemaParams() (PayloadSchemaParams, error) {
	var body PayloadSchemaParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayloadSchemaParams overwrites any union data inside the PayloadIndexInfo_Params as the provided PayloadSchemaParams
func (t *PayloadIndexInfo_Params) FromPayloadSchemaParams(v PayloadSchemaParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayloadSchemaParams performs a merge with any union data inside the PayloadIndexInfo_Params, using the provided PayloadSchemaParams
func (t *PayloadIndexInfo_Params) MergePayloadSchemaParams(v PayloadSchemaParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPayloadIndexInfoParams1 returns the union data inside the PayloadIndexInfo_Params as a PayloadIndexInfoParams1
func (t PayloadIndexInfo_Params) AsPayloadIndexInfoParams1() (PayloadIndexInfoParams1, error) {
	var body PayloadIndexInfoParams1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayloadIndexInfoParams1 overwrites any union data inside the PayloadIndexInfo_Params as the provided PayloadIndexInfoParams1
func (t *PayloadIndexInfo_Params) FromPayloadIndexInfoParams1(v PayloadIndexInfoParams1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayloadIndexInfoParams1 performs a merge with any union data inside the PayloadIndexInfo_Params, using the provided PayloadIndexInfoParams1
func (t *PayloadIndexInfo_Params) MergePayloadIndexInfoParams1(v PayloadIndexInfoParams1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PayloadIndexInfo_Params) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PayloadIndexInfo_Params) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTextIndexParams returns the union data inside the PayloadSchemaParams as a TextIndexParams
func (t PayloadSchemaParams) AsTextIndexParams() (TextIndexParams, error) {
	var body TextIndexParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextIndexParams overwrites any union data inside the PayloadSchemaParams as the provided TextIndexParams
func (t *PayloadSchemaParams) FromTextIndexParams(v TextIndexParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextIndexParams performs a merge with any union data inside the PayloadSchemaParams, using the provided TextIndexParams
func (t *PayloadSchemaParams) MergeTextIndexParams(v TextIndexParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PayloadSchemaParams) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PayloadSchemaParams) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPayloadSelectorInclude returns the union data inside the PayloadSelector as a PayloadSelectorInclude
func (t PayloadSelector) AsPayloadSelectorInclude() (PayloadSelectorInclude, error) {
	var body PayloadSelectorInclude
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayloadSelectorInclude overwrites any union data inside the PayloadSelector as the provided PayloadSelectorInclude
func (t *PayloadSelector) FromPayloadSelectorInclude(v PayloadSelectorInclude) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayloadSelectorInclude performs a merge with any union data inside the PayloadSelector, using the provided PayloadSelectorInclude
func (t *PayloadSelector) MergePayloadSelectorInclude(v PayloadSelectorInclude) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPayloadSelectorExclude returns the union data inside the PayloadSelector as a PayloadSelectorExclude
func (t PayloadSelector) AsPayloadSelectorExclude() (PayloadSelectorExclude, error) {
	var body PayloadSelectorExclude
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayloadSelectorExclude overwrites any union data inside the PayloadSelector as the provided PayloadSelectorExclude
func (t *PayloadSelector) FromPayloadSelectorExclude(v PayloadSelectorExclude) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayloadSelectorExclude performs a merge with any union data inside the PayloadSelector, using the provided PayloadSelectorExclude
func (t *PayloadSelector) MergePayloadSelectorExclude(v PayloadSelectorExclude) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PayloadSelector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PayloadSelector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPayloadStorageType0 returns the union data inside the PayloadStorageType as a PayloadStorageType0
func (t PayloadStorageType) AsPayloadStorageType0() (PayloadStorageType0, error) {
	var body PayloadStorageType0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayloadStorageType0 overwrites any union data inside the PayloadStorageType as the provided PayloadStorageType0
func (t *PayloadStorageType) FromPayloadStorageType0(v PayloadStorageType0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayloadStorageType0 performs a merge with any union data inside the PayloadStorageType, using the provided PayloadStorageType0
func (t *PayloadStorageType) MergePayloadStorageType0(v PayloadStorageType0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPayloadStorageType1 returns the union data inside the PayloadStorageType as a PayloadStorageType1
func (t PayloadStorageType) AsPayloadStorageType1() (PayloadStorageType1, error) {
	var body PayloadStorageType1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayloadStorageType1 overwrites any union data inside the PayloadStorageType as the provided PayloadStorageType1
func (t *PayloadStorageType) FromPayloadStorageType1(v PayloadStorageType1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayloadStorageType1 performs a merge with any union data inside the PayloadStorageType, using the provided PayloadStorageType1
func (t *PayloadStorageType) MergePayloadStorageType1(v PayloadStorageType1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PayloadStorageType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PayloadStorageType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPointsBatch returns the union data inside the PointInsertOperations as a PointsBatch
func (t PointInsertOperations) AsPointsBatch() (PointsBatch, error) {
	var body PointsBatch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPointsBatch overwrites any union data inside the PointInsertOperations as the provided PointsBatch
func (t *PointInsertOperations) FromPointsBatch(v PointsBatch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePointsBatch performs a merge with any union data inside the PointInsertOperations, using the provided PointsBatch
func (t *PointInsertOperations) MergePointsBatch(v PointsBatch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPointsList returns the union data inside the PointInsertOperations as a PointsList
func (t PointInsertOperations) AsPointsList() (PointsList, error) {
	var body PointsList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPointsList overwrites any union data inside the PointInsertOperations as the provided PointsList
func (t *PointInsertOperations) FromPointsList(v PointsList) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePointsList performs a merge with any union data inside the PointInsertOperations, using the provided PointsList
func (t *PointInsertOperations) MergePointsList(v PointsList) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PointInsertOperations) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PointInsertOperations) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWithPayloadInterface returns the union data inside the PointRequest_WithPayload as a WithPayloadInterface
func (t PointRequest_WithPayload) AsWithPayloadInterface() (WithPayloadInterface, error) {
	var body WithPayloadInterface
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWithPayloadInterface overwrites any union data inside the PointRequest_WithPayload as the provided WithPayloadInterface
func (t *PointRequest_WithPayload) FromWithPayloadInterface(v WithPayloadInterface) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWithPayloadInterface performs a merge with any union data inside the PointRequest_WithPayload, using the provided WithPayloadInterface
func (t *PointRequest_WithPayload) MergeWithPayloadInterface(v WithPayloadInterface) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPointRequestWithPayload1 returns the union data inside the PointRequest_WithPayload as a PointRequestWithPayload1
func (t PointRequest_WithPayload) AsPointRequestWithPayload1() (PointRequestWithPayload1, error) {
	var body PointRequestWithPayload1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPointRequestWithPayload1 overwrites any union data inside the PointRequest_WithPayload as the provided PointRequestWithPayload1
func (t *PointRequest_WithPayload) FromPointRequestWithPayload1(v PointRequestWithPayload1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePointRequestWithPayload1 performs a merge with any union data inside the PointRequest_WithPayload, using the provided PointRequestWithPayload1
func (t *PointRequest_WithPayload) MergePointRequestWithPayload1(v PointRequestWithPayload1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PointRequest_WithPayload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PointRequest_WithPayload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPayload returns the union data inside the PointStruct_Payload as a Payload
func (t PointStruct_Payload) AsPayload() (Payload, error) {
	var body Payload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayload overwrites any union data inside the PointStruct_Payload as the provided Payload
func (t *PointStruct_Payload) FromPayload(v Payload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayload performs a merge with any union data inside the PointStruct_Payload, using the provided Payload
func (t *PointStruct_Payload) MergePayload(v Payload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPointStructPayload1 returns the union data inside the PointStruct_Payload as a PointStructPayload1
func (t PointStruct_Payload) AsPointStructPayload1() (PointStructPayload1, error) {
	var body PointStructPayload1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPointStructPayload1 overwrites any union data inside the PointStruct_Payload as the provided PointStructPayload1
func (t *PointStruct_Payload) FromPointStructPayload1(v PointStructPayload1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePointStructPayload1 performs a merge with any union data inside the PointStruct_Payload, using the provided PointStructPayload1
func (t *PointStruct_Payload) MergePointStructPayload1(v PointStructPayload1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PointStruct_Payload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PointStruct_Payload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPointIdsList returns the union data inside the PointsSelector as a PointIdsList
func (t PointsSelector) AsPointIdsList() (PointIdsList, error) {
	var body PointIdsList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPointIdsList overwrites any union data inside the PointsSelector as the provided PointIdsList
func (t *PointsSelector) FromPointIdsList(v PointIdsList) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePointIdsList performs a merge with any union data inside the PointsSelector, using the provided PointIdsList
func (t *PointsSelector) MergePointIdsList(v PointIdsList) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsFilterSelector returns the union data inside the PointsSelector as a FilterSelector
func (t PointsSelector) AsFilterSelector() (FilterSelector, error) {
	var body FilterSelector
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFilterSelector overwrites any union data inside the PointsSelector as the provided FilterSelector
func (t *PointsSelector) FromFilterSelector(v FilterSelector) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFilterSelector performs a merge with any union data inside the PointsSelector, using the provided FilterSelector
func (t *PointsSelector) MergeFilterSelector(v FilterSelector) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PointsSelector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PointsSelector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScalarQuantization returns the union data inside the QuantizationConfig as a ScalarQuantization
func (t QuantizationConfig) AsScalarQuantization() (ScalarQuantization, error) {
	var body ScalarQuantization
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScalarQuantization overwrites any union data inside the QuantizationConfig as the provided ScalarQuantization
func (t *QuantizationConfig) FromScalarQuantization(v ScalarQuantization) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScalarQuantization performs a merge with any union data inside the QuantizationConfig, using the provided ScalarQuantization
func (t *QuantizationConfig) MergeScalarQuantization(v ScalarQuantization) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t QuantizationConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *QuantizationConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStateRole returns the union data inside the RaftInfo_Role as a StateRole
func (t RaftInfo_Role) AsStateRole() (StateRole, error) {
	var body StateRole
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStateRole overwrites any union data inside the RaftInfo_Role as the provided StateRole
func (t *RaftInfo_Role) FromStateRole(v StateRole) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStateRole performs a merge with any union data inside the RaftInfo_Role, using the provided StateRole
func (t *RaftInfo_Role) MergeStateRole(v StateRole) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRaftInfoRole1 returns the union data inside the RaftInfo_Role as a RaftInfoRole1
func (t RaftInfo_Role) AsRaftInfoRole1() (RaftInfoRole1, error) {
	var body RaftInfoRole1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRaftInfoRole1 overwrites any union data inside the RaftInfo_Role as the provided RaftInfoRole1
func (t *RaftInfo_Role) FromRaftInfoRole1(v RaftInfoRole1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRaftInfoRole1 performs a merge with any union data inside the RaftInfo_Role, using the provided RaftInfoRole1
func (t *RaftInfo_Role) MergeRaftInfoRole1(v RaftInfoRole1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t RaftInfo_Role) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RaftInfo_Role) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReadConsistency0 returns the union data inside the ReadConsistency as a ReadConsistency0
func (t ReadConsistency) AsReadConsistency0() (ReadConsistency0, error) {
	var body ReadConsistency0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReadConsistency0 overwrites any union data inside the ReadConsistency as the provided ReadConsistency0
func (t *ReadConsistency) FromReadConsistency0(v ReadConsistency0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReadConsistency0 performs a merge with any union data inside the ReadConsistency, using the provided ReadConsistency0
func (t *ReadConsistency) MergeReadConsistency0(v ReadConsistency0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsReadConsistencyType returns the union data inside the ReadConsistency as a ReadConsistencyType
func (t ReadConsistency) AsReadConsistencyType() (ReadConsistencyType, error) {
	var body ReadConsistencyType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReadConsistencyType overwrites any union data inside the ReadConsistency as the provided ReadConsistencyType
func (t *ReadConsistency) FromReadConsistencyType(v ReadConsistencyType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReadConsistencyType performs a merge with any union data inside the ReadConsistency, using the provided ReadConsistencyType
func (t *ReadConsistency) MergeReadConsistencyType(v ReadConsistencyType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ReadConsistency) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReadConsistency) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFilter returns the union data inside the RecommendRequest_Filter as a Filter
func (t RecommendRequest_Filter) AsFilter() (Filter, error) {
	var body Filter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFilter overwrites any union data inside the RecommendRequest_Filter as the provided Filter
func (t *RecommendRequest_Filter) FromFilter(v Filter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFilter performs a merge with any union data inside the RecommendRequest_Filter, using the provided Filter
func (t *RecommendRequest_Filter) MergeFilter(v Filter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRecommendRequestFilter1 returns the union data inside the RecommendRequest_Filter as a RecommendRequestFilter1
func (t RecommendRequest_Filter) AsRecommendRequestFilter1() (RecommendRequestFilter1, error) {
	var body RecommendRequestFilter1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecommendRequestFilter1 overwrites any union data inside the RecommendRequest_Filter as the provided RecommendRequestFilter1
func (t *RecommendRequest_Filter) FromRecommendRequestFilter1(v RecommendRequestFilter1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecommendRequestFilter1 performs a merge with any union data inside the RecommendRequest_Filter, using the provided RecommendRequestFilter1
func (t *RecommendRequest_Filter) MergeRecommendRequestFilter1(v RecommendRequestFilter1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t RecommendRequest_Filter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RecommendRequest_Filter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLookupLocation returns the union data inside the RecommendRequest_LookupFrom as a LookupLocation
func (t RecommendRequest_LookupFrom) AsLookupLocation() (LookupLocation, error) {
	var body LookupLocation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLookupLocation overwrites any union data inside the RecommendRequest_LookupFrom as the provided LookupLocation
func (t *RecommendRequest_LookupFrom) FromLookupLocation(v LookupLocation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLookupLocation performs a merge with any union data inside the RecommendRequest_LookupFrom, using the provided LookupLocation
func (t *RecommendRequest_LookupFrom) MergeLookupLocation(v LookupLocation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRecommendRequestLookupFrom1 returns the union data inside the RecommendRequest_LookupFrom as a RecommendRequestLookupFrom1
func (t RecommendRequest_LookupFrom) AsRecommendRequestLookupFrom1() (RecommendRequestLookupFrom1, error) {
	var body RecommendRequestLookupFrom1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecommendRequestLookupFrom1 overwrites any union data inside the RecommendRequest_LookupFrom as the provided RecommendRequestLookupFrom1
func (t *RecommendRequest_LookupFrom) FromRecommendRequestLookupFrom1(v RecommendRequestLookupFrom1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecommendRequestLookupFrom1 performs a merge with any union data inside the RecommendRequest_LookupFrom, using the provided RecommendRequestLookupFrom1
func (t *RecommendRequest_LookupFrom) MergeRecommendRequestLookupFrom1(v RecommendRequestLookupFrom1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t RecommendRequest_LookupFrom) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RecommendRequest_LookupFrom) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSearchParams returns the union data inside the RecommendRequest_Params as a SearchParams
func (t RecommendRequest_Params) AsSearchParams() (SearchParams, error) {
	var body SearchParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchParams overwrites any union data inside the RecommendRequest_Params as the provided SearchParams
func (t *RecommendRequest_Params) FromSearchParams(v SearchParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchParams performs a merge with any union data inside the RecommendRequest_Params, using the provided SearchParams
func (t *RecommendRequest_Params) MergeSearchParams(v SearchParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRecommendRequestParams1 returns the union data inside the RecommendRequest_Params as a RecommendRequestParams1
func (t RecommendRequest_Params) AsRecommendRequestParams1() (RecommendRequestParams1, error) {
	var body RecommendRequestParams1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecommendRequestParams1 overwrites any union data inside the RecommendRequest_Params as the provided RecommendRequestParams1
func (t *RecommendRequest_Params) FromRecommendRequestParams1(v RecommendRequestParams1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecommendRequestParams1 performs a merge with any union data inside the RecommendRequest_Params, using the provided RecommendRequestParams1
func (t *RecommendRequest_Params) MergeRecommendRequestParams1(v RecommendRequestParams1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t RecommendRequest_Params) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RecommendRequest_Params) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUsingVector returns the union data inside the RecommendRequest_Using as a UsingVector
func (t RecommendRequest_Using) AsUsingVector() (UsingVector, error) {
	var body UsingVector
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUsingVector overwrites any union data inside the RecommendRequest_Using as the provided UsingVector
func (t *RecommendRequest_Using) FromUsingVector(v UsingVector) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUsingVector performs a merge with any union data inside the RecommendRequest_Using, using the provided UsingVector
func (t *RecommendRequest_Using) MergeUsingVector(v UsingVector) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRecommendRequestUsing1 returns the union data inside the RecommendRequest_Using as a RecommendRequestUsing1
func (t RecommendRequest_Using) AsRecommendRequestUsing1() (RecommendRequestUsing1, error) {
	var body RecommendRequestUsing1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecommendRequestUsing1 overwrites any union data inside the RecommendRequest_Using as the provided RecommendRequestUsing1
func (t *RecommendRequest_Using) FromRecommendRequestUsing1(v RecommendRequestUsing1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecommendRequestUsing1 performs a merge with any union data inside the RecommendRequest_Using, using the provided RecommendRequestUsing1
func (t *RecommendRequest_Using) MergeRecommendRequestUsing1(v RecommendRequestUsing1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t RecommendRequest_Using) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RecommendRequest_Using) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWithPayloadInterface returns the union data inside the RecommendRequest_WithPayload as a WithPayloadInterface
func (t RecommendRequest_WithPayload) AsWithPayloadInterface() (WithPayloadInterface, error) {
	var body WithPayloadInterface
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWithPayloadInterface overwrites any union data inside the RecommendRequest_WithPayload as the provided WithPayloadInterface
func (t *RecommendRequest_WithPayload) FromWithPayloadInterface(v WithPayloadInterface) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWithPayloadInterface performs a merge with any union data inside the RecommendRequest_WithPayload, using the provided WithPayloadInterface
func (t *RecommendRequest_WithPayload) MergeWithPayloadInterface(v WithPayloadInterface) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRecommendRequestWithPayload1 returns the union data inside the RecommendRequest_WithPayload as a RecommendRequestWithPayload1
func (t RecommendRequest_WithPayload) AsRecommendRequestWithPayload1() (RecommendRequestWithPayload1, error) {
	var body RecommendRequestWithPayload1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecommendRequestWithPayload1 overwrites any union data inside the RecommendRequest_WithPayload as the provided RecommendRequestWithPayload1
func (t *RecommendRequest_WithPayload) FromRecommendRequestWithPayload1(v RecommendRequestWithPayload1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecommendRequestWithPayload1 performs a merge with any union data inside the RecommendRequest_WithPayload, using the provided RecommendRequestWithPayload1
func (t *RecommendRequest_WithPayload) MergeRecommendRequestWithPayload1(v RecommendRequestWithPayload1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t RecommendRequest_WithPayload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RecommendRequest_WithPayload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWithVector returns the union data inside the RecommendRequest_WithVector as a WithVector
func (t RecommendRequest_WithVector) AsWithVector() (WithVector, error) {
	var body WithVector
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWithVector overwrites any union data inside the RecommendRequest_WithVector as the provided WithVector
func (t *RecommendRequest_WithVector) FromWithVector(v WithVector) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWithVector performs a merge with any union data inside the RecommendRequest_WithVector, using the provided WithVector
func (t *RecommendRequest_WithVector) MergeWithVector(v WithVector) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRecommendRequestWithVector1 returns the union data inside the RecommendRequest_WithVector as a RecommendRequestWithVector1
func (t RecommendRequest_WithVector) AsRecommendRequestWithVector1() (RecommendRequestWithVector1, error) {
	var body RecommendRequestWithVector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecommendRequestWithVector1 overwrites any union data inside the RecommendRequest_WithVector as the provided RecommendRequestWithVector1
func (t *RecommendRequest_WithVector) FromRecommendRequestWithVector1(v RecommendRequestWithVector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecommendRequestWithVector1 performs a merge with any union data inside the RecommendRequest_WithVector, using the provided RecommendRequestWithVector1
func (t *RecommendRequest_WithVector) MergeRecommendRequestWithVector1(v RecommendRequestWithVector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t RecommendRequest_WithVector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RecommendRequest_WithVector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPayload returns the union data inside the Record_Payload as a Payload
func (t Record_Payload) AsPayload() (Payload, error) {
	var body Payload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayload overwrites any union data inside the Record_Payload as the provided Payload
func (t *Record_Payload) FromPayload(v Payload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayload performs a merge with any union data inside the Record_Payload, using the provided Payload
func (t *Record_Payload) MergePayload(v Payload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRecordPayload1 returns the union data inside the Record_Payload as a RecordPayload1
func (t Record_Payload) AsRecordPayload1() (RecordPayload1, error) {
	var body RecordPayload1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecordPayload1 overwrites any union data inside the Record_Payload as the provided RecordPayload1
func (t *Record_Payload) FromRecordPayload1(v RecordPayload1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecordPayload1 performs a merge with any union data inside the Record_Payload, using the provided RecordPayload1
func (t *Record_Payload) MergeRecordPayload1(v RecordPayload1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Record_Payload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Record_Payload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVectorStruct returns the union data inside the Record_Vector as a VectorStruct
func (t Record_Vector) AsVectorStruct() (VectorStruct, error) {
	var body VectorStruct
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVectorStruct overwrites any union data inside the Record_Vector as the provided VectorStruct
func (t *Record_Vector) FromVectorStruct(v VectorStruct) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVectorStruct performs a merge with any union data inside the Record_Vector, using the provided VectorStruct
func (t *Record_Vector) MergeVectorStruct(v VectorStruct) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRecordVector1 returns the union data inside the Record_Vector as a RecordVector1
func (t Record_Vector) AsRecordVector1() (RecordVector1, error) {
	var body RecordVector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecordVector1 overwrites any union data inside the Record_Vector as the provided RecordVector1
func (t *Record_Vector) FromRecordVector1(v RecordVector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecordVector1 performs a merge with any union data inside the Record_Vector, using the provided RecordVector1
func (t *Record_Vector) MergeRecordVector1(v RecordVector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Record_Vector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Record_Vector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocalShardTelemetry returns the union data inside the ReplicaSetTelemetry_Local as a LocalShardTelemetry
func (t ReplicaSetTelemetry_Local) AsLocalShardTelemetry() (LocalShardTelemetry, error) {
	var body LocalShardTelemetry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocalShardTelemetry overwrites any union data inside the ReplicaSetTelemetry_Local as the provided LocalShardTelemetry
func (t *ReplicaSetTelemetry_Local) FromLocalShardTelemetry(v LocalShardTelemetry) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocalShardTelemetry performs a merge with any union data inside the ReplicaSetTelemetry_Local, using the provided LocalShardTelemetry
func (t *ReplicaSetTelemetry_Local) MergeLocalShardTelemetry(v LocalShardTelemetry) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsReplicaSetTelemetryLocal1 returns the union data inside the ReplicaSetTelemetry_Local as a ReplicaSetTelemetryLocal1
func (t ReplicaSetTelemetry_Local) AsReplicaSetTelemetryLocal1() (ReplicaSetTelemetryLocal1, error) {
	var body ReplicaSetTelemetryLocal1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReplicaSetTelemetryLocal1 overwrites any union data inside the ReplicaSetTelemetry_Local as the provided ReplicaSetTelemetryLocal1
func (t *ReplicaSetTelemetry_Local) FromReplicaSetTelemetryLocal1(v ReplicaSetTelemetryLocal1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReplicaSetTelemetryLocal1 performs a merge with any union data inside the ReplicaSetTelemetry_Local, using the provided ReplicaSetTelemetryLocal1
func (t *ReplicaSetTelemetry_Local) MergeReplicaSetTelemetryLocal1(v ReplicaSetTelemetryLocal1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ReplicaSetTelemetry_Local) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReplicaSetTelemetry_Local) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPayload returns the union data inside the ScoredPoint_Payload as a Payload
func (t ScoredPoint_Payload) AsPayload() (Payload, error) {
	var body Payload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayload overwrites any union data inside the ScoredPoint_Payload as the provided Payload
func (t *ScoredPoint_Payload) FromPayload(v Payload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayload performs a merge with any union data inside the ScoredPoint_Payload, using the provided Payload
func (t *ScoredPoint_Payload) MergePayload(v Payload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsScoredPointPayload1 returns the union data inside the ScoredPoint_Payload as a ScoredPointPayload1
func (t ScoredPoint_Payload) AsScoredPointPayload1() (ScoredPointPayload1, error) {
	var body ScoredPointPayload1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScoredPointPayload1 overwrites any union data inside the ScoredPoint_Payload as the provided ScoredPointPayload1
func (t *ScoredPoint_Payload) FromScoredPointPayload1(v ScoredPointPayload1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScoredPointPayload1 performs a merge with any union data inside the ScoredPoint_Payload, using the provided ScoredPointPayload1
func (t *ScoredPoint_Payload) MergeScoredPointPayload1(v ScoredPointPayload1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ScoredPoint_Payload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScoredPoint_Payload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVectorStruct returns the union data inside the ScoredPoint_Vector as a VectorStruct
func (t ScoredPoint_Vector) AsVectorStruct() (VectorStruct, error) {
	var body VectorStruct
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVectorStruct overwrites any union data inside the ScoredPoint_Vector as the provided VectorStruct
func (t *ScoredPoint_Vector) FromVectorStruct(v VectorStruct) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVectorStruct performs a merge with any union data inside the ScoredPoint_Vector, using the provided VectorStruct
func (t *ScoredPoint_Vector) MergeVectorStruct(v VectorStruct) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsScoredPointVector1 returns the union data inside the ScoredPoint_Vector as a ScoredPointVector1
func (t ScoredPoint_Vector) AsScoredPointVector1() (ScoredPointVector1, error) {
	var body ScoredPointVector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScoredPointVector1 overwrites any union data inside the ScoredPoint_Vector as the provided ScoredPointVector1
func (t *ScoredPoint_Vector) FromScoredPointVector1(v ScoredPointVector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScoredPointVector1 performs a merge with any union data inside the ScoredPoint_Vector, using the provided ScoredPointVector1
func (t *ScoredPoint_Vector) MergeScoredPointVector1(v ScoredPointVector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ScoredPoint_Vector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScoredPoint_Vector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFilter returns the union data inside the ScrollRequest_Filter as a Filter
func (t ScrollRequest_Filter) AsFilter() (Filter, error) {
	var body Filter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFilter overwrites any union data inside the ScrollRequest_Filter as the provided Filter
func (t *ScrollRequest_Filter) FromFilter(v Filter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFilter performs a merge with any union data inside the ScrollRequest_Filter, using the provided Filter
func (t *ScrollRequest_Filter) MergeFilter(v Filter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsScrollRequestFilter1 returns the union data inside the ScrollRequest_Filter as a ScrollRequestFilter1
func (t ScrollRequest_Filter) AsScrollRequestFilter1() (ScrollRequestFilter1, error) {
	var body ScrollRequestFilter1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrollRequestFilter1 overwrites any union data inside the ScrollRequest_Filter as the provided ScrollRequestFilter1
func (t *ScrollRequest_Filter) FromScrollRequestFilter1(v ScrollRequestFilter1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrollRequestFilter1 performs a merge with any union data inside the ScrollRequest_Filter, using the provided ScrollRequestFilter1
func (t *ScrollRequest_Filter) MergeScrollRequestFilter1(v ScrollRequestFilter1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ScrollRequest_Filter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScrollRequest_Filter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsExtendedPointId returns the union data inside the ScrollRequest_Offset as a ExtendedPointId
func (t ScrollRequest_Offset) AsExtendedPointId() (ExtendedPointId, error) {
	var body ExtendedPointId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExtendedPointId overwrites any union data inside the ScrollRequest_Offset as the provided ExtendedPointId
func (t *ScrollRequest_Offset) FromExtendedPointId(v ExtendedPointId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExtendedPointId performs a merge with any union data inside the ScrollRequest_Offset, using the provided ExtendedPointId
func (t *ScrollRequest_Offset) MergeExtendedPointId(v ExtendedPointId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsScrollRequestOffset1 returns the union data inside the ScrollRequest_Offset as a ScrollRequestOffset1
func (t ScrollRequest_Offset) AsScrollRequestOffset1() (ScrollRequestOffset1, error) {
	var body ScrollRequestOffset1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrollRequestOffset1 overwrites any union data inside the ScrollRequest_Offset as the provided ScrollRequestOffset1
func (t *ScrollRequest_Offset) FromScrollRequestOffset1(v ScrollRequestOffset1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrollRequestOffset1 performs a merge with any union data inside the ScrollRequest_Offset, using the provided ScrollRequestOffset1
func (t *ScrollRequest_Offset) MergeScrollRequestOffset1(v ScrollRequestOffset1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ScrollRequest_Offset) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScrollRequest_Offset) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWithPayloadInterface returns the union data inside the ScrollRequest_WithPayload as a WithPayloadInterface
func (t ScrollRequest_WithPayload) AsWithPayloadInterface() (WithPayloadInterface, error) {
	var body WithPayloadInterface
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWithPayloadInterface overwrites any union data inside the ScrollRequest_WithPayload as the provided WithPayloadInterface
func (t *ScrollRequest_WithPayload) FromWithPayloadInterface(v WithPayloadInterface) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWithPayloadInterface performs a merge with any union data inside the ScrollRequest_WithPayload, using the provided WithPayloadInterface
func (t *ScrollRequest_WithPayload) MergeWithPayloadInterface(v WithPayloadInterface) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsScrollRequestWithPayload1 returns the union data inside the ScrollRequest_WithPayload as a ScrollRequestWithPayload1
func (t ScrollRequest_WithPayload) AsScrollRequestWithPayload1() (ScrollRequestWithPayload1, error) {
	var body ScrollRequestWithPayload1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrollRequestWithPayload1 overwrites any union data inside the ScrollRequest_WithPayload as the provided ScrollRequestWithPayload1
func (t *ScrollRequest_WithPayload) FromScrollRequestWithPayload1(v ScrollRequestWithPayload1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrollRequestWithPayload1 performs a merge with any union data inside the ScrollRequest_WithPayload, using the provided ScrollRequestWithPayload1
func (t *ScrollRequest_WithPayload) MergeScrollRequestWithPayload1(v ScrollRequestWithPayload1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ScrollRequest_WithPayload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScrollRequest_WithPayload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsExtendedPointId returns the union data inside the ScrollResult_NextPageOffset as a ExtendedPointId
func (t ScrollResult_NextPageOffset) AsExtendedPointId() (ExtendedPointId, error) {
	var body ExtendedPointId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExtendedPointId overwrites any union data inside the ScrollResult_NextPageOffset as the provided ExtendedPointId
func (t *ScrollResult_NextPageOffset) FromExtendedPointId(v ExtendedPointId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExtendedPointId performs a merge with any union data inside the ScrollResult_NextPageOffset, using the provided ExtendedPointId
func (t *ScrollResult_NextPageOffset) MergeExtendedPointId(v ExtendedPointId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsScrollResultNextPageOffset1 returns the union data inside the ScrollResult_NextPageOffset as a ScrollResultNextPageOffset1
func (t ScrollResult_NextPageOffset) AsScrollResultNextPageOffset1() (ScrollResultNextPageOffset1, error) {
	var body ScrollResultNextPageOffset1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrollResultNextPageOffset1 overwrites any union data inside the ScrollResult_NextPageOffset as the provided ScrollResultNextPageOffset1
func (t *ScrollResult_NextPageOffset) FromScrollResultNextPageOffset1(v ScrollResultNextPageOffset1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrollResultNextPageOffset1 performs a merge with any union data inside the ScrollResult_NextPageOffset, using the provided ScrollResultNextPageOffset1
func (t *ScrollResult_NextPageOffset) MergeScrollResultNextPageOffset1(v ScrollResultNextPageOffset1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ScrollResult_NextPageOffset) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScrollResult_NextPageOffset) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantizationSearchParams returns the union data inside the SearchParams_Quantization as a QuantizationSearchParams
func (t SearchParams_Quantization) AsQuantizationSearchParams() (QuantizationSearchParams, error) {
	var body QuantizationSearchParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantizationSearchParams overwrites any union data inside the SearchParams_Quantization as the provided QuantizationSearchParams
func (t *SearchParams_Quantization) FromQuantizationSearchParams(v QuantizationSearchParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantizationSearchParams performs a merge with any union data inside the SearchParams_Quantization, using the provided QuantizationSearchParams
func (t *SearchParams_Quantization) MergeQuantizationSearchParams(v QuantizationSearchParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsSearchParamsQuantization1 returns the union data inside the SearchParams_Quantization as a SearchParamsQuantization1
func (t SearchParams_Quantization) AsSearchParamsQuantization1() (SearchParamsQuantization1, error) {
	var body SearchParamsQuantization1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchParamsQuantization1 overwrites any union data inside the SearchParams_Quantization as the provided SearchParamsQuantization1
func (t *SearchParams_Quantization) FromSearchParamsQuantization1(v SearchParamsQuantization1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchParamsQuantization1 performs a merge with any union data inside the SearchParams_Quantization, using the provided SearchParamsQuantization1
func (t *SearchParams_Quantization) MergeSearchParamsQuantization1(v SearchParamsQuantization1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t SearchParams_Quantization) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SearchParams_Quantization) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// func (t SearchRequest_Filter) MarshalJSON() ([]byte, error) {
// 	b, err := json.Marshal(t)
// 	return b, err
// }

// func (t *SearchRequest_Filter) UnmarshalJSON(b []byte) error {
// 	err := json.Unmarshal(b, t)
// 	return err
// }

// AsSearchParams returns the union data inside the SearchRequest_Params as a SearchParams
func (t SearchRequest_Params) AsSearchParams() (SearchParams, error) {
	var body SearchParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchParams overwrites any union data inside the SearchRequest_Params as the provided SearchParams
func (t *SearchRequest_Params) FromSearchParams(v SearchParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchParams performs a merge with any union data inside the SearchRequest_Params, using the provided SearchParams
func (t *SearchRequest_Params) MergeSearchParams(v SearchParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsSearchRequestParams1 returns the union data inside the SearchRequest_Params as a SearchRequestParams1
func (t SearchRequest_Params) AsSearchRequestParams1() (SearchRequestParams1, error) {
	var body SearchRequestParams1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchRequestParams1 overwrites any union data inside the SearchRequest_Params as the provided SearchRequestParams1
func (t *SearchRequest_Params) FromSearchRequestParams1(v SearchRequestParams1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchRequestParams1 performs a merge with any union data inside the SearchRequest_Params, using the provided SearchRequestParams1
func (t *SearchRequest_Params) MergeSearchRequestParams1(v SearchRequestParams1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t SearchRequest_Params) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SearchRequest_Params) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWithPayloadInterface returns the union data inside the SearchRequest_WithPayload as a WithPayloadInterface
func (t SearchRequest_WithPayload) AsWithPayloadInterface() (WithPayloadInterface, error) {
	var body WithPayloadInterface
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWithPayloadInterface overwrites any union data inside the SearchRequest_WithPayload as the provided WithPayloadInterface
func (t *SearchRequest_WithPayload) FromWithPayloadInterface(v WithPayloadInterface) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWithPayloadInterface performs a merge with any union data inside the SearchRequest_WithPayload, using the provided WithPayloadInterface
func (t *SearchRequest_WithPayload) MergeWithPayloadInterface(v WithPayloadInterface) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsSearchRequestWithPayload1 returns the union data inside the SearchRequest_WithPayload as a SearchRequestWithPayload1
func (t SearchRequest_WithPayload) AsSearchRequestWithPayload1() (SearchRequestWithPayload1, error) {
	var body SearchRequestWithPayload1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchRequestWithPayload1 overwrites any union data inside the SearchRequest_WithPayload as the provided SearchRequestWithPayload1
func (t *SearchRequest_WithPayload) FromSearchRequestWithPayload1(v SearchRequestWithPayload1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchRequestWithPayload1 performs a merge with any union data inside the SearchRequest_WithPayload, using the provided SearchRequestWithPayload1
func (t *SearchRequest_WithPayload) MergeSearchRequestWithPayload1(v SearchRequestWithPayload1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t SearchRequest_WithPayload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SearchRequest_WithPayload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWithVector returns the union data inside the SearchRequest_WithVector as a WithVector
func (t SearchRequest_WithVector) AsWithVector() (WithVector, error) {
	var body WithVector
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWithVector overwrites any union data inside the SearchRequest_WithVector as the provided WithVector
func (t *SearchRequest_WithVector) FromWithVector(v WithVector) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWithVector performs a merge with any union data inside the SearchRequest_WithVector, using the provided WithVector
func (t *SearchRequest_WithVector) MergeWithVector(v WithVector) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsSearchRequestWithVector1 returns the union data inside the SearchRequest_WithVector as a SearchRequestWithVector1
func (t SearchRequest_WithVector) AsSearchRequestWithVector1() (SearchRequestWithVector1, error) {
	var body SearchRequestWithVector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchRequestWithVector1 overwrites any union data inside the SearchRequest_WithVector as the provided SearchRequestWithVector1
func (t *SearchRequest_WithVector) FromSearchRequestWithVector1(v SearchRequestWithVector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchRequestWithVector1 performs a merge with any union data inside the SearchRequest_WithVector, using the provided SearchRequestWithVector1
func (t *SearchRequest_WithVector) MergeSearchRequestWithVector1(v SearchRequestWithVector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t SearchRequest_WithVector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SearchRequest_WithVector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantizationConfig returns the union data inside the SegmentConfig_QuantizationConfig as a QuantizationConfig
func (t SegmentConfig_QuantizationConfig) AsQuantizationConfig() (QuantizationConfig, error) {
	var body QuantizationConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantizationConfig overwrites any union data inside the SegmentConfig_QuantizationConfig as the provided QuantizationConfig
func (t *SegmentConfig_QuantizationConfig) FromQuantizationConfig(v QuantizationConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantizationConfig performs a merge with any union data inside the SegmentConfig_QuantizationConfig, using the provided QuantizationConfig
func (t *SegmentConfig_QuantizationConfig) MergeQuantizationConfig(v QuantizationConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsSegmentConfigQuantizationConfig1 returns the union data inside the SegmentConfig_QuantizationConfig as a SegmentConfigQuantizationConfig1
func (t SegmentConfig_QuantizationConfig) AsSegmentConfigQuantizationConfig1() (SegmentConfigQuantizationConfig1, error) {
	var body SegmentConfigQuantizationConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSegmentConfigQuantizationConfig1 overwrites any union data inside the SegmentConfig_QuantizationConfig as the provided SegmentConfigQuantizationConfig1
func (t *SegmentConfig_QuantizationConfig) FromSegmentConfigQuantizationConfig1(v SegmentConfigQuantizationConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSegmentConfigQuantizationConfig1 performs a merge with any union data inside the SegmentConfig_QuantizationConfig, using the provided SegmentConfigQuantizationConfig1
func (t *SegmentConfig_QuantizationConfig) MergeSegmentConfigQuantizationConfig1(v SegmentConfigQuantizationConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t SegmentConfig_QuantizationConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SegmentConfig_QuantizationConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFilter returns the union data inside the SetPayload_Filter as a Filter
func (t SetPayload_Filter) AsFilter() (Filter, error) {
	var body Filter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFilter overwrites any union data inside the SetPayload_Filter as the provided Filter
func (t *SetPayload_Filter) FromFilter(v Filter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFilter performs a merge with any union data inside the SetPayload_Filter, using the provided Filter
func (t *SetPayload_Filter) MergeFilter(v Filter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsSetPayloadFilter1 returns the union data inside the SetPayload_Filter as a SetPayloadFilter1
func (t SetPayload_Filter) AsSetPayloadFilter1() (SetPayloadFilter1, error) {
	var body SetPayloadFilter1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetPayloadFilter1 overwrites any union data inside the SetPayload_Filter as the provided SetPayloadFilter1
func (t *SetPayload_Filter) FromSetPayloadFilter1(v SetPayloadFilter1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetPayloadFilter1 performs a merge with any union data inside the SetPayload_Filter, using the provided SetPayloadFilter1
func (t *SetPayload_Filter) MergeSetPayloadFilter1(v SetPayloadFilter1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t SetPayload_Filter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SetPayload_Filter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSnapshotPriority returns the union data inside the SnapshotRecover_Priority as a SnapshotPriority
func (t SnapshotRecover_Priority) AsSnapshotPriority() (SnapshotPriority, error) {
	var body SnapshotPriority
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapshotPriority overwrites any union data inside the SnapshotRecover_Priority as the provided SnapshotPriority
func (t *SnapshotRecover_Priority) FromSnapshotPriority(v SnapshotPriority) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapshotPriority performs a merge with any union data inside the SnapshotRecover_Priority, using the provided SnapshotPriority
func (t *SnapshotRecover_Priority) MergeSnapshotPriority(v SnapshotPriority) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsSnapshotRecoverPriority1 returns the union data inside the SnapshotRecover_Priority as a SnapshotRecoverPriority1
func (t SnapshotRecover_Priority) AsSnapshotRecoverPriority1() (SnapshotRecoverPriority1, error) {
	var body SnapshotRecoverPriority1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnapshotRecoverPriority1 overwrites any union data inside the SnapshotRecover_Priority as the provided SnapshotRecoverPriority1
func (t *SnapshotRecover_Priority) FromSnapshotRecoverPriority1(v SnapshotRecoverPriority1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnapshotRecoverPriority1 performs a merge with any union data inside the SnapshotRecover_Priority, using the provided SnapshotRecoverPriority1
func (t *SnapshotRecover_Priority) MergeSnapshotRecoverPriority1(v SnapshotRecoverPriority1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t SnapshotRecover_Priority) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SnapshotRecover_Priority) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStorageType0 returns the union data inside the StorageType as a StorageType0
func (t StorageType) AsStorageType0() (StorageType0, error) {
	var body StorageType0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStorageType0 overwrites any union data inside the StorageType as the provided StorageType0
func (t *StorageType) FromStorageType0(v StorageType0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStorageType0 performs a merge with any union data inside the StorageType, using the provided StorageType0
func (t *StorageType) MergeStorageType0(v StorageType0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsStorageType1 returns the union data inside the StorageType as a StorageType1
func (t StorageType) AsStorageType1() (StorageType1, error) {
	var body StorageType1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStorageType1 overwrites any union data inside the StorageType as the provided StorageType1
func (t *StorageType) FromStorageType1(v StorageType1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStorageType1 performs a merge with any union data inside the StorageType, using the provided StorageType1
func (t *StorageType) MergeStorageType1(v StorageType1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t StorageType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StorageType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOptimizersConfigDiff returns the union data inside the UpdateCollection_OptimizersConfig as a OptimizersConfigDiff
func (t UpdateCollection_OptimizersConfig) AsOptimizersConfigDiff() (OptimizersConfigDiff, error) {
	var body OptimizersConfigDiff
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOptimizersConfigDiff overwrites any union data inside the UpdateCollection_OptimizersConfig as the provided OptimizersConfigDiff
func (t *UpdateCollection_OptimizersConfig) FromOptimizersConfigDiff(v OptimizersConfigDiff) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOptimizersConfigDiff performs a merge with any union data inside the UpdateCollection_OptimizersConfig, using the provided OptimizersConfigDiff
func (t *UpdateCollection_OptimizersConfig) MergeOptimizersConfigDiff(v OptimizersConfigDiff) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsUpdateCollectionOptimizersConfig1 returns the union data inside the UpdateCollection_OptimizersConfig as a UpdateCollectionOptimizersConfig1
func (t UpdateCollection_OptimizersConfig) AsUpdateCollectionOptimizersConfig1() (UpdateCollectionOptimizersConfig1, error) {
	var body UpdateCollectionOptimizersConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateCollectionOptimizersConfig1 overwrites any union data inside the UpdateCollection_OptimizersConfig as the provided UpdateCollectionOptimizersConfig1
func (t *UpdateCollection_OptimizersConfig) FromUpdateCollectionOptimizersConfig1(v UpdateCollectionOptimizersConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateCollectionOptimizersConfig1 performs a merge with any union data inside the UpdateCollection_OptimizersConfig, using the provided UpdateCollectionOptimizersConfig1
func (t *UpdateCollection_OptimizersConfig) MergeUpdateCollectionOptimizersConfig1(v UpdateCollectionOptimizersConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t UpdateCollection_OptimizersConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateCollection_OptimizersConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCollectionParamsDiff returns the union data inside the UpdateCollection_Params as a CollectionParamsDiff
func (t UpdateCollection_Params) AsCollectionParamsDiff() (CollectionParamsDiff, error) {
	var body CollectionParamsDiff
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCollectionParamsDiff overwrites any union data inside the UpdateCollection_Params as the provided CollectionParamsDiff
func (t *UpdateCollection_Params) FromCollectionParamsDiff(v CollectionParamsDiff) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCollectionParamsDiff performs a merge with any union data inside the UpdateCollection_Params, using the provided CollectionParamsDiff
func (t *UpdateCollection_Params) MergeCollectionParamsDiff(v CollectionParamsDiff) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsUpdateCollectionParams1 returns the union data inside the UpdateCollection_Params as a UpdateCollectionParams1
func (t UpdateCollection_Params) AsUpdateCollectionParams1() (UpdateCollectionParams1, error) {
	var body UpdateCollectionParams1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateCollectionParams1 overwrites any union data inside the UpdateCollection_Params as the provided UpdateCollectionParams1
func (t *UpdateCollection_Params) FromUpdateCollectionParams1(v UpdateCollectionParams1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateCollectionParams1 performs a merge with any union data inside the UpdateCollection_Params, using the provided UpdateCollectionParams1
func (t *UpdateCollection_Params) MergeUpdateCollectionParams1(v UpdateCollectionParams1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t UpdateCollection_Params) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateCollection_Params) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUsingVector0 returns the union data inside the UsingVector as a UsingVector0
func (t UsingVector) AsUsingVector0() (UsingVector0, error) {
	var body UsingVector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUsingVector0 overwrites any union data inside the UsingVector as the provided UsingVector0
func (t *UsingVector) FromUsingVector0(v UsingVector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUsingVector0 performs a merge with any union data inside the UsingVector, using the provided UsingVector0
func (t *UsingVector) MergeUsingVector0(v UsingVector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t UsingVector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UsingVector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsValueVariants0 returns the union data inside the ValueVariants as a ValueVariants0
func (t ValueVariants) AsValueVariants0() (ValueVariants0, error) {
	var body ValueVariants0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValueVariants0 overwrites any union data inside the ValueVariants as the provided ValueVariants0
func (t *ValueVariants) FromValueVariants0(v ValueVariants0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValueVariants0 performs a merge with any union data inside the ValueVariants, using the provided ValueVariants0
func (t *ValueVariants) MergeValueVariants0(v ValueVariants0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsValueVariants1 returns the union data inside the ValueVariants as a ValueVariants1
func (t ValueVariants) AsValueVariants1() (ValueVariants1, error) {
	var body ValueVariants1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValueVariants1 overwrites any union data inside the ValueVariants as the provided ValueVariants1
func (t *ValueVariants) FromValueVariants1(v ValueVariants1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValueVariants1 performs a merge with any union data inside the ValueVariants, using the provided ValueVariants1
func (t *ValueVariants) MergeValueVariants1(v ValueVariants1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsValueVariants2 returns the union data inside the ValueVariants as a ValueVariants2
func (t ValueVariants) AsValueVariants2() (ValueVariants2, error) {
	var body ValueVariants2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValueVariants2 overwrites any union data inside the ValueVariants as the provided ValueVariants2
func (t *ValueVariants) FromValueVariants2(v ValueVariants2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValueVariants2 performs a merge with any union data inside the ValueVariants, using the provided ValueVariants2
func (t *ValueVariants) MergeValueVariants2(v ValueVariants2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ValueVariants) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ValueVariants) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVectorStruct0 returns the union data inside the VectorStruct as a VectorStruct0
func (t VectorStruct) AsVectorStruct0() (VectorStruct0, error) {
	var body VectorStruct0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVectorStruct0 overwrites any union data inside the VectorStruct as the provided VectorStruct0
func (t *VectorStruct) FromVectorStruct0(v VectorStruct0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVectorStruct0 performs a merge with any union data inside the VectorStruct, using the provided VectorStruct0
func (t *VectorStruct) MergeVectorStruct0(v VectorStruct0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsVectorStruct1 returns the union data inside the VectorStruct as a VectorStruct1
func (t VectorStruct) AsVectorStruct1() (VectorStruct1, error) {
	var body VectorStruct1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVectorStruct1 overwrites any union data inside the VectorStruct as the provided VectorStruct1
func (t *VectorStruct) FromVectorStruct1(v VectorStruct1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVectorStruct1 performs a merge with any union data inside the VectorStruct, using the provided VectorStruct1
func (t *VectorStruct) MergeVectorStruct1(v VectorStruct1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t VectorStruct) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VectorStruct) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVectorParams returns the union data inside the VectorsConfig as a VectorParams
func (t VectorsConfig) AsVectorParams() (VectorParams, error) {
	var body VectorParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVectorParams overwrites any union data inside the VectorsConfig as the provided VectorParams
func (t *VectorsConfig) FromVectorParams(v VectorParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVectorParams performs a merge with any union data inside the VectorsConfig, using the provided VectorParams
func (t *VectorsConfig) MergeVectorParams(v VectorParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsVectorsConfig1 returns the union data inside the VectorsConfig as a VectorsConfig1
func (t VectorsConfig) AsVectorsConfig1() (VectorsConfig1, error) {
	var body VectorsConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVectorsConfig1 overwrites any union data inside the VectorsConfig as the provided VectorsConfig1
func (t *VectorsConfig) FromVectorsConfig1(v VectorsConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVectorsConfig1 performs a merge with any union data inside the VectorsConfig, using the provided VectorsConfig1
func (t *VectorsConfig) MergeVectorsConfig1(v VectorsConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t VectorsConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VectorsConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWithPayloadInterface0 returns the union data inside the WithPayloadInterface as a WithPayloadInterface0
func (t WithPayloadInterface) AsWithPayloadInterface0() (WithPayloadInterface0, error) {
	var body WithPayloadInterface0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWithPayloadInterface0 overwrites any union data inside the WithPayloadInterface as the provided WithPayloadInterface0
func (t *WithPayloadInterface) FromWithPayloadInterface0(v WithPayloadInterface0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWithPayloadInterface0 performs a merge with any union data inside the WithPayloadInterface, using the provided WithPayloadInterface0
func (t *WithPayloadInterface) MergeWithPayloadInterface0(v WithPayloadInterface0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsWithPayloadInterface1 returns the union data inside the WithPayloadInterface as a WithPayloadInterface1
func (t WithPayloadInterface) AsWithPayloadInterface1() (WithPayloadInterface1, error) {
	var body WithPayloadInterface1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWithPayloadInterface1 overwrites any union data inside the WithPayloadInterface as the provided WithPayloadInterface1
func (t *WithPayloadInterface) FromWithPayloadInterface1(v WithPayloadInterface1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWithPayloadInterface1 performs a merge with any union data inside the WithPayloadInterface, using the provided WithPayloadInterface1
func (t *WithPayloadInterface) MergeWithPayloadInterface1(v WithPayloadInterface1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPayloadSelector returns the union data inside the WithPayloadInterface as a PayloadSelector
func (t WithPayloadInterface) AsPayloadSelector() (PayloadSelector, error) {
	var body PayloadSelector
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayloadSelector overwrites any union data inside the WithPayloadInterface as the provided PayloadSelector
func (t *WithPayloadInterface) FromPayloadSelector(v PayloadSelector) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayloadSelector performs a merge with any union data inside the WithPayloadInterface, using the provided PayloadSelector
func (t *WithPayloadInterface) MergePayloadSelector(v PayloadSelector) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t WithPayloadInterface) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WithPayloadInterface) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWithVector0 returns the union data inside the WithVector as a WithVector0
func (t WithVector) AsWithVector0() (WithVector0, error) {
	var body WithVector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWithVector0 overwrites any union data inside the WithVector as the provided WithVector0
func (t *WithVector) FromWithVector0(v WithVector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWithVector0 performs a merge with any union data inside the WithVector, using the provided WithVector0
func (t *WithVector) MergeWithVector0(v WithVector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsWithVector1 returns the union data inside the WithVector as a WithVector1
func (t WithVector) AsWithVector1() (WithVector1, error) {
	var body WithVector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWithVector1 overwrites any union data inside the WithVector as the provided WithVector1
func (t *WithVector) FromWithVector1(v WithVector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWithVector1 performs a merge with any union data inside the WithVector, using the provided WithVector1
func (t *WithVector) MergeWithVector1(v WithVector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t WithVector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WithVector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCollectionsAliases request
	GetCollectionsAliases(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClusterStatus request
	ClusterStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePeer request
	RemovePeer(ctx context.Context, peerId int, params *RemovePeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverCurrentPeer request
	RecoverCurrentPeer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollections request
	GetCollections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAliases request with any body
	UpdateAliasesWithBody(ctx context.Context, params *UpdateAliasesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAliases(ctx context.Context, params *UpdateAliasesParams, body UpdateAliasesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCollection request
	DeleteCollection(ctx context.Context, collectionName string, params *DeleteCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollection request
	GetCollection(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCollection request with any body
	UpdateCollectionWithBody(ctx context.Context, collectionName string, params *UpdateCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCollection(ctx context.Context, collectionName string, params *UpdateCollectionParams, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCollection request with any body
	CreateCollectionWithBody(ctx context.Context, collectionName string, params *CreateCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCollection(ctx context.Context, collectionName string, params *CreateCollectionParams, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectionAliases request
	GetCollectionAliases(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectionClusterInfo request
	CollectionClusterInfo(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCollectionCluster request with any body
	UpdateCollectionClusterWithBody(ctx context.Context, collectionName string, params *UpdateCollectionClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCollectionCluster(ctx context.Context, collectionName string, params *UpdateCollectionClusterParams, body UpdateCollectionClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFieldIndex request with any body
	CreateFieldIndexWithBody(ctx context.Context, collectionName string, params *CreateFieldIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFieldIndex(ctx context.Context, collectionName string, params *CreateFieldIndexParams, body CreateFieldIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFieldIndex request
	DeleteFieldIndex(ctx context.Context, collectionName string, fieldName string, params *DeleteFieldIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPoints request with any body
	GetPointsWithBody(ctx context.Context, collectionName string, params *GetPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPoints(ctx context.Context, collectionName string, params *GetPointsParams, body GetPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertPoints request with any body
	UpsertPointsWithBody(ctx context.Context, collectionName string, params *UpsertPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertPoints(ctx context.Context, collectionName string, params *UpsertPointsParams, body UpsertPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountPoints request with any body
	CountPointsWithBody(ctx context.Context, collectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CountPoints(ctx context.Context, collectionName string, body CountPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePoints request with any body
	DeletePointsWithBody(ctx context.Context, collectionName string, params *DeletePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePoints(ctx context.Context, collectionName string, params *DeletePointsParams, body DeletePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPayload request with any body
	SetPayloadWithBody(ctx context.Context, collectionName string, params *SetPayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetPayload(ctx context.Context, collectionName string, params *SetPayloadParams, body SetPayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OverwritePayload request with any body
	OverwritePayloadWithBody(ctx context.Context, collectionName string, params *OverwritePayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OverwritePayload(ctx context.Context, collectionName string, params *OverwritePayloadParams, body OverwritePayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearPayload request with any body
	ClearPayloadWithBody(ctx context.Context, collectionName string, params *ClearPayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClearPayload(ctx context.Context, collectionName string, params *ClearPayloadParams, body ClearPayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePayload request with any body
	DeletePayloadWithBody(ctx context.Context, collectionName string, params *DeletePayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePayload(ctx context.Context, collectionName string, params *DeletePayloadParams, body DeletePayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecommendPoints request with any body
	RecommendPointsWithBody(ctx context.Context, collectionName string, params *RecommendPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RecommendPoints(ctx context.Context, collectionName string, params *RecommendPointsParams, body RecommendPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecommendBatchPoints request with any body
	RecommendBatchPointsWithBody(ctx context.Context, collectionName string, params *RecommendBatchPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RecommendBatchPoints(ctx context.Context, collectionName string, params *RecommendBatchPointsParams, body RecommendBatchPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScrollPoints request with any body
	ScrollPointsWithBody(ctx context.Context, collectionName string, params *ScrollPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScrollPoints(ctx context.Context, collectionName string, params *ScrollPointsParams, body ScrollPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchPoints request with any body
	SearchPointsWithBody(ctx context.Context, collectionName string, params *SearchPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchPoints(ctx context.Context, collectionName string, params *SearchPointsParams, body SearchPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchBatchPoints request with any body
	SearchBatchPointsWithBody(ctx context.Context, collectionName string, params *SearchBatchPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchBatchPoints(ctx context.Context, collectionName string, params *SearchBatchPointsParams, body SearchBatchPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPoint request
	GetPoint(ctx context.Context, collectionName string, id ExtendedPointId, params *GetPointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSnapshots request
	ListSnapshots(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSnapshot request
	CreateSnapshot(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverFromSnapshot request with any body
	RecoverFromSnapshotWithBody(ctx context.Context, collectionName string, params *RecoverFromSnapshotParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RecoverFromSnapshot(ctx context.Context, collectionName string, params *RecoverFromSnapshotParams, body RecoverFromSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSnapshot request
	DeleteSnapshot(ctx context.Context, collectionName string, snapshotName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSnapshot request
	GetSnapshot(ctx context.Context, collectionName string, snapshotName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocks request
	GetLocks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLocks request with any body
	PostLocksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLocks(ctx context.Context, body PostLocksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Metrics request
	Metrics(ctx context.Context, params *MetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFullSnapshots request
	ListFullSnapshots(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFullSnapshot request
	CreateFullSnapshot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFullSnapshot request
	DeleteFullSnapshot(ctx context.Context, snapshotName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFullSnapshot request
	GetFullSnapshot(ctx context.Context, snapshotName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Telemetry request
	Telemetry(ctx context.Context, params *TelemetryParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCollectionsAliases(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionsAliasesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClusterStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClusterStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePeer(ctx context.Context, peerId int, params *RemovePeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePeerRequest(c.Server, peerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverCurrentPeer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverCurrentPeerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAliasesWithBody(ctx context.Context, params *UpdateAliasesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAliasesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAliases(ctx context.Context, params *UpdateAliasesParams, body UpdateAliasesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAliasesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCollection(ctx context.Context, collectionName string, params *DeleteCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCollectionRequest(c.Server, collectionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollection(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionRequest(c.Server, collectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollectionWithBody(ctx context.Context, collectionName string, params *UpdateCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollectionRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollection(ctx context.Context, collectionName string, params *UpdateCollectionParams, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollectionRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollectionWithBody(ctx context.Context, collectionName string, params *CreateCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollection(ctx context.Context, collectionName string, params *CreateCollectionParams, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectionAliases(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionAliasesRequest(c.Server, collectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionClusterInfo(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionClusterInfoRequest(c.Server, collectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollectionClusterWithBody(ctx context.Context, collectionName string, params *UpdateCollectionClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollectionClusterRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollectionCluster(ctx context.Context, collectionName string, params *UpdateCollectionClusterParams, body UpdateCollectionClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollectionClusterRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFieldIndexWithBody(ctx context.Context, collectionName string, params *CreateFieldIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFieldIndexRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFieldIndex(ctx context.Context, collectionName string, params *CreateFieldIndexParams, body CreateFieldIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFieldIndexRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFieldIndex(ctx context.Context, collectionName string, fieldName string, params *DeleteFieldIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFieldIndexRequest(c.Server, collectionName, fieldName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPointsWithBody(ctx context.Context, collectionName string, params *GetPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPointsRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPoints(ctx context.Context, collectionName string, params *GetPointsParams, body GetPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPointsRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertPointsWithBody(ctx context.Context, collectionName string, params *UpsertPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertPointsRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertPoints(ctx context.Context, collectionName string, params *UpsertPointsParams, body UpsertPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertPointsRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountPointsWithBody(ctx context.Context, collectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountPointsRequestWithBody(c.Server, collectionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountPoints(ctx context.Context, collectionName string, body CountPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountPointsRequest(c.Server, collectionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePointsWithBody(ctx context.Context, collectionName string, params *DeletePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePointsRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePoints(ctx context.Context, collectionName string, params *DeletePointsParams, body DeletePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePointsRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPayloadWithBody(ctx context.Context, collectionName string, params *SetPayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPayloadRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPayload(ctx context.Context, collectionName string, params *SetPayloadParams, body SetPayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPayloadRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OverwritePayloadWithBody(ctx context.Context, collectionName string, params *OverwritePayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOverwritePayloadRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OverwritePayload(ctx context.Context, collectionName string, params *OverwritePayloadParams, body OverwritePayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOverwritePayloadRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearPayloadWithBody(ctx context.Context, collectionName string, params *ClearPayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearPayloadRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearPayload(ctx context.Context, collectionName string, params *ClearPayloadParams, body ClearPayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearPayloadRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePayloadWithBody(ctx context.Context, collectionName string, params *DeletePayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePayloadRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePayload(ctx context.Context, collectionName string, params *DeletePayloadParams, body DeletePayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePayloadRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecommendPointsWithBody(ctx context.Context, collectionName string, params *RecommendPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecommendPointsRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecommendPoints(ctx context.Context, collectionName string, params *RecommendPointsParams, body RecommendPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecommendPointsRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecommendBatchPointsWithBody(ctx context.Context, collectionName string, params *RecommendBatchPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecommendBatchPointsRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecommendBatchPoints(ctx context.Context, collectionName string, params *RecommendBatchPointsParams, body RecommendBatchPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecommendBatchPointsRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScrollPointsWithBody(ctx context.Context, collectionName string, params *ScrollPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScrollPointsRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScrollPoints(ctx context.Context, collectionName string, params *ScrollPointsParams, body ScrollPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScrollPointsRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPointsWithBody(ctx context.Context, collectionName string, params *SearchPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPointsRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPoints(ctx context.Context, collectionName string, params *SearchPointsParams, body SearchPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPointsRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchBatchPointsWithBody(ctx context.Context, collectionName string, params *SearchBatchPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchBatchPointsRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchBatchPoints(ctx context.Context, collectionName string, params *SearchBatchPointsParams, body SearchBatchPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchBatchPointsRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPoint(ctx context.Context, collectionName string, id ExtendedPointId, params *GetPointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPointRequest(c.Server, collectionName, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSnapshots(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSnapshotsRequest(c.Server, collectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshot(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequest(c.Server, collectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverFromSnapshotWithBody(ctx context.Context, collectionName string, params *RecoverFromSnapshotParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverFromSnapshotRequestWithBody(c.Server, collectionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverFromSnapshot(ctx context.Context, collectionName string, params *RecoverFromSnapshotParams, body RecoverFromSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverFromSnapshotRequest(c.Server, collectionName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSnapshot(ctx context.Context, collectionName string, snapshotName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSnapshotRequest(c.Server, collectionName, snapshotName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSnapshot(ctx context.Context, collectionName string, snapshotName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSnapshotRequest(c.Server, collectionName, snapshotName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLocksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLocksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLocks(ctx context.Context, body PostLocksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLocksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Metrics(ctx context.Context, params *MetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFullSnapshots(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFullSnapshotsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFullSnapshot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFullSnapshotRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFullSnapshot(ctx context.Context, snapshotName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFullSnapshotRequest(c.Server, snapshotName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFullSnapshot(ctx context.Context, snapshotName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFullSnapshotRequest(c.Server, snapshotName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Telemetry(ctx context.Context, params *TelemetryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTelemetryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCollectionsAliasesRequest generates requests for GetCollectionsAliases
func NewGetCollectionsAliasesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aliases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClusterStatusRequest generates requests for ClusterStatus
func NewClusterStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemovePeerRequest generates requests for RemovePeer
func NewRemovePeerRequest(server string, peerId int, params *RemovePeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "peer_id", runtime.ParamLocationPath, peerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster/peer/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecoverCurrentPeerRequest generates requests for RecoverCurrentPeer
func NewRecoverCurrentPeerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster/recover")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionsRequest generates requests for GetCollections
func NewGetCollectionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAliasesRequest calls the generic UpdateAliases builder with application/json body
func NewUpdateAliasesRequest(server string, params *UpdateAliasesParams, body UpdateAliasesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAliasesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateAliasesRequestWithBody generates requests for UpdateAliases with any type of body
func NewUpdateAliasesRequestWithBody(server string, params *UpdateAliasesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/aliases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Timeout != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCollectionRequest generates requests for DeleteCollection
func NewDeleteCollectionRequest(server string, collectionName string, params *DeleteCollectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Timeout != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionRequest generates requests for GetCollection
func NewGetCollectionRequest(server string, collectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCollectionRequest calls the generic UpdateCollection builder with application/json body
func NewUpdateCollectionRequest(server string, collectionName string, params *UpdateCollectionParams, body UpdateCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCollectionRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewUpdateCollectionRequestWithBody generates requests for UpdateCollection with any type of body
func NewUpdateCollectionRequestWithBody(server string, collectionName string, params *UpdateCollectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Timeout != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCollectionRequest calls the generic CreateCollection builder with application/json body
func NewCreateCollectionRequest(server string, collectionName string, params *CreateCollectionParams, body CreateCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCollectionRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewCreateCollectionRequestWithBody generates requests for CreateCollection with any type of body
func NewCreateCollectionRequestWithBody(server string, collectionName string, params *CreateCollectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Timeout != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCollectionAliasesRequest generates requests for GetCollectionAliases
func NewGetCollectionAliasesRequest(server string, collectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/aliases", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCollectionClusterInfoRequest generates requests for CollectionClusterInfo
func NewCollectionClusterInfoRequest(server string, collectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/cluster", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCollectionClusterRequest calls the generic UpdateCollectionCluster builder with application/json body
func NewUpdateCollectionClusterRequest(server string, collectionName string, params *UpdateCollectionClusterParams, body UpdateCollectionClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCollectionClusterRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewUpdateCollectionClusterRequestWithBody generates requests for UpdateCollectionCluster with any type of body
func NewUpdateCollectionClusterRequestWithBody(server string, collectionName string, params *UpdateCollectionClusterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/cluster", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Timeout != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFieldIndexRequest calls the generic CreateFieldIndex builder with application/json body
func NewCreateFieldIndexRequest(server string, collectionName string, params *CreateFieldIndexParams, body CreateFieldIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFieldIndexRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewCreateFieldIndexRequestWithBody generates requests for CreateFieldIndex with any type of body
func NewCreateFieldIndexRequestWithBody(server string, collectionName string, params *CreateFieldIndexParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/index", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Wait != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wait", runtime.ParamLocationQuery, *params.Wait); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ordering != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ordering", runtime.ParamLocationQuery, *params.Ordering); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFieldIndexRequest generates requests for DeleteFieldIndex
func NewDeleteFieldIndexRequest(server string, collectionName string, fieldName string, params *DeleteFieldIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "field_name", runtime.ParamLocationPath, fieldName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/index/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Wait != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wait", runtime.ParamLocationQuery, *params.Wait); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ordering != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ordering", runtime.ParamLocationQuery, *params.Ordering); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPointsRequest calls the generic GetPoints builder with application/json body
func NewGetPointsRequest(server string, collectionName string, params *GetPointsParams, body GetPointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPointsRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewGetPointsRequestWithBody generates requests for GetPoints with any type of body
func NewGetPointsRequestWithBody(server string, collectionName string, params *GetPointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Consistency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistency", runtime.ParamLocationQuery, *params.Consistency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertPointsRequest calls the generic UpsertPoints builder with application/json body
func NewUpsertPointsRequest(server string, collectionName string, params *UpsertPointsParams, body UpsertPointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertPointsRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewUpsertPointsRequestWithBody generates requests for UpsertPoints with any type of body
func NewUpsertPointsRequestWithBody(server string, collectionName string, params *UpsertPointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Wait != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wait", runtime.ParamLocationQuery, *params.Wait); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ordering != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ordering", runtime.ParamLocationQuery, *params.Ordering); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountPointsRequest calls the generic CountPoints builder with application/json body
func NewCountPointsRequest(server string, collectionName string, body CountPointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCountPointsRequestWithBody(server, collectionName, "application/json", bodyReader)
}

// NewCountPointsRequestWithBody generates requests for CountPoints with any type of body
func NewCountPointsRequestWithBody(server string, collectionName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePointsRequest calls the generic DeletePoints builder with application/json body
func NewDeletePointsRequest(server string, collectionName string, params *DeletePointsParams, body DeletePointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePointsRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewDeletePointsRequestWithBody generates requests for DeletePoints with any type of body
func NewDeletePointsRequestWithBody(server string, collectionName string, params *DeletePointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Wait != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wait", runtime.ParamLocationQuery, *params.Wait); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ordering != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ordering", runtime.ParamLocationQuery, *params.Ordering); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetPayloadRequest calls the generic SetPayload builder with application/json body
func NewSetPayloadRequest(server string, collectionName string, params *SetPayloadParams, body SetPayloadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPayloadRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewSetPayloadRequestWithBody generates requests for SetPayload with any type of body
func NewSetPayloadRequestWithBody(server string, collectionName string, params *SetPayloadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points/payload", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Wait != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wait", runtime.ParamLocationQuery, *params.Wait); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ordering != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ordering", runtime.ParamLocationQuery, *params.Ordering); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOverwritePayloadRequest calls the generic OverwritePayload builder with application/json body
func NewOverwritePayloadRequest(server string, collectionName string, params *OverwritePayloadParams, body OverwritePayloadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOverwritePayloadRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewOverwritePayloadRequestWithBody generates requests for OverwritePayload with any type of body
func NewOverwritePayloadRequestWithBody(server string, collectionName string, params *OverwritePayloadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points/payload", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Wait != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wait", runtime.ParamLocationQuery, *params.Wait); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ordering != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ordering", runtime.ParamLocationQuery, *params.Ordering); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearPayloadRequest calls the generic ClearPayload builder with application/json body
func NewClearPayloadRequest(server string, collectionName string, params *ClearPayloadParams, body ClearPayloadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClearPayloadRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewClearPayloadRequestWithBody generates requests for ClearPayload with any type of body
func NewClearPayloadRequestWithBody(server string, collectionName string, params *ClearPayloadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points/payload/clear", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Wait != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wait", runtime.ParamLocationQuery, *params.Wait); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ordering != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ordering", runtime.ParamLocationQuery, *params.Ordering); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePayloadRequest calls the generic DeletePayload builder with application/json body
func NewDeletePayloadRequest(server string, collectionName string, params *DeletePayloadParams, body DeletePayloadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePayloadRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewDeletePayloadRequestWithBody generates requests for DeletePayload with any type of body
func NewDeletePayloadRequestWithBody(server string, collectionName string, params *DeletePayloadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points/payload/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Wait != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wait", runtime.ParamLocationQuery, *params.Wait); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ordering != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ordering", runtime.ParamLocationQuery, *params.Ordering); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecommendPointsRequest calls the generic RecommendPoints builder with application/json body
func NewRecommendPointsRequest(server string, collectionName string, params *RecommendPointsParams, body RecommendPointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRecommendPointsRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewRecommendPointsRequestWithBody generates requests for RecommendPoints with any type of body
func NewRecommendPointsRequestWithBody(server string, collectionName string, params *RecommendPointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points/recommend", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Consistency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistency", runtime.ParamLocationQuery, *params.Consistency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecommendBatchPointsRequest calls the generic RecommendBatchPoints builder with application/json body
func NewRecommendBatchPointsRequest(server string, collectionName string, params *RecommendBatchPointsParams, body RecommendBatchPointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRecommendBatchPointsRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewRecommendBatchPointsRequestWithBody generates requests for RecommendBatchPoints with any type of body
func NewRecommendBatchPointsRequestWithBody(server string, collectionName string, params *RecommendBatchPointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points/recommend/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Consistency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistency", runtime.ParamLocationQuery, *params.Consistency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScrollPointsRequest calls the generic ScrollPoints builder with application/json body
func NewScrollPointsRequest(server string, collectionName string, params *ScrollPointsParams, body ScrollPointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScrollPointsRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewScrollPointsRequestWithBody generates requests for ScrollPoints with any type of body
func NewScrollPointsRequestWithBody(server string, collectionName string, params *ScrollPointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points/scroll", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Consistency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistency", runtime.ParamLocationQuery, *params.Consistency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchPointsRequest calls the generic SearchPoints builder with application/json body
func NewSearchPointsRequest(server string, collectionName string, params *SearchPointsParams, body SearchPointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchPointsRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewSearchPointsRequestWithBody generates requests for SearchPoints with any type of body
func NewSearchPointsRequestWithBody(server string, collectionName string, params *SearchPointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Consistency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistency", runtime.ParamLocationQuery, *params.Consistency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchBatchPointsRequest calls the generic SearchBatchPoints builder with application/json body
func NewSearchBatchPointsRequest(server string, collectionName string, params *SearchBatchPointsParams, body SearchBatchPointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchBatchPointsRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewSearchBatchPointsRequestWithBody generates requests for SearchBatchPoints with any type of body
func NewSearchBatchPointsRequestWithBody(server string, collectionName string, params *SearchBatchPointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points/search/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Consistency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistency", runtime.ParamLocationQuery, *params.Consistency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPointRequest generates requests for GetPoint
func NewGetPointRequest(server string, collectionName string, id ExtendedPointId, params *GetPointParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/points/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Consistency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistency", runtime.ParamLocationQuery, *params.Consistency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSnapshotsRequest generates requests for ListSnapshots
func NewListSnapshotsRequest(server string, collectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSnapshotRequest generates requests for CreateSnapshot
func NewCreateSnapshotRequest(server string, collectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecoverFromSnapshotRequest calls the generic RecoverFromSnapshot builder with application/json body
func NewRecoverFromSnapshotRequest(server string, collectionName string, params *RecoverFromSnapshotParams, body RecoverFromSnapshotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRecoverFromSnapshotRequestWithBody(server, collectionName, params, "application/json", bodyReader)
}

// NewRecoverFromSnapshotRequestWithBody generates requests for RecoverFromSnapshot with any type of body
func NewRecoverFromSnapshotRequestWithBody(server string, collectionName string, params *RecoverFromSnapshotParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/snapshots/recover", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Wait != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wait", runtime.ParamLocationQuery, *params.Wait); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSnapshotRequest generates requests for DeleteSnapshot
func NewDeleteSnapshotRequest(server string, collectionName string, snapshotName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "snapshot_name", runtime.ParamLocationPath, snapshotName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/snapshots/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSnapshotRequest generates requests for GetSnapshot
func NewGetSnapshotRequest(server string, collectionName string, snapshotName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "snapshot_name", runtime.ParamLocationPath, snapshotName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/snapshots/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocksRequest generates requests for GetLocks
func NewGetLocksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLocksRequest calls the generic PostLocks builder with application/json body
func NewPostLocksRequest(server string, body PostLocksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLocksRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLocksRequestWithBody generates requests for PostLocks with any type of body
func NewPostLocksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricsRequest generates requests for Metrics
func NewMetricsRequest(server string, params *MetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Anonymize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "anonymize", runtime.ParamLocationQuery, *params.Anonymize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFullSnapshotsRequest generates requests for ListFullSnapshots
func NewListFullSnapshotsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFullSnapshotRequest generates requests for CreateFullSnapshot
func NewCreateFullSnapshotRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFullSnapshotRequest generates requests for DeleteFullSnapshot
func NewDeleteFullSnapshotRequest(server string, snapshotName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "snapshot_name", runtime.ParamLocationPath, snapshotName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFullSnapshotRequest generates requests for GetFullSnapshot
func NewGetFullSnapshotRequest(server string, snapshotName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "snapshot_name", runtime.ParamLocationPath, snapshotName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTelemetryRequest generates requests for Telemetry
func NewTelemetryRequest(server string, params *TelemetryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/telemetry")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Anonymize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "anonymize", runtime.ParamLocationQuery, *params.Anonymize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, HttpRequestDoer, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, nil, err
	}
	return &ClientWithResponses{client}, client.Client, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCollectionsAliases request
	GetCollectionsAliasesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCollectionsAliasesResponse, error)

	// ClusterStatus request
	ClusterStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClusterStatusResponse, error)

	// RemovePeer request
	RemovePeerWithResponse(ctx context.Context, peerId int, params *RemovePeerParams, reqEditors ...RequestEditorFn) (*RemovePeerResponse, error)

	// RecoverCurrentPeer request
	RecoverCurrentPeerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RecoverCurrentPeerResponse, error)

	// GetCollections request
	GetCollectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCollectionsResponse, error)

	// UpdateAliases request with any body
	UpdateAliasesWithBodyWithResponse(ctx context.Context, params *UpdateAliasesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAliasesResponse, error)

	UpdateAliasesWithResponse(ctx context.Context, params *UpdateAliasesParams, body UpdateAliasesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAliasesResponse, error)

	// DeleteCollection request
	DeleteCollectionWithResponse(ctx context.Context, collectionName string, params *DeleteCollectionParams, reqEditors ...RequestEditorFn) (*DeleteCollectionResponse, error)

	// GetCollection request
	GetCollectionWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*GetCollectionResponse, error)

	// UpdateCollection request with any body
	UpdateCollectionWithBodyWithResponse(ctx context.Context, collectionName string, params *UpdateCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error)

	UpdateCollectionWithResponse(ctx context.Context, collectionName string, params *UpdateCollectionParams, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error)

	// CreateCollection request with any body
	CreateCollectionWithBodyWithResponse(ctx context.Context, collectionName string, params *CreateCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	CreateCollectionWithResponse(ctx context.Context, collectionName string, params *CreateCollectionParams, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	// GetCollectionAliases request
	GetCollectionAliasesWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*GetCollectionAliasesResponse, error)

	// CollectionClusterInfo request
	CollectionClusterInfoWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*CollectionClusterInfoResponse, error)

	// UpdateCollectionCluster request with any body
	UpdateCollectionClusterWithBodyWithResponse(ctx context.Context, collectionName string, params *UpdateCollectionClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollectionClusterResponse, error)

	UpdateCollectionClusterWithResponse(ctx context.Context, collectionName string, params *UpdateCollectionClusterParams, body UpdateCollectionClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollectionClusterResponse, error)

	// CreateFieldIndex request with any body
	CreateFieldIndexWithBodyWithResponse(ctx context.Context, collectionName string, params *CreateFieldIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFieldIndexResponse, error)

	CreateFieldIndexWithResponse(ctx context.Context, collectionName string, params *CreateFieldIndexParams, body CreateFieldIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFieldIndexResponse, error)

	// DeleteFieldIndex request
	DeleteFieldIndexWithResponse(ctx context.Context, collectionName string, fieldName string, params *DeleteFieldIndexParams, reqEditors ...RequestEditorFn) (*DeleteFieldIndexResponse, error)

	// GetPoints request with any body
	GetPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *GetPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPointsResponse, error)

	GetPointsWithResponse(ctx context.Context, collectionName string, params *GetPointsParams, body GetPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPointsResponse, error)

	// UpsertPoints request with any body
	UpsertPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *UpsertPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertPointsResponse, error)

	UpsertPointsWithResponse(ctx context.Context, collectionName string, params *UpsertPointsParams, body UpsertPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertPointsResponse, error)

	// CountPoints request with any body
	CountPointsWithBodyWithResponse(ctx context.Context, collectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CountPointsResponse, error)

	CountPointsWithResponse(ctx context.Context, collectionName string, body CountPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*CountPointsResponse, error)

	// DeletePoints request with any body
	DeletePointsWithBodyWithResponse(ctx context.Context, collectionName string, params *DeletePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePointsResponse, error)

	DeletePointsWithResponse(ctx context.Context, collectionName string, params *DeletePointsParams, body DeletePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePointsResponse, error)

	// SetPayload request with any body
	SetPayloadWithBodyWithResponse(ctx context.Context, collectionName string, params *SetPayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPayloadResponse, error)

	SetPayloadWithResponse(ctx context.Context, collectionName string, params *SetPayloadParams, body SetPayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPayloadResponse, error)

	// OverwritePayload request with any body
	OverwritePayloadWithBodyWithResponse(ctx context.Context, collectionName string, params *OverwritePayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OverwritePayloadResponse, error)

	OverwritePayloadWithResponse(ctx context.Context, collectionName string, params *OverwritePayloadParams, body OverwritePayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*OverwritePayloadResponse, error)

	// ClearPayload request with any body
	ClearPayloadWithBodyWithResponse(ctx context.Context, collectionName string, params *ClearPayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClearPayloadResponse, error)

	ClearPayloadWithResponse(ctx context.Context, collectionName string, params *ClearPayloadParams, body ClearPayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*ClearPayloadResponse, error)

	// DeletePayload request with any body
	DeletePayloadWithBodyWithResponse(ctx context.Context, collectionName string, params *DeletePayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePayloadResponse, error)

	DeletePayloadWithResponse(ctx context.Context, collectionName string, params *DeletePayloadParams, body DeletePayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePayloadResponse, error)

	// RecommendPoints request with any body
	RecommendPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *RecommendPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecommendPointsResponse, error)

	RecommendPointsWithResponse(ctx context.Context, collectionName string, params *RecommendPointsParams, body RecommendPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*RecommendPointsResponse, error)

	// RecommendBatchPoints request with any body
	RecommendBatchPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *RecommendBatchPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecommendBatchPointsResponse, error)

	RecommendBatchPointsWithResponse(ctx context.Context, collectionName string, params *RecommendBatchPointsParams, body RecommendBatchPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*RecommendBatchPointsResponse, error)

	// ScrollPoints request with any body
	ScrollPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *ScrollPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScrollPointsResponse, error)

	ScrollPointsWithResponse(ctx context.Context, collectionName string, params *ScrollPointsParams, body ScrollPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ScrollPointsResponse, error)

	// SearchPoints request with any body
	SearchPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *SearchPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchPointsResponse, error)

	SearchPointsWithResponse(ctx context.Context, collectionName string, params *SearchPointsParams, body SearchPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchPointsResponse, error)

	// SearchBatchPoints request with any body
	SearchBatchPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *SearchBatchPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchBatchPointsResponse, error)

	SearchBatchPointsWithResponse(ctx context.Context, collectionName string, params *SearchBatchPointsParams, body SearchBatchPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchBatchPointsResponse, error)

	// GetPoint request
	GetPointWithResponse(ctx context.Context, collectionName string, id ExtendedPointId, params *GetPointParams, reqEditors ...RequestEditorFn) (*GetPointResponse, error)

	// ListSnapshots request
	ListSnapshotsWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*ListSnapshotsResponse, error)

	// CreateSnapshot request
	CreateSnapshotWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error)

	// RecoverFromSnapshot request with any body
	RecoverFromSnapshotWithBodyWithResponse(ctx context.Context, collectionName string, params *RecoverFromSnapshotParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecoverFromSnapshotResponse, error)

	RecoverFromSnapshotWithResponse(ctx context.Context, collectionName string, params *RecoverFromSnapshotParams, body RecoverFromSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*RecoverFromSnapshotResponse, error)

	// DeleteSnapshot request
	DeleteSnapshotWithResponse(ctx context.Context, collectionName string, snapshotName string, reqEditors ...RequestEditorFn) (*DeleteSnapshotResponse, error)

	// GetSnapshot request
	GetSnapshotWithResponse(ctx context.Context, collectionName string, snapshotName string, reqEditors ...RequestEditorFn) (*GetSnapshotResponse, error)

	// GetLocks request
	GetLocksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocksResponse, error)

	// PostLocks request with any body
	PostLocksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLocksResponse, error)

	PostLocksWithResponse(ctx context.Context, body PostLocksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLocksResponse, error)

	// Metrics request
	MetricsWithResponse(ctx context.Context, params *MetricsParams, reqEditors ...RequestEditorFn) (*MetricsResponse, error)

	// ListFullSnapshots request
	ListFullSnapshotsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListFullSnapshotsResponse, error)

	// CreateFullSnapshot request
	CreateFullSnapshotWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateFullSnapshotResponse, error)

	// DeleteFullSnapshot request
	DeleteFullSnapshotWithResponse(ctx context.Context, snapshotName string, reqEditors ...RequestEditorFn) (*DeleteFullSnapshotResponse, error)

	// GetFullSnapshot request
	GetFullSnapshotWithResponse(ctx context.Context, snapshotName string, reqEditors ...RequestEditorFn) (*GetFullSnapshotResponse, error)

	// Telemetry request
	TelemetryWithResponse(ctx context.Context, params *TelemetryParams, reqEditors ...RequestEditorFn) (*TelemetryResponse, error)
}

type GetCollectionsAliasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *CollectionsAliasesResponse `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCollectionsAliasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionsAliasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClusterStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Result Information about current cluster status and structure
		Result *ClusterStatus `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ClusterStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClusterStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *bool       `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RemovePeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverCurrentPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *bool       `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RecoverCurrentPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverCurrentPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *CollectionsResponse `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAliasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *bool       `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAliasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAliasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *bool       `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Result Current statistics and configuration of the collection
		Result *CollectionInfo `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *bool       `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *bool       `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionAliasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *CollectionsAliasesResponse `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCollectionAliasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionAliasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectionClusterInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Result Current clustering distribution for the collection
		Result *CollectionClusterInfo `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CollectionClusterInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionClusterInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCollectionClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *bool       `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateCollectionClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCollectionClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFieldIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *UpdateResult `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateFieldIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFieldIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFieldIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *UpdateResult `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteFieldIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFieldIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *[]Record   `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertPointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *UpdateResult `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpsertPointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertPointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountPointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *CountResult `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CountPointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountPointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *UpdateResult `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeletePointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPayloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *UpdateResult `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetPayloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPayloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OverwritePayloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *UpdateResult `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r OverwritePayloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OverwritePayloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearPayloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *UpdateResult `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ClearPayloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearPayloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePayloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *UpdateResult `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeletePayloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePayloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecommendPointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *[]ScoredPoint `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RecommendPointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecommendPointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecommendBatchPointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *[][]ScoredPoint `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RecommendBatchPointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecommendBatchPointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScrollPointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Result Result of the points read request
		Result *ScrollResult `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ScrollPointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScrollPointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchPointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *[]ScoredPoint `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SearchPointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchPointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchBatchPointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *[][]ScoredPoint `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SearchBatchPointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchBatchPointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Result Point data
		Result *Record     `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *[]SnapshotDescription `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *SnapshotDescription `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverFromSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *bool       `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RecoverFromSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverFromSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *bool       `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *LocksOption `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLocksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *LocksOption `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostLocksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLocksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFullSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *[]SnapshotDescription `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListFullSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFullSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFullSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *SnapshotDescription `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateFullSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFullSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFullSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *bool       `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteFullSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFullSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFullSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetFullSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFullSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TelemetryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *[]TelemetryData `json:"result,omitempty"`

		// Time Time spent to process this request
		Time *float32 `json:"time,omitempty"`
	}
	JSON4XX     *ErrorResponse
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TelemetryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TelemetryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCollectionsAliasesWithResponse request returning *GetCollectionsAliasesResponse
func (c *ClientWithResponses) GetCollectionsAliasesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCollectionsAliasesResponse, error) {
	rsp, err := c.GetCollectionsAliases(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionsAliasesResponse(rsp)
}

// ClusterStatusWithResponse request returning *ClusterStatusResponse
func (c *ClientWithResponses) ClusterStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClusterStatusResponse, error) {
	rsp, err := c.ClusterStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClusterStatusResponse(rsp)
}

// RemovePeerWithResponse request returning *RemovePeerResponse
func (c *ClientWithResponses) RemovePeerWithResponse(ctx context.Context, peerId int, params *RemovePeerParams, reqEditors ...RequestEditorFn) (*RemovePeerResponse, error) {
	rsp, err := c.RemovePeer(ctx, peerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePeerResponse(rsp)
}

// RecoverCurrentPeerWithResponse request returning *RecoverCurrentPeerResponse
func (c *ClientWithResponses) RecoverCurrentPeerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RecoverCurrentPeerResponse, error) {
	rsp, err := c.RecoverCurrentPeer(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverCurrentPeerResponse(rsp)
}

// GetCollectionsWithResponse request returning *GetCollectionsResponse
func (c *ClientWithResponses) GetCollectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCollectionsResponse, error) {
	rsp, err := c.GetCollections(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionsResponse(rsp)
}

// UpdateAliasesWithBodyWithResponse request with arbitrary body returning *UpdateAliasesResponse
func (c *ClientWithResponses) UpdateAliasesWithBodyWithResponse(ctx context.Context, params *UpdateAliasesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAliasesResponse, error) {
	rsp, err := c.UpdateAliasesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAliasesResponse(rsp)
}

func (c *ClientWithResponses) UpdateAliasesWithResponse(ctx context.Context, params *UpdateAliasesParams, body UpdateAliasesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAliasesResponse, error) {
	rsp, err := c.UpdateAliases(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAliasesResponse(rsp)
}

// DeleteCollectionWithResponse request returning *DeleteCollectionResponse
func (c *ClientWithResponses) DeleteCollectionWithResponse(ctx context.Context, collectionName string, params *DeleteCollectionParams, reqEditors ...RequestEditorFn) (*DeleteCollectionResponse, error) {
	rsp, err := c.DeleteCollection(ctx, collectionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCollectionResponse(rsp)
}

// GetCollectionWithResponse request returning *GetCollectionResponse
func (c *ClientWithResponses) GetCollectionWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*GetCollectionResponse, error) {
	rsp, err := c.GetCollection(ctx, collectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionResponse(rsp)
}

// UpdateCollectionWithBodyWithResponse request with arbitrary body returning *UpdateCollectionResponse
func (c *ClientWithResponses) UpdateCollectionWithBodyWithResponse(ctx context.Context, collectionName string, params *UpdateCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error) {
	rsp, err := c.UpdateCollectionWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateCollectionWithResponse(ctx context.Context, collectionName string, params *UpdateCollectionParams, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error) {
	rsp, err := c.UpdateCollection(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollectionResponse(rsp)
}

// CreateCollectionWithBodyWithResponse request with arbitrary body returning *CreateCollectionResponse
func (c *ClientWithResponses) CreateCollectionWithBodyWithResponse(ctx context.Context, collectionName string, params *CreateCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollectionWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

func (c *ClientWithResponses) CreateCollectionWithResponse(ctx context.Context, collectionName string, params *CreateCollectionParams, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollection(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

// GetCollectionAliasesWithResponse request returning *GetCollectionAliasesResponse
func (c *ClientWithResponses) GetCollectionAliasesWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*GetCollectionAliasesResponse, error) {
	rsp, err := c.GetCollectionAliases(ctx, collectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionAliasesResponse(rsp)
}

// CollectionClusterInfoWithResponse request returning *CollectionClusterInfoResponse
func (c *ClientWithResponses) CollectionClusterInfoWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*CollectionClusterInfoResponse, error) {
	rsp, err := c.CollectionClusterInfo(ctx, collectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionClusterInfoResponse(rsp)
}

// UpdateCollectionClusterWithBodyWithResponse request with arbitrary body returning *UpdateCollectionClusterResponse
func (c *ClientWithResponses) UpdateCollectionClusterWithBodyWithResponse(ctx context.Context, collectionName string, params *UpdateCollectionClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollectionClusterResponse, error) {
	rsp, err := c.UpdateCollectionClusterWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollectionClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateCollectionClusterWithResponse(ctx context.Context, collectionName string, params *UpdateCollectionClusterParams, body UpdateCollectionClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollectionClusterResponse, error) {
	rsp, err := c.UpdateCollectionCluster(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollectionClusterResponse(rsp)
}

// CreateFieldIndexWithBodyWithResponse request with arbitrary body returning *CreateFieldIndexResponse
func (c *ClientWithResponses) CreateFieldIndexWithBodyWithResponse(ctx context.Context, collectionName string, params *CreateFieldIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFieldIndexResponse, error) {
	rsp, err := c.CreateFieldIndexWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFieldIndexResponse(rsp)
}

func (c *ClientWithResponses) CreateFieldIndexWithResponse(ctx context.Context, collectionName string, params *CreateFieldIndexParams, body CreateFieldIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFieldIndexResponse, error) {
	rsp, err := c.CreateFieldIndex(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFieldIndexResponse(rsp)
}

// DeleteFieldIndexWithResponse request returning *DeleteFieldIndexResponse
func (c *ClientWithResponses) DeleteFieldIndexWithResponse(ctx context.Context, collectionName string, fieldName string, params *DeleteFieldIndexParams, reqEditors ...RequestEditorFn) (*DeleteFieldIndexResponse, error) {
	rsp, err := c.DeleteFieldIndex(ctx, collectionName, fieldName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFieldIndexResponse(rsp)
}

// GetPointsWithBodyWithResponse request with arbitrary body returning *GetPointsResponse
func (c *ClientWithResponses) GetPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *GetPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPointsResponse, error) {
	rsp, err := c.GetPointsWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPointsResponse(rsp)
}

func (c *ClientWithResponses) GetPointsWithResponse(ctx context.Context, collectionName string, params *GetPointsParams, body GetPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPointsResponse, error) {
	rsp, err := c.GetPoints(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPointsResponse(rsp)
}

// UpsertPointsWithBodyWithResponse request with arbitrary body returning *UpsertPointsResponse
func (c *ClientWithResponses) UpsertPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *UpsertPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertPointsResponse, error) {
	rsp, err := c.UpsertPointsWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertPointsResponse(rsp)
}

func (c *ClientWithResponses) UpsertPointsWithResponse(ctx context.Context, collectionName string, params *UpsertPointsParams, body UpsertPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertPointsResponse, error) {
	rsp, err := c.UpsertPoints(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertPointsResponse(rsp)
}

// CountPointsWithBodyWithResponse request with arbitrary body returning *CountPointsResponse
func (c *ClientWithResponses) CountPointsWithBodyWithResponse(ctx context.Context, collectionName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CountPointsResponse, error) {
	rsp, err := c.CountPointsWithBody(ctx, collectionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountPointsResponse(rsp)
}

func (c *ClientWithResponses) CountPointsWithResponse(ctx context.Context, collectionName string, body CountPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*CountPointsResponse, error) {
	rsp, err := c.CountPoints(ctx, collectionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountPointsResponse(rsp)
}

// DeletePointsWithBodyWithResponse request with arbitrary body returning *DeletePointsResponse
func (c *ClientWithResponses) DeletePointsWithBodyWithResponse(ctx context.Context, collectionName string, params *DeletePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePointsResponse, error) {
	rsp, err := c.DeletePointsWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePointsResponse(rsp)
}

func (c *ClientWithResponses) DeletePointsWithResponse(ctx context.Context, collectionName string, params *DeletePointsParams, body DeletePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePointsResponse, error) {
	rsp, err := c.DeletePoints(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePointsResponse(rsp)
}

// SetPayloadWithBodyWithResponse request with arbitrary body returning *SetPayloadResponse
func (c *ClientWithResponses) SetPayloadWithBodyWithResponse(ctx context.Context, collectionName string, params *SetPayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPayloadResponse, error) {
	rsp, err := c.SetPayloadWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPayloadResponse(rsp)
}

func (c *ClientWithResponses) SetPayloadWithResponse(ctx context.Context, collectionName string, params *SetPayloadParams, body SetPayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPayloadResponse, error) {
	rsp, err := c.SetPayload(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPayloadResponse(rsp)
}

// OverwritePayloadWithBodyWithResponse request with arbitrary body returning *OverwritePayloadResponse
func (c *ClientWithResponses) OverwritePayloadWithBodyWithResponse(ctx context.Context, collectionName string, params *OverwritePayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OverwritePayloadResponse, error) {
	rsp, err := c.OverwritePayloadWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOverwritePayloadResponse(rsp)
}

func (c *ClientWithResponses) OverwritePayloadWithResponse(ctx context.Context, collectionName string, params *OverwritePayloadParams, body OverwritePayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*OverwritePayloadResponse, error) {
	rsp, err := c.OverwritePayload(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOverwritePayloadResponse(rsp)
}

// ClearPayloadWithBodyWithResponse request with arbitrary body returning *ClearPayloadResponse
func (c *ClientWithResponses) ClearPayloadWithBodyWithResponse(ctx context.Context, collectionName string, params *ClearPayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClearPayloadResponse, error) {
	rsp, err := c.ClearPayloadWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearPayloadResponse(rsp)
}

func (c *ClientWithResponses) ClearPayloadWithResponse(ctx context.Context, collectionName string, params *ClearPayloadParams, body ClearPayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*ClearPayloadResponse, error) {
	rsp, err := c.ClearPayload(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearPayloadResponse(rsp)
}

// DeletePayloadWithBodyWithResponse request with arbitrary body returning *DeletePayloadResponse
func (c *ClientWithResponses) DeletePayloadWithBodyWithResponse(ctx context.Context, collectionName string, params *DeletePayloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePayloadResponse, error) {
	rsp, err := c.DeletePayloadWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePayloadResponse(rsp)
}

func (c *ClientWithResponses) DeletePayloadWithResponse(ctx context.Context, collectionName string, params *DeletePayloadParams, body DeletePayloadJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePayloadResponse, error) {
	rsp, err := c.DeletePayload(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePayloadResponse(rsp)
}

// RecommendPointsWithBodyWithResponse request with arbitrary body returning *RecommendPointsResponse
func (c *ClientWithResponses) RecommendPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *RecommendPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecommendPointsResponse, error) {
	rsp, err := c.RecommendPointsWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecommendPointsResponse(rsp)
}

func (c *ClientWithResponses) RecommendPointsWithResponse(ctx context.Context, collectionName string, params *RecommendPointsParams, body RecommendPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*RecommendPointsResponse, error) {
	rsp, err := c.RecommendPoints(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecommendPointsResponse(rsp)
}

// RecommendBatchPointsWithBodyWithResponse request with arbitrary body returning *RecommendBatchPointsResponse
func (c *ClientWithResponses) RecommendBatchPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *RecommendBatchPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecommendBatchPointsResponse, error) {
	rsp, err := c.RecommendBatchPointsWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecommendBatchPointsResponse(rsp)
}

func (c *ClientWithResponses) RecommendBatchPointsWithResponse(ctx context.Context, collectionName string, params *RecommendBatchPointsParams, body RecommendBatchPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*RecommendBatchPointsResponse, error) {
	rsp, err := c.RecommendBatchPoints(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecommendBatchPointsResponse(rsp)
}

// ScrollPointsWithBodyWithResponse request with arbitrary body returning *ScrollPointsResponse
func (c *ClientWithResponses) ScrollPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *ScrollPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScrollPointsResponse, error) {
	rsp, err := c.ScrollPointsWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScrollPointsResponse(rsp)
}

func (c *ClientWithResponses) ScrollPointsWithResponse(ctx context.Context, collectionName string, params *ScrollPointsParams, body ScrollPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ScrollPointsResponse, error) {
	rsp, err := c.ScrollPoints(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScrollPointsResponse(rsp)
}

// SearchPointsWithBodyWithResponse request with arbitrary body returning *SearchPointsResponse
func (c *ClientWithResponses) SearchPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *SearchPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchPointsResponse, error) {
	rsp, err := c.SearchPointsWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPointsResponse(rsp)
}

func (c *ClientWithResponses) SearchPointsWithResponse(ctx context.Context, collectionName string, params *SearchPointsParams, body SearchPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchPointsResponse, error) {
	rsp, err := c.SearchPoints(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPointsResponse(rsp)
}

// SearchBatchPointsWithBodyWithResponse request with arbitrary body returning *SearchBatchPointsResponse
func (c *ClientWithResponses) SearchBatchPointsWithBodyWithResponse(ctx context.Context, collectionName string, params *SearchBatchPointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchBatchPointsResponse, error) {
	rsp, err := c.SearchBatchPointsWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchBatchPointsResponse(rsp)
}

func (c *ClientWithResponses) SearchBatchPointsWithResponse(ctx context.Context, collectionName string, params *SearchBatchPointsParams, body SearchBatchPointsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchBatchPointsResponse, error) {
	rsp, err := c.SearchBatchPoints(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchBatchPointsResponse(rsp)
}

// GetPointWithResponse request returning *GetPointResponse
func (c *ClientWithResponses) GetPointWithResponse(ctx context.Context, collectionName string, id ExtendedPointId, params *GetPointParams, reqEditors ...RequestEditorFn) (*GetPointResponse, error) {
	rsp, err := c.GetPoint(ctx, collectionName, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPointResponse(rsp)
}

// ListSnapshotsWithResponse request returning *ListSnapshotsResponse
func (c *ClientWithResponses) ListSnapshotsWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*ListSnapshotsResponse, error) {
	rsp, err := c.ListSnapshots(ctx, collectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSnapshotsResponse(rsp)
}

// CreateSnapshotWithResponse request returning *CreateSnapshotResponse
func (c *ClientWithResponses) CreateSnapshotWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error) {
	rsp, err := c.CreateSnapshot(ctx, collectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResponse(rsp)
}

// RecoverFromSnapshotWithBodyWithResponse request with arbitrary body returning *RecoverFromSnapshotResponse
func (c *ClientWithResponses) RecoverFromSnapshotWithBodyWithResponse(ctx context.Context, collectionName string, params *RecoverFromSnapshotParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecoverFromSnapshotResponse, error) {
	rsp, err := c.RecoverFromSnapshotWithBody(ctx, collectionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverFromSnapshotResponse(rsp)
}

func (c *ClientWithResponses) RecoverFromSnapshotWithResponse(ctx context.Context, collectionName string, params *RecoverFromSnapshotParams, body RecoverFromSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*RecoverFromSnapshotResponse, error) {
	rsp, err := c.RecoverFromSnapshot(ctx, collectionName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverFromSnapshotResponse(rsp)
}

// DeleteSnapshotWithResponse request returning *DeleteSnapshotResponse
func (c *ClientWithResponses) DeleteSnapshotWithResponse(ctx context.Context, collectionName string, snapshotName string, reqEditors ...RequestEditorFn) (*DeleteSnapshotResponse, error) {
	rsp, err := c.DeleteSnapshot(ctx, collectionName, snapshotName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSnapshotResponse(rsp)
}

// GetSnapshotWithResponse request returning *GetSnapshotResponse
func (c *ClientWithResponses) GetSnapshotWithResponse(ctx context.Context, collectionName string, snapshotName string, reqEditors ...RequestEditorFn) (*GetSnapshotResponse, error) {
	rsp, err := c.GetSnapshot(ctx, collectionName, snapshotName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSnapshotResponse(rsp)
}

// GetLocksWithResponse request returning *GetLocksResponse
func (c *ClientWithResponses) GetLocksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocksResponse, error) {
	rsp, err := c.GetLocks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocksResponse(rsp)
}

// PostLocksWithBodyWithResponse request with arbitrary body returning *PostLocksResponse
func (c *ClientWithResponses) PostLocksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLocksResponse, error) {
	rsp, err := c.PostLocksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLocksResponse(rsp)
}

func (c *ClientWithResponses) PostLocksWithResponse(ctx context.Context, body PostLocksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLocksResponse, error) {
	rsp, err := c.PostLocks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLocksResponse(rsp)
}

// MetricsWithResponse request returning *MetricsResponse
func (c *ClientWithResponses) MetricsWithResponse(ctx context.Context, params *MetricsParams, reqEditors ...RequestEditorFn) (*MetricsResponse, error) {
	rsp, err := c.Metrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricsResponse(rsp)
}

// ListFullSnapshotsWithResponse request returning *ListFullSnapshotsResponse
func (c *ClientWithResponses) ListFullSnapshotsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListFullSnapshotsResponse, error) {
	rsp, err := c.ListFullSnapshots(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFullSnapshotsResponse(rsp)
}

// CreateFullSnapshotWithResponse request returning *CreateFullSnapshotResponse
func (c *ClientWithResponses) CreateFullSnapshotWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateFullSnapshotResponse, error) {
	rsp, err := c.CreateFullSnapshot(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFullSnapshotResponse(rsp)
}

// DeleteFullSnapshotWithResponse request returning *DeleteFullSnapshotResponse
func (c *ClientWithResponses) DeleteFullSnapshotWithResponse(ctx context.Context, snapshotName string, reqEditors ...RequestEditorFn) (*DeleteFullSnapshotResponse, error) {
	rsp, err := c.DeleteFullSnapshot(ctx, snapshotName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFullSnapshotResponse(rsp)
}

// GetFullSnapshotWithResponse request returning *GetFullSnapshotResponse
func (c *ClientWithResponses) GetFullSnapshotWithResponse(ctx context.Context, snapshotName string, reqEditors ...RequestEditorFn) (*GetFullSnapshotResponse, error) {
	rsp, err := c.GetFullSnapshot(ctx, snapshotName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFullSnapshotResponse(rsp)
}

// TelemetryWithResponse request returning *TelemetryResponse
func (c *ClientWithResponses) TelemetryWithResponse(ctx context.Context, params *TelemetryParams, reqEditors ...RequestEditorFn) (*TelemetryResponse, error) {
	rsp, err := c.Telemetry(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTelemetryResponse(rsp)
}

// ParseGetCollectionsAliasesResponse parses an HTTP response from a GetCollectionsAliasesWithResponse call
func ParseGetCollectionsAliasesResponse(rsp *http.Response) (*GetCollectionsAliasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionsAliasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *CollectionsAliasesResponse `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseClusterStatusResponse parses an HTTP response from a ClusterStatusWithResponse call
func ParseClusterStatusResponse(rsp *http.Response) (*ClusterStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClusterStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Result Information about current cluster status and structure
			Result *ClusterStatus `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRemovePeerResponse parses an HTTP response from a RemovePeerWithResponse call
func ParseRemovePeerResponse(rsp *http.Response) (*RemovePeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *bool       `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRecoverCurrentPeerResponse parses an HTTP response from a RecoverCurrentPeerWithResponse call
func ParseRecoverCurrentPeerResponse(rsp *http.Response) (*RecoverCurrentPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverCurrentPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *bool       `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCollectionsResponse parses an HTTP response from a GetCollectionsWithResponse call
func ParseGetCollectionsResponse(rsp *http.Response) (*GetCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *CollectionsResponse `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateAliasesResponse parses an HTTP response from a UpdateAliasesWithResponse call
func ParseUpdateAliasesResponse(rsp *http.Response) (*UpdateAliasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAliasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *bool       `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCollectionResponse parses an HTTP response from a DeleteCollectionWithResponse call
func ParseDeleteCollectionResponse(rsp *http.Response) (*DeleteCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *bool       `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCollectionResponse parses an HTTP response from a GetCollectionWithResponse call
func ParseGetCollectionResponse(rsp *http.Response) (*GetCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Result Current statistics and configuration of the collection
			Result *CollectionInfo `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateCollectionResponse parses an HTTP response from a UpdateCollectionWithResponse call
func ParseUpdateCollectionResponse(rsp *http.Response) (*UpdateCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *bool       `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCollectionResponse parses an HTTP response from a CreateCollectionWithResponse call
func ParseCreateCollectionResponse(rsp *http.Response) (*CreateCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *bool       `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCollectionAliasesResponse parses an HTTP response from a GetCollectionAliasesWithResponse call
func ParseGetCollectionAliasesResponse(rsp *http.Response) (*GetCollectionAliasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionAliasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *CollectionsAliasesResponse `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCollectionClusterInfoResponse parses an HTTP response from a CollectionClusterInfoWithResponse call
func ParseCollectionClusterInfoResponse(rsp *http.Response) (*CollectionClusterInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionClusterInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Result Current clustering distribution for the collection
			Result *CollectionClusterInfo `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateCollectionClusterResponse parses an HTTP response from a UpdateCollectionClusterWithResponse call
func ParseUpdateCollectionClusterResponse(rsp *http.Response) (*UpdateCollectionClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCollectionClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *bool       `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFieldIndexResponse parses an HTTP response from a CreateFieldIndexWithResponse call
func ParseCreateFieldIndexResponse(rsp *http.Response) (*CreateFieldIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFieldIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *UpdateResult `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFieldIndexResponse parses an HTTP response from a DeleteFieldIndexWithResponse call
func ParseDeleteFieldIndexResponse(rsp *http.Response) (*DeleteFieldIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFieldIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *UpdateResult `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPointsResponse parses an HTTP response from a GetPointsWithResponse call
func ParseGetPointsResponse(rsp *http.Response) (*GetPointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *[]Record   `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpsertPointsResponse parses an HTTP response from a UpsertPointsWithResponse call
func ParseUpsertPointsResponse(rsp *http.Response) (*UpsertPointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertPointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *UpdateResult `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCountPointsResponse parses an HTTP response from a CountPointsWithResponse call
func ParseCountPointsResponse(rsp *http.Response) (*CountPointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountPointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *CountResult `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePointsResponse parses an HTTP response from a DeletePointsWithResponse call
func ParseDeletePointsResponse(rsp *http.Response) (*DeletePointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *UpdateResult `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetPayloadResponse parses an HTTP response from a SetPayloadWithResponse call
func ParseSetPayloadResponse(rsp *http.Response) (*SetPayloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPayloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *UpdateResult `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOverwritePayloadResponse parses an HTTP response from a OverwritePayloadWithResponse call
func ParseOverwritePayloadResponse(rsp *http.Response) (*OverwritePayloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OverwritePayloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *UpdateResult `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseClearPayloadResponse parses an HTTP response from a ClearPayloadWithResponse call
func ParseClearPayloadResponse(rsp *http.Response) (*ClearPayloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearPayloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *UpdateResult `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePayloadResponse parses an HTTP response from a DeletePayloadWithResponse call
func ParseDeletePayloadResponse(rsp *http.Response) (*DeletePayloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePayloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *UpdateResult `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRecommendPointsResponse parses an HTTP response from a RecommendPointsWithResponse call
func ParseRecommendPointsResponse(rsp *http.Response) (*RecommendPointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecommendPointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *[]ScoredPoint `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRecommendBatchPointsResponse parses an HTTP response from a RecommendBatchPointsWithResponse call
func ParseRecommendBatchPointsResponse(rsp *http.Response) (*RecommendBatchPointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecommendBatchPointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *[][]ScoredPoint `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseScrollPointsResponse parses an HTTP response from a ScrollPointsWithResponse call
func ParseScrollPointsResponse(rsp *http.Response) (*ScrollPointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScrollPointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Result Result of the points read request
			Result *ScrollResult `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchPointsResponse parses an HTTP response from a SearchPointsWithResponse call
func ParseSearchPointsResponse(rsp *http.Response) (*SearchPointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchPointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *[]ScoredPoint `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchBatchPointsResponse parses an HTTP response from a SearchBatchPointsWithResponse call
func ParseSearchBatchPointsResponse(rsp *http.Response) (*SearchBatchPointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchBatchPointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *[][]ScoredPoint `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPointResponse parses an HTTP response from a GetPointWithResponse call
func ParseGetPointResponse(rsp *http.Response) (*GetPointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Result Point data
			Result *Record     `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListSnapshotsResponse parses an HTTP response from a ListSnapshotsWithResponse call
func ParseListSnapshotsResponse(rsp *http.Response) (*ListSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *[]SnapshotDescription `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSnapshotResponse parses an HTTP response from a CreateSnapshotWithResponse call
func ParseCreateSnapshotResponse(rsp *http.Response) (*CreateSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *SnapshotDescription `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRecoverFromSnapshotResponse parses an HTTP response from a RecoverFromSnapshotWithResponse call
func ParseRecoverFromSnapshotResponse(rsp *http.Response) (*RecoverFromSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverFromSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *bool       `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSnapshotResponse parses an HTTP response from a DeleteSnapshotWithResponse call
func ParseDeleteSnapshotResponse(rsp *http.Response) (*DeleteSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *bool       `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSnapshotResponse parses an HTTP response from a GetSnapshotWithResponse call
func ParseGetSnapshotResponse(rsp *http.Response) (*GetSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLocksResponse parses an HTTP response from a GetLocksWithResponse call
func ParseGetLocksResponse(rsp *http.Response) (*GetLocksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *LocksOption `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostLocksResponse parses an HTTP response from a PostLocksWithResponse call
func ParsePostLocksResponse(rsp *http.Response) (*PostLocksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLocksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *LocksOption `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMetricsResponse parses an HTTP response from a MetricsWithResponse call
func ParseMetricsResponse(rsp *http.Response) (*MetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListFullSnapshotsResponse parses an HTTP response from a ListFullSnapshotsWithResponse call
func ParseListFullSnapshotsResponse(rsp *http.Response) (*ListFullSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFullSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *[]SnapshotDescription `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFullSnapshotResponse parses an HTTP response from a CreateFullSnapshotWithResponse call
func ParseCreateFullSnapshotResponse(rsp *http.Response) (*CreateFullSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFullSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *SnapshotDescription `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFullSnapshotResponse parses an HTTP response from a DeleteFullSnapshotWithResponse call
func ParseDeleteFullSnapshotResponse(rsp *http.Response) (*DeleteFullSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFullSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *bool       `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFullSnapshotResponse parses an HTTP response from a GetFullSnapshotWithResponse call
func ParseGetFullSnapshotResponse(rsp *http.Response) (*GetFullSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFullSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTelemetryResponse parses an HTTP response from a TelemetryWithResponse call
func ParseTelemetryResponse(rsp *http.Response) (*TelemetryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TelemetryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *[]TelemetryData `json:"result,omitempty"`

			// Time Time spent to process this request
			Time *float32 `json:"time,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
