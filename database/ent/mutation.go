// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/stablecog/sc-go/database/ent/apitoken"
	"github.com/stablecog/sc-go/database/ent/authclient"
	"github.com/stablecog/sc-go/database/ent/bannedwords"
	"github.com/stablecog/sc-go/database/ent/credit"
	"github.com/stablecog/sc-go/database/ent/credittype"
	"github.com/stablecog/sc-go/database/ent/deviceinfo"
	"github.com/stablecog/sc-go/database/ent/disposableemail"
	"github.com/stablecog/sc-go/database/ent/generation"
	"github.com/stablecog/sc-go/database/ent/generationmodel"
	"github.com/stablecog/sc-go/database/ent/generationoutput"
	"github.com/stablecog/sc-go/database/ent/generationoutputlike"
	"github.com/stablecog/sc-go/database/ent/ipblacklist"
	"github.com/stablecog/sc-go/database/ent/mqlog"
	"github.com/stablecog/sc-go/database/ent/negativeprompt"
	"github.com/stablecog/sc-go/database/ent/predicate"
	"github.com/stablecog/sc-go/database/ent/prompt"
	"github.com/stablecog/sc-go/database/ent/role"
	"github.com/stablecog/sc-go/database/ent/scheduler"
	"github.com/stablecog/sc-go/database/ent/tiplog"
	"github.com/stablecog/sc-go/database/ent/upscale"
	"github.com/stablecog/sc-go/database/ent/upscalemodel"
	"github.com/stablecog/sc-go/database/ent/upscaleoutput"
	"github.com/stablecog/sc-go/database/ent/user"
	"github.com/stablecog/sc-go/database/ent/voiceover"
	"github.com/stablecog/sc-go/database/ent/voiceovermodel"
	"github.com/stablecog/sc-go/database/ent/voiceoveroutput"
	"github.com/stablecog/sc-go/database/ent/voiceoverspeaker"
	"github.com/stablecog/sc-go/database/enttypes"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApiToken             = "ApiToken"
	TypeAuthClient           = "AuthClient"
	TypeBannedWords          = "BannedWords"
	TypeCredit               = "Credit"
	TypeCreditType           = "CreditType"
	TypeDeviceInfo           = "DeviceInfo"
	TypeDisposableEmail      = "DisposableEmail"
	TypeGeneration           = "Generation"
	TypeGenerationModel      = "GenerationModel"
	TypeGenerationOutput     = "GenerationOutput"
	TypeGenerationOutputLike = "GenerationOutputLike"
	TypeIPBlackList          = "IPBlackList"
	TypeMqLog                = "MqLog"
	TypeNegativePrompt       = "NegativePrompt"
	TypePrompt               = "Prompt"
	TypeRole                 = "Role"
	TypeScheduler            = "Scheduler"
	TypeTipLog               = "TipLog"
	TypeUpscale              = "Upscale"
	TypeUpscaleModel         = "UpscaleModel"
	TypeUpscaleOutput        = "UpscaleOutput"
	TypeUser                 = "User"
	TypeVoiceover            = "Voiceover"
	TypeVoiceoverModel       = "VoiceoverModel"
	TypeVoiceoverOutput      = "VoiceoverOutput"
	TypeVoiceoverSpeaker     = "VoiceoverSpeaker"
)

// ApiTokenMutation represents an operation that mutates the ApiToken nodes in the graph.
type ApiTokenMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	hashed_token        *string
	name                *string
	short_string        *string
	is_active           *bool
	uses                *int
	adduses             *int
	credits_spent       *int
	addcredits_spent    *int
	last_used_at        *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	user                *uuid.UUID
	cleareduser         bool
	generations         map[uuid.UUID]struct{}
	removedgenerations  map[uuid.UUID]struct{}
	clearedgenerations  bool
	upscales            map[uuid.UUID]struct{}
	removedupscales     map[uuid.UUID]struct{}
	clearedupscales     bool
	voiceovers          map[uuid.UUID]struct{}
	removedvoiceovers   map[uuid.UUID]struct{}
	clearedvoiceovers   bool
	auth_clients        *uuid.UUID
	clearedauth_clients bool
	done                bool
	oldValue            func(context.Context) (*ApiToken, error)
	predicates          []predicate.ApiToken
}

var _ ent.Mutation = (*ApiTokenMutation)(nil)

// apitokenOption allows management of the mutation configuration using functional options.
type apitokenOption func(*ApiTokenMutation)

// newApiTokenMutation creates new mutation for the ApiToken entity.
func newApiTokenMutation(c config, op Op, opts ...apitokenOption) *ApiTokenMutation {
	m := &ApiTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeApiToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiTokenID sets the ID field of the mutation.
func withApiTokenID(id uuid.UUID) apitokenOption {
	return func(m *ApiTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiToken
		)
		m.oldValue = func(ctx context.Context) (*ApiToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiToken sets the old ApiToken of the mutation.
func withApiToken(node *ApiToken) apitokenOption {
	return func(m *ApiTokenMutation) {
		m.oldValue = func(context.Context) (*ApiToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiToken entities.
func (m *ApiTokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiTokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiTokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHashedToken sets the "hashed_token" field.
func (m *ApiTokenMutation) SetHashedToken(s string) {
	m.hashed_token = &s
}

// HashedToken returns the value of the "hashed_token" field in the mutation.
func (m *ApiTokenMutation) HashedToken() (r string, exists bool) {
	v := m.hashed_token
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedToken returns the old "hashed_token" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldHashedToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedToken: %w", err)
	}
	return oldValue.HashedToken, nil
}

// ResetHashedToken resets all changes to the "hashed_token" field.
func (m *ApiTokenMutation) ResetHashedToken() {
	m.hashed_token = nil
}

// SetName sets the "name" field.
func (m *ApiTokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApiTokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApiTokenMutation) ResetName() {
	m.name = nil
}

// SetShortString sets the "short_string" field.
func (m *ApiTokenMutation) SetShortString(s string) {
	m.short_string = &s
}

// ShortString returns the value of the "short_string" field in the mutation.
func (m *ApiTokenMutation) ShortString() (r string, exists bool) {
	v := m.short_string
	if v == nil {
		return
	}
	return *v, true
}

// OldShortString returns the old "short_string" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldShortString(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortString is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortString requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortString: %w", err)
	}
	return oldValue.ShortString, nil
}

// ResetShortString resets all changes to the "short_string" field.
func (m *ApiTokenMutation) ResetShortString() {
	m.short_string = nil
}

// SetIsActive sets the "is_active" field.
func (m *ApiTokenMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ApiTokenMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ApiTokenMutation) ResetIsActive() {
	m.is_active = nil
}

// SetUses sets the "uses" field.
func (m *ApiTokenMutation) SetUses(i int) {
	m.uses = &i
	m.adduses = nil
}

// Uses returns the value of the "uses" field in the mutation.
func (m *ApiTokenMutation) Uses() (r int, exists bool) {
	v := m.uses
	if v == nil {
		return
	}
	return *v, true
}

// OldUses returns the old "uses" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldUses(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUses: %w", err)
	}
	return oldValue.Uses, nil
}

// AddUses adds i to the "uses" field.
func (m *ApiTokenMutation) AddUses(i int) {
	if m.adduses != nil {
		*m.adduses += i
	} else {
		m.adduses = &i
	}
}

// AddedUses returns the value that was added to the "uses" field in this mutation.
func (m *ApiTokenMutation) AddedUses() (r int, exists bool) {
	v := m.adduses
	if v == nil {
		return
	}
	return *v, true
}

// ResetUses resets all changes to the "uses" field.
func (m *ApiTokenMutation) ResetUses() {
	m.uses = nil
	m.adduses = nil
}

// SetCreditsSpent sets the "credits_spent" field.
func (m *ApiTokenMutation) SetCreditsSpent(i int) {
	m.credits_spent = &i
	m.addcredits_spent = nil
}

// CreditsSpent returns the value of the "credits_spent" field in the mutation.
func (m *ApiTokenMutation) CreditsSpent() (r int, exists bool) {
	v := m.credits_spent
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditsSpent returns the old "credits_spent" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldCreditsSpent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditsSpent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditsSpent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditsSpent: %w", err)
	}
	return oldValue.CreditsSpent, nil
}

// AddCreditsSpent adds i to the "credits_spent" field.
func (m *ApiTokenMutation) AddCreditsSpent(i int) {
	if m.addcredits_spent != nil {
		*m.addcredits_spent += i
	} else {
		m.addcredits_spent = &i
	}
}

// AddedCreditsSpent returns the value that was added to the "credits_spent" field in this mutation.
func (m *ApiTokenMutation) AddedCreditsSpent() (r int, exists bool) {
	v := m.addcredits_spent
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreditsSpent resets all changes to the "credits_spent" field.
func (m *ApiTokenMutation) ResetCreditsSpent() {
	m.credits_spent = nil
	m.addcredits_spent = nil
}

// SetUserID sets the "user_id" field.
func (m *ApiTokenMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ApiTokenMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ApiTokenMutation) ResetUserID() {
	m.user = nil
}

// SetAuthClientID sets the "auth_client_id" field.
func (m *ApiTokenMutation) SetAuthClientID(u uuid.UUID) {
	m.auth_clients = &u
}

// AuthClientID returns the value of the "auth_client_id" field in the mutation.
func (m *ApiTokenMutation) AuthClientID() (r uuid.UUID, exists bool) {
	v := m.auth_clients
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthClientID returns the old "auth_client_id" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldAuthClientID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthClientID: %w", err)
	}
	return oldValue.AuthClientID, nil
}

// ClearAuthClientID clears the value of the "auth_client_id" field.
func (m *ApiTokenMutation) ClearAuthClientID() {
	m.auth_clients = nil
	m.clearedFields[apitoken.FieldAuthClientID] = struct{}{}
}

// AuthClientIDCleared returns if the "auth_client_id" field was cleared in this mutation.
func (m *ApiTokenMutation) AuthClientIDCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldAuthClientID]
	return ok
}

// ResetAuthClientID resets all changes to the "auth_client_id" field.
func (m *ApiTokenMutation) ResetAuthClientID() {
	m.auth_clients = nil
	delete(m.clearedFields, apitoken.FieldAuthClientID)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *ApiTokenMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *ApiTokenMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *ApiTokenMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[apitoken.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *ApiTokenMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *ApiTokenMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, apitoken.FieldLastUsedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApiTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApiTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApiTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ApiTokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ApiTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ApiTokenMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ApiTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *ApiTokenMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *ApiTokenMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *ApiTokenMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *ApiTokenMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *ApiTokenMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *ApiTokenMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *ApiTokenMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// AddUpscaleIDs adds the "upscales" edge to the Upscale entity by ids.
func (m *ApiTokenMutation) AddUpscaleIDs(ids ...uuid.UUID) {
	if m.upscales == nil {
		m.upscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscales[ids[i]] = struct{}{}
	}
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *ApiTokenMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *ApiTokenMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// RemoveUpscaleIDs removes the "upscales" edge to the Upscale entity by IDs.
func (m *ApiTokenMutation) RemoveUpscaleIDs(ids ...uuid.UUID) {
	if m.removedupscales == nil {
		m.removedupscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscales, ids[i])
		m.removedupscales[ids[i]] = struct{}{}
	}
}

// RemovedUpscales returns the removed IDs of the "upscales" edge to the Upscale entity.
func (m *ApiTokenMutation) RemovedUpscalesIDs() (ids []uuid.UUID) {
	for id := range m.removedupscales {
		ids = append(ids, id)
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
func (m *ApiTokenMutation) UpscalesIDs() (ids []uuid.UUID) {
	for id := range m.upscales {
		ids = append(ids, id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *ApiTokenMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
	m.removedupscales = nil
}

// AddVoiceoverIDs adds the "voiceovers" edge to the Voiceover entity by ids.
func (m *ApiTokenMutation) AddVoiceoverIDs(ids ...uuid.UUID) {
	if m.voiceovers == nil {
		m.voiceovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.voiceovers[ids[i]] = struct{}{}
	}
}

// ClearVoiceovers clears the "voiceovers" edge to the Voiceover entity.
func (m *ApiTokenMutation) ClearVoiceovers() {
	m.clearedvoiceovers = true
}

// VoiceoversCleared reports if the "voiceovers" edge to the Voiceover entity was cleared.
func (m *ApiTokenMutation) VoiceoversCleared() bool {
	return m.clearedvoiceovers
}

// RemoveVoiceoverIDs removes the "voiceovers" edge to the Voiceover entity by IDs.
func (m *ApiTokenMutation) RemoveVoiceoverIDs(ids ...uuid.UUID) {
	if m.removedvoiceovers == nil {
		m.removedvoiceovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.voiceovers, ids[i])
		m.removedvoiceovers[ids[i]] = struct{}{}
	}
}

// RemovedVoiceovers returns the removed IDs of the "voiceovers" edge to the Voiceover entity.
func (m *ApiTokenMutation) RemovedVoiceoversIDs() (ids []uuid.UUID) {
	for id := range m.removedvoiceovers {
		ids = append(ids, id)
	}
	return
}

// VoiceoversIDs returns the "voiceovers" edge IDs in the mutation.
func (m *ApiTokenMutation) VoiceoversIDs() (ids []uuid.UUID) {
	for id := range m.voiceovers {
		ids = append(ids, id)
	}
	return
}

// ResetVoiceovers resets all changes to the "voiceovers" edge.
func (m *ApiTokenMutation) ResetVoiceovers() {
	m.voiceovers = nil
	m.clearedvoiceovers = false
	m.removedvoiceovers = nil
}

// SetAuthClientsID sets the "auth_clients" edge to the AuthClient entity by id.
func (m *ApiTokenMutation) SetAuthClientsID(id uuid.UUID) {
	m.auth_clients = &id
}

// ClearAuthClients clears the "auth_clients" edge to the AuthClient entity.
func (m *ApiTokenMutation) ClearAuthClients() {
	m.clearedauth_clients = true
}

// AuthClientsCleared reports if the "auth_clients" edge to the AuthClient entity was cleared.
func (m *ApiTokenMutation) AuthClientsCleared() bool {
	return m.AuthClientIDCleared() || m.clearedauth_clients
}

// AuthClientsID returns the "auth_clients" edge ID in the mutation.
func (m *ApiTokenMutation) AuthClientsID() (id uuid.UUID, exists bool) {
	if m.auth_clients != nil {
		return *m.auth_clients, true
	}
	return
}

// AuthClientsIDs returns the "auth_clients" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthClientsID instead. It exists only for internal usage by the builders.
func (m *ApiTokenMutation) AuthClientsIDs() (ids []uuid.UUID) {
	if id := m.auth_clients; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthClients resets all changes to the "auth_clients" edge.
func (m *ApiTokenMutation) ResetAuthClients() {
	m.auth_clients = nil
	m.clearedauth_clients = false
}

// Where appends a list predicates to the ApiTokenMutation builder.
func (m *ApiTokenMutation) Where(ps ...predicate.ApiToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiToken).
func (m *ApiTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiTokenMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.hashed_token != nil {
		fields = append(fields, apitoken.FieldHashedToken)
	}
	if m.name != nil {
		fields = append(fields, apitoken.FieldName)
	}
	if m.short_string != nil {
		fields = append(fields, apitoken.FieldShortString)
	}
	if m.is_active != nil {
		fields = append(fields, apitoken.FieldIsActive)
	}
	if m.uses != nil {
		fields = append(fields, apitoken.FieldUses)
	}
	if m.credits_spent != nil {
		fields = append(fields, apitoken.FieldCreditsSpent)
	}
	if m.user != nil {
		fields = append(fields, apitoken.FieldUserID)
	}
	if m.auth_clients != nil {
		fields = append(fields, apitoken.FieldAuthClientID)
	}
	if m.last_used_at != nil {
		fields = append(fields, apitoken.FieldLastUsedAt)
	}
	if m.created_at != nil {
		fields = append(fields, apitoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apitoken.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apitoken.FieldHashedToken:
		return m.HashedToken()
	case apitoken.FieldName:
		return m.Name()
	case apitoken.FieldShortString:
		return m.ShortString()
	case apitoken.FieldIsActive:
		return m.IsActive()
	case apitoken.FieldUses:
		return m.Uses()
	case apitoken.FieldCreditsSpent:
		return m.CreditsSpent()
	case apitoken.FieldUserID:
		return m.UserID()
	case apitoken.FieldAuthClientID:
		return m.AuthClientID()
	case apitoken.FieldLastUsedAt:
		return m.LastUsedAt()
	case apitoken.FieldCreatedAt:
		return m.CreatedAt()
	case apitoken.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apitoken.FieldHashedToken:
		return m.OldHashedToken(ctx)
	case apitoken.FieldName:
		return m.OldName(ctx)
	case apitoken.FieldShortString:
		return m.OldShortString(ctx)
	case apitoken.FieldIsActive:
		return m.OldIsActive(ctx)
	case apitoken.FieldUses:
		return m.OldUses(ctx)
	case apitoken.FieldCreditsSpent:
		return m.OldCreditsSpent(ctx)
	case apitoken.FieldUserID:
		return m.OldUserID(ctx)
	case apitoken.FieldAuthClientID:
		return m.OldAuthClientID(ctx)
	case apitoken.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case apitoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apitoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ApiToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apitoken.FieldHashedToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedToken(v)
		return nil
	case apitoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apitoken.FieldShortString:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortString(v)
		return nil
	case apitoken.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case apitoken.FieldUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUses(v)
		return nil
	case apitoken.FieldCreditsSpent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditsSpent(v)
		return nil
	case apitoken.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apitoken.FieldAuthClientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthClientID(v)
		return nil
	case apitoken.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case apitoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apitoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ApiToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiTokenMutation) AddedFields() []string {
	var fields []string
	if m.adduses != nil {
		fields = append(fields, apitoken.FieldUses)
	}
	if m.addcredits_spent != nil {
		fields = append(fields, apitoken.FieldCreditsSpent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apitoken.FieldUses:
		return m.AddedUses()
	case apitoken.FieldCreditsSpent:
		return m.AddedCreditsSpent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apitoken.FieldUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUses(v)
		return nil
	case apitoken.FieldCreditsSpent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditsSpent(v)
		return nil
	}
	return fmt.Errorf("unknown ApiToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apitoken.FieldAuthClientID) {
		fields = append(fields, apitoken.FieldAuthClientID)
	}
	if m.FieldCleared(apitoken.FieldLastUsedAt) {
		fields = append(fields, apitoken.FieldLastUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiTokenMutation) ClearField(name string) error {
	switch name {
	case apitoken.FieldAuthClientID:
		m.ClearAuthClientID()
		return nil
	case apitoken.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown ApiToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiTokenMutation) ResetField(name string) error {
	switch name {
	case apitoken.FieldHashedToken:
		m.ResetHashedToken()
		return nil
	case apitoken.FieldName:
		m.ResetName()
		return nil
	case apitoken.FieldShortString:
		m.ResetShortString()
		return nil
	case apitoken.FieldIsActive:
		m.ResetIsActive()
		return nil
	case apitoken.FieldUses:
		m.ResetUses()
		return nil
	case apitoken.FieldCreditsSpent:
		m.ResetCreditsSpent()
		return nil
	case apitoken.FieldUserID:
		m.ResetUserID()
		return nil
	case apitoken.FieldAuthClientID:
		m.ResetAuthClientID()
		return nil
	case apitoken.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case apitoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apitoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ApiToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, apitoken.EdgeUser)
	}
	if m.generations != nil {
		edges = append(edges, apitoken.EdgeGenerations)
	}
	if m.upscales != nil {
		edges = append(edges, apitoken.EdgeUpscales)
	}
	if m.voiceovers != nil {
		edges = append(edges, apitoken.EdgeVoiceovers)
	}
	if m.auth_clients != nil {
		edges = append(edges, apitoken.EdgeAuthClients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apitoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case apitoken.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	case apitoken.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.upscales))
		for id := range m.upscales {
			ids = append(ids, id)
		}
		return ids
	case apitoken.EdgeVoiceovers:
		ids := make([]ent.Value, 0, len(m.voiceovers))
		for id := range m.voiceovers {
			ids = append(ids, id)
		}
		return ids
	case apitoken.EdgeAuthClients:
		if id := m.auth_clients; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedgenerations != nil {
		edges = append(edges, apitoken.EdgeGenerations)
	}
	if m.removedupscales != nil {
		edges = append(edges, apitoken.EdgeUpscales)
	}
	if m.removedvoiceovers != nil {
		edges = append(edges, apitoken.EdgeVoiceovers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiTokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apitoken.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	case apitoken.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.removedupscales))
		for id := range m.removedupscales {
			ids = append(ids, id)
		}
		return ids
	case apitoken.EdgeVoiceovers:
		ids := make([]ent.Value, 0, len(m.removedvoiceovers))
		for id := range m.removedvoiceovers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, apitoken.EdgeUser)
	}
	if m.clearedgenerations {
		edges = append(edges, apitoken.EdgeGenerations)
	}
	if m.clearedupscales {
		edges = append(edges, apitoken.EdgeUpscales)
	}
	if m.clearedvoiceovers {
		edges = append(edges, apitoken.EdgeVoiceovers)
	}
	if m.clearedauth_clients {
		edges = append(edges, apitoken.EdgeAuthClients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case apitoken.EdgeUser:
		return m.cleareduser
	case apitoken.EdgeGenerations:
		return m.clearedgenerations
	case apitoken.EdgeUpscales:
		return m.clearedupscales
	case apitoken.EdgeVoiceovers:
		return m.clearedvoiceovers
	case apitoken.EdgeAuthClients:
		return m.clearedauth_clients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiTokenMutation) ClearEdge(name string) error {
	switch name {
	case apitoken.EdgeUser:
		m.ClearUser()
		return nil
	case apitoken.EdgeAuthClients:
		m.ClearAuthClients()
		return nil
	}
	return fmt.Errorf("unknown ApiToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiTokenMutation) ResetEdge(name string) error {
	switch name {
	case apitoken.EdgeUser:
		m.ResetUser()
		return nil
	case apitoken.EdgeGenerations:
		m.ResetGenerations()
		return nil
	case apitoken.EdgeUpscales:
		m.ResetUpscales()
		return nil
	case apitoken.EdgeVoiceovers:
		m.ResetVoiceovers()
		return nil
	case apitoken.EdgeAuthClients:
		m.ResetAuthClients()
		return nil
	}
	return fmt.Errorf("unknown ApiToken edge %s", name)
}

// AuthClientMutation represents an operation that mutates the AuthClient nodes in the graph.
type AuthClientMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	api_tokens        map[uuid.UUID]struct{}
	removedapi_tokens map[uuid.UUID]struct{}
	clearedapi_tokens bool
	done              bool
	oldValue          func(context.Context) (*AuthClient, error)
	predicates        []predicate.AuthClient
}

var _ ent.Mutation = (*AuthClientMutation)(nil)

// authclientOption allows management of the mutation configuration using functional options.
type authclientOption func(*AuthClientMutation)

// newAuthClientMutation creates new mutation for the AuthClient entity.
func newAuthClientMutation(c config, op Op, opts ...authclientOption) *AuthClientMutation {
	m := &AuthClientMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthClient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthClientID sets the ID field of the mutation.
func withAuthClientID(id uuid.UUID) authclientOption {
	return func(m *AuthClientMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthClient
		)
		m.oldValue = func(ctx context.Context) (*AuthClient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthClient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthClient sets the old AuthClient of the mutation.
func withAuthClient(node *AuthClient) authclientOption {
	return func(m *AuthClientMutation) {
		m.oldValue = func(context.Context) (*AuthClient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthClient entities.
func (m *AuthClientMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthClientMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthClientMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthClient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AuthClientMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AuthClientMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AuthClient entity.
// If the AuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthClientMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AuthClientMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthClientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthClientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthClient entity.
// If the AuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthClientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthClientMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthClientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthClientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthClient entity.
// If the AuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthClientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthClientMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAPITokenIDs adds the "api_tokens" edge to the ApiToken entity by ids.
func (m *AuthClientMutation) AddAPITokenIDs(ids ...uuid.UUID) {
	if m.api_tokens == nil {
		m.api_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.api_tokens[ids[i]] = struct{}{}
	}
}

// ClearAPITokens clears the "api_tokens" edge to the ApiToken entity.
func (m *AuthClientMutation) ClearAPITokens() {
	m.clearedapi_tokens = true
}

// APITokensCleared reports if the "api_tokens" edge to the ApiToken entity was cleared.
func (m *AuthClientMutation) APITokensCleared() bool {
	return m.clearedapi_tokens
}

// RemoveAPITokenIDs removes the "api_tokens" edge to the ApiToken entity by IDs.
func (m *AuthClientMutation) RemoveAPITokenIDs(ids ...uuid.UUID) {
	if m.removedapi_tokens == nil {
		m.removedapi_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.api_tokens, ids[i])
		m.removedapi_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAPITokens returns the removed IDs of the "api_tokens" edge to the ApiToken entity.
func (m *AuthClientMutation) RemovedAPITokensIDs() (ids []uuid.UUID) {
	for id := range m.removedapi_tokens {
		ids = append(ids, id)
	}
	return
}

// APITokensIDs returns the "api_tokens" edge IDs in the mutation.
func (m *AuthClientMutation) APITokensIDs() (ids []uuid.UUID) {
	for id := range m.api_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAPITokens resets all changes to the "api_tokens" edge.
func (m *AuthClientMutation) ResetAPITokens() {
	m.api_tokens = nil
	m.clearedapi_tokens = false
	m.removedapi_tokens = nil
}

// Where appends a list predicates to the AuthClientMutation builder.
func (m *AuthClientMutation) Where(ps ...predicate.AuthClient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthClientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthClientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthClient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthClientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthClientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthClient).
func (m *AuthClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthClientMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, authclient.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, authclient.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authclient.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authclient.FieldName:
		return m.Name()
	case authclient.FieldCreatedAt:
		return m.CreatedAt()
	case authclient.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authclient.FieldName:
		return m.OldName(ctx)
	case authclient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authclient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthClient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authclient.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case authclient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authclient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthClient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthClientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthClientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthClient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthClientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthClientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthClient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthClientMutation) ResetField(name string) error {
	switch name {
	case authclient.FieldName:
		m.ResetName()
		return nil
	case authclient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authclient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AuthClient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.api_tokens != nil {
		edges = append(edges, authclient.EdgeAPITokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthClientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authclient.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.api_tokens))
		for id := range m.api_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedapi_tokens != nil {
		edges = append(edges, authclient.EdgeAPITokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthClientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case authclient.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.removedapi_tokens))
		for id := range m.removedapi_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapi_tokens {
		edges = append(edges, authclient.EdgeAPITokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthClientMutation) EdgeCleared(name string) bool {
	switch name {
	case authclient.EdgeAPITokens:
		return m.clearedapi_tokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthClientMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthClient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthClientMutation) ResetEdge(name string) error {
	switch name {
	case authclient.EdgeAPITokens:
		m.ResetAPITokens()
		return nil
	}
	return fmt.Errorf("unknown AuthClient edge %s", name)
}

// BannedWordsMutation represents an operation that mutates the BannedWords nodes in the graph.
type BannedWordsMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	words         *[]string
	appendwords   []string
	reason        *string
	split_match   *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BannedWords, error)
	predicates    []predicate.BannedWords
}

var _ ent.Mutation = (*BannedWordsMutation)(nil)

// bannedwordsOption allows management of the mutation configuration using functional options.
type bannedwordsOption func(*BannedWordsMutation)

// newBannedWordsMutation creates new mutation for the BannedWords entity.
func newBannedWordsMutation(c config, op Op, opts ...bannedwordsOption) *BannedWordsMutation {
	m := &BannedWordsMutation{
		config:        c,
		op:            op,
		typ:           TypeBannedWords,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannedWordsID sets the ID field of the mutation.
func withBannedWordsID(id uuid.UUID) bannedwordsOption {
	return func(m *BannedWordsMutation) {
		var (
			err   error
			once  sync.Once
			value *BannedWords
		)
		m.oldValue = func(ctx context.Context) (*BannedWords, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BannedWords.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBannedWords sets the old BannedWords of the mutation.
func withBannedWords(node *BannedWords) bannedwordsOption {
	return func(m *BannedWordsMutation) {
		m.oldValue = func(context.Context) (*BannedWords, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannedWordsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannedWordsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BannedWords entities.
func (m *BannedWordsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannedWordsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BannedWordsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BannedWords.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWords sets the "words" field.
func (m *BannedWordsMutation) SetWords(s []string) {
	m.words = &s
	m.appendwords = nil
}

// Words returns the value of the "words" field in the mutation.
func (m *BannedWordsMutation) Words() (r []string, exists bool) {
	v := m.words
	if v == nil {
		return
	}
	return *v, true
}

// OldWords returns the old "words" field's value of the BannedWords entity.
// If the BannedWords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannedWordsMutation) OldWords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWords: %w", err)
	}
	return oldValue.Words, nil
}

// AppendWords adds s to the "words" field.
func (m *BannedWordsMutation) AppendWords(s []string) {
	m.appendwords = append(m.appendwords, s...)
}

// AppendedWords returns the list of values that were appended to the "words" field in this mutation.
func (m *BannedWordsMutation) AppendedWords() ([]string, bool) {
	if len(m.appendwords) == 0 {
		return nil, false
	}
	return m.appendwords, true
}

// ResetWords resets all changes to the "words" field.
func (m *BannedWordsMutation) ResetWords() {
	m.words = nil
	m.appendwords = nil
}

// SetReason sets the "reason" field.
func (m *BannedWordsMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *BannedWordsMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the BannedWords entity.
// If the BannedWords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannedWordsMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *BannedWordsMutation) ResetReason() {
	m.reason = nil
}

// SetSplitMatch sets the "split_match" field.
func (m *BannedWordsMutation) SetSplitMatch(b bool) {
	m.split_match = &b
}

// SplitMatch returns the value of the "split_match" field in the mutation.
func (m *BannedWordsMutation) SplitMatch() (r bool, exists bool) {
	v := m.split_match
	if v == nil {
		return
	}
	return *v, true
}

// OldSplitMatch returns the old "split_match" field's value of the BannedWords entity.
// If the BannedWords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannedWordsMutation) OldSplitMatch(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSplitMatch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSplitMatch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSplitMatch: %w", err)
	}
	return oldValue.SplitMatch, nil
}

// ResetSplitMatch resets all changes to the "split_match" field.
func (m *BannedWordsMutation) ResetSplitMatch() {
	m.split_match = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BannedWordsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BannedWordsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BannedWords entity.
// If the BannedWords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannedWordsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BannedWordsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BannedWordsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BannedWordsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BannedWords entity.
// If the BannedWords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannedWordsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BannedWordsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the BannedWordsMutation builder.
func (m *BannedWordsMutation) Where(ps ...predicate.BannedWords) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BannedWordsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BannedWordsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BannedWords, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BannedWordsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BannedWordsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BannedWords).
func (m *BannedWordsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannedWordsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.words != nil {
		fields = append(fields, bannedwords.FieldWords)
	}
	if m.reason != nil {
		fields = append(fields, bannedwords.FieldReason)
	}
	if m.split_match != nil {
		fields = append(fields, bannedwords.FieldSplitMatch)
	}
	if m.created_at != nil {
		fields = append(fields, bannedwords.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bannedwords.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannedWordsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bannedwords.FieldWords:
		return m.Words()
	case bannedwords.FieldReason:
		return m.Reason()
	case bannedwords.FieldSplitMatch:
		return m.SplitMatch()
	case bannedwords.FieldCreatedAt:
		return m.CreatedAt()
	case bannedwords.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannedWordsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bannedwords.FieldWords:
		return m.OldWords(ctx)
	case bannedwords.FieldReason:
		return m.OldReason(ctx)
	case bannedwords.FieldSplitMatch:
		return m.OldSplitMatch(ctx)
	case bannedwords.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bannedwords.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BannedWords field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannedWordsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bannedwords.FieldWords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWords(v)
		return nil
	case bannedwords.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case bannedwords.FieldSplitMatch:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSplitMatch(v)
		return nil
	case bannedwords.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bannedwords.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BannedWords field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannedWordsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannedWordsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannedWordsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BannedWords numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannedWordsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannedWordsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannedWordsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BannedWords nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannedWordsMutation) ResetField(name string) error {
	switch name {
	case bannedwords.FieldWords:
		m.ResetWords()
		return nil
	case bannedwords.FieldReason:
		m.ResetReason()
		return nil
	case bannedwords.FieldSplitMatch:
		m.ResetSplitMatch()
		return nil
	case bannedwords.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bannedwords.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BannedWords field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannedWordsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannedWordsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannedWordsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannedWordsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannedWordsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannedWordsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannedWordsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BannedWords unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannedWordsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BannedWords edge %s", name)
}

// CreditMutation represents an operation that mutates the Credit nodes in the graph.
type CreditMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	remaining_amount    *int32
	addremaining_amount *int32
	expires_at          *time.Time
	stripe_line_item_id *string
	replenished_at      *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	users               *uuid.UUID
	clearedusers        bool
	credit_type         *uuid.UUID
	clearedcredit_type  bool
	done                bool
	oldValue            func(context.Context) (*Credit, error)
	predicates          []predicate.Credit
}

var _ ent.Mutation = (*CreditMutation)(nil)

// creditOption allows management of the mutation configuration using functional options.
type creditOption func(*CreditMutation)

// newCreditMutation creates new mutation for the Credit entity.
func newCreditMutation(c config, op Op, opts ...creditOption) *CreditMutation {
	m := &CreditMutation{
		config:        c,
		op:            op,
		typ:           TypeCredit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCreditID sets the ID field of the mutation.
func withCreditID(id uuid.UUID) creditOption {
	return func(m *CreditMutation) {
		var (
			err   error
			once  sync.Once
			value *Credit
		)
		m.oldValue = func(ctx context.Context) (*Credit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredit sets the old Credit of the mutation.
func withCredit(node *Credit) creditOption {
	return func(m *CreditMutation) {
		m.oldValue = func(context.Context) (*Credit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CreditMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CreditMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Credit entities.
func (m *CreditMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CreditMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CreditMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRemainingAmount sets the "remaining_amount" field.
func (m *CreditMutation) SetRemainingAmount(i int32) {
	m.remaining_amount = &i
	m.addremaining_amount = nil
}

// RemainingAmount returns the value of the "remaining_amount" field in the mutation.
func (m *CreditMutation) RemainingAmount() (r int32, exists bool) {
	v := m.remaining_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingAmount returns the old "remaining_amount" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldRemainingAmount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainingAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainingAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingAmount: %w", err)
	}
	return oldValue.RemainingAmount, nil
}

// AddRemainingAmount adds i to the "remaining_amount" field.
func (m *CreditMutation) AddRemainingAmount(i int32) {
	if m.addremaining_amount != nil {
		*m.addremaining_amount += i
	} else {
		m.addremaining_amount = &i
	}
}

// AddedRemainingAmount returns the value that was added to the "remaining_amount" field in this mutation.
func (m *CreditMutation) AddedRemainingAmount() (r int32, exists bool) {
	v := m.addremaining_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainingAmount resets all changes to the "remaining_amount" field.
func (m *CreditMutation) ResetRemainingAmount() {
	m.remaining_amount = nil
	m.addremaining_amount = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *CreditMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *CreditMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *CreditMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetStripeLineItemID sets the "stripe_line_item_id" field.
func (m *CreditMutation) SetStripeLineItemID(s string) {
	m.stripe_line_item_id = &s
}

// StripeLineItemID returns the value of the "stripe_line_item_id" field in the mutation.
func (m *CreditMutation) StripeLineItemID() (r string, exists bool) {
	v := m.stripe_line_item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeLineItemID returns the old "stripe_line_item_id" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldStripeLineItemID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeLineItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeLineItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeLineItemID: %w", err)
	}
	return oldValue.StripeLineItemID, nil
}

// ClearStripeLineItemID clears the value of the "stripe_line_item_id" field.
func (m *CreditMutation) ClearStripeLineItemID() {
	m.stripe_line_item_id = nil
	m.clearedFields[credit.FieldStripeLineItemID] = struct{}{}
}

// StripeLineItemIDCleared returns if the "stripe_line_item_id" field was cleared in this mutation.
func (m *CreditMutation) StripeLineItemIDCleared() bool {
	_, ok := m.clearedFields[credit.FieldStripeLineItemID]
	return ok
}

// ResetStripeLineItemID resets all changes to the "stripe_line_item_id" field.
func (m *CreditMutation) ResetStripeLineItemID() {
	m.stripe_line_item_id = nil
	delete(m.clearedFields, credit.FieldStripeLineItemID)
}

// SetReplenishedAt sets the "replenished_at" field.
func (m *CreditMutation) SetReplenishedAt(t time.Time) {
	m.replenished_at = &t
}

// ReplenishedAt returns the value of the "replenished_at" field in the mutation.
func (m *CreditMutation) ReplenishedAt() (r time.Time, exists bool) {
	v := m.replenished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReplenishedAt returns the old "replenished_at" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldReplenishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplenishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplenishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplenishedAt: %w", err)
	}
	return oldValue.ReplenishedAt, nil
}

// ResetReplenishedAt resets all changes to the "replenished_at" field.
func (m *CreditMutation) ResetReplenishedAt() {
	m.replenished_at = nil
}

// SetUserID sets the "user_id" field.
func (m *CreditMutation) SetUserID(u uuid.UUID) {
	m.users = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CreditMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CreditMutation) ResetUserID() {
	m.users = nil
}

// SetCreditTypeID sets the "credit_type_id" field.
func (m *CreditMutation) SetCreditTypeID(u uuid.UUID) {
	m.credit_type = &u
}

// CreditTypeID returns the value of the "credit_type_id" field in the mutation.
func (m *CreditMutation) CreditTypeID() (r uuid.UUID, exists bool) {
	v := m.credit_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditTypeID returns the old "credit_type_id" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldCreditTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditTypeID: %w", err)
	}
	return oldValue.CreditTypeID, nil
}

// ResetCreditTypeID resets all changes to the "credit_type_id" field.
func (m *CreditMutation) ResetCreditTypeID() {
	m.credit_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CreditMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CreditMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CreditMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CreditMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CreditMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CreditMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *CreditMutation) SetUsersID(id uuid.UUID) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *CreditMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *CreditMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *CreditMutation) UsersID() (id uuid.UUID, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *CreditMutation) UsersIDs() (ids []uuid.UUID) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *CreditMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// ClearCreditType clears the "credit_type" edge to the CreditType entity.
func (m *CreditMutation) ClearCreditType() {
	m.clearedcredit_type = true
}

// CreditTypeCleared reports if the "credit_type" edge to the CreditType entity was cleared.
func (m *CreditMutation) CreditTypeCleared() bool {
	return m.clearedcredit_type
}

// CreditTypeIDs returns the "credit_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreditTypeID instead. It exists only for internal usage by the builders.
func (m *CreditMutation) CreditTypeIDs() (ids []uuid.UUID) {
	if id := m.credit_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreditType resets all changes to the "credit_type" edge.
func (m *CreditMutation) ResetCreditType() {
	m.credit_type = nil
	m.clearedcredit_type = false
}

// Where appends a list predicates to the CreditMutation builder.
func (m *CreditMutation) Where(ps ...predicate.Credit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CreditMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CreditMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CreditMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CreditMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credit).
func (m *CreditMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CreditMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.remaining_amount != nil {
		fields = append(fields, credit.FieldRemainingAmount)
	}
	if m.expires_at != nil {
		fields = append(fields, credit.FieldExpiresAt)
	}
	if m.stripe_line_item_id != nil {
		fields = append(fields, credit.FieldStripeLineItemID)
	}
	if m.replenished_at != nil {
		fields = append(fields, credit.FieldReplenishedAt)
	}
	if m.users != nil {
		fields = append(fields, credit.FieldUserID)
	}
	if m.credit_type != nil {
		fields = append(fields, credit.FieldCreditTypeID)
	}
	if m.created_at != nil {
		fields = append(fields, credit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, credit.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CreditMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credit.FieldRemainingAmount:
		return m.RemainingAmount()
	case credit.FieldExpiresAt:
		return m.ExpiresAt()
	case credit.FieldStripeLineItemID:
		return m.StripeLineItemID()
	case credit.FieldReplenishedAt:
		return m.ReplenishedAt()
	case credit.FieldUserID:
		return m.UserID()
	case credit.FieldCreditTypeID:
		return m.CreditTypeID()
	case credit.FieldCreatedAt:
		return m.CreatedAt()
	case credit.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CreditMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credit.FieldRemainingAmount:
		return m.OldRemainingAmount(ctx)
	case credit.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case credit.FieldStripeLineItemID:
		return m.OldStripeLineItemID(ctx)
	case credit.FieldReplenishedAt:
		return m.OldReplenishedAt(ctx)
	case credit.FieldUserID:
		return m.OldUserID(ctx)
	case credit.FieldCreditTypeID:
		return m.OldCreditTypeID(ctx)
	case credit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case credit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Credit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credit.FieldRemainingAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingAmount(v)
		return nil
	case credit.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case credit.FieldStripeLineItemID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeLineItemID(v)
		return nil
	case credit.FieldReplenishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplenishedAt(v)
		return nil
	case credit.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case credit.FieldCreditTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditTypeID(v)
		return nil
	case credit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case credit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Credit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CreditMutation) AddedFields() []string {
	var fields []string
	if m.addremaining_amount != nil {
		fields = append(fields, credit.FieldRemainingAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CreditMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case credit.FieldRemainingAmount:
		return m.AddedRemainingAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditMutation) AddField(name string, value ent.Value) error {
	switch name {
	case credit.FieldRemainingAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainingAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Credit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CreditMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credit.FieldStripeLineItemID) {
		fields = append(fields, credit.FieldStripeLineItemID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CreditMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CreditMutation) ClearField(name string) error {
	switch name {
	case credit.FieldStripeLineItemID:
		m.ClearStripeLineItemID()
		return nil
	}
	return fmt.Errorf("unknown Credit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CreditMutation) ResetField(name string) error {
	switch name {
	case credit.FieldRemainingAmount:
		m.ResetRemainingAmount()
		return nil
	case credit.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case credit.FieldStripeLineItemID:
		m.ResetStripeLineItemID()
		return nil
	case credit.FieldReplenishedAt:
		m.ResetReplenishedAt()
		return nil
	case credit.FieldUserID:
		m.ResetUserID()
		return nil
	case credit.FieldCreditTypeID:
		m.ResetCreditTypeID()
		return nil
	case credit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case credit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Credit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CreditMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, credit.EdgeUsers)
	}
	if m.credit_type != nil {
		edges = append(edges, credit.EdgeCreditType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CreditMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credit.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case credit.EdgeCreditType:
		if id := m.credit_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CreditMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CreditMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CreditMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, credit.EdgeUsers)
	}
	if m.clearedcredit_type {
		edges = append(edges, credit.EdgeCreditType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CreditMutation) EdgeCleared(name string) bool {
	switch name {
	case credit.EdgeUsers:
		return m.clearedusers
	case credit.EdgeCreditType:
		return m.clearedcredit_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CreditMutation) ClearEdge(name string) error {
	switch name {
	case credit.EdgeUsers:
		m.ClearUsers()
		return nil
	case credit.EdgeCreditType:
		m.ClearCreditType()
		return nil
	}
	return fmt.Errorf("unknown Credit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CreditMutation) ResetEdge(name string) error {
	switch name {
	case credit.EdgeUsers:
		m.ResetUsers()
		return nil
	case credit.EdgeCreditType:
		m.ResetCreditType()
		return nil
	}
	return fmt.Errorf("unknown Credit edge %s", name)
}

// CreditTypeMutation represents an operation that mutates the CreditType nodes in the graph.
type CreditTypeMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	description       *string
	amount            *int32
	addamount         *int32
	stripe_product_id *string
	_type             *credittype.Type
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	credits           map[uuid.UUID]struct{}
	removedcredits    map[uuid.UUID]struct{}
	clearedcredits    bool
	done              bool
	oldValue          func(context.Context) (*CreditType, error)
	predicates        []predicate.CreditType
}

var _ ent.Mutation = (*CreditTypeMutation)(nil)

// credittypeOption allows management of the mutation configuration using functional options.
type credittypeOption func(*CreditTypeMutation)

// newCreditTypeMutation creates new mutation for the CreditType entity.
func newCreditTypeMutation(c config, op Op, opts ...credittypeOption) *CreditTypeMutation {
	m := &CreditTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCreditType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCreditTypeID sets the ID field of the mutation.
func withCreditTypeID(id uuid.UUID) credittypeOption {
	return func(m *CreditTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CreditType
		)
		m.oldValue = func(ctx context.Context) (*CreditType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CreditType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCreditType sets the old CreditType of the mutation.
func withCreditType(node *CreditType) credittypeOption {
	return func(m *CreditTypeMutation) {
		m.oldValue = func(context.Context) (*CreditType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CreditTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CreditTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CreditType entities.
func (m *CreditTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CreditTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CreditTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CreditType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CreditTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CreditTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CreditTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CreditTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CreditTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CreditTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[credittype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CreditTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[credittype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CreditTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, credittype.FieldDescription)
}

// SetAmount sets the "amount" field.
func (m *CreditTypeMutation) SetAmount(i int32) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *CreditTypeMutation) Amount() (r int32, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldAmount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *CreditTypeMutation) AddAmount(i int32) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *CreditTypeMutation) AddedAmount() (r int32, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *CreditTypeMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStripeProductID sets the "stripe_product_id" field.
func (m *CreditTypeMutation) SetStripeProductID(s string) {
	m.stripe_product_id = &s
}

// StripeProductID returns the value of the "stripe_product_id" field in the mutation.
func (m *CreditTypeMutation) StripeProductID() (r string, exists bool) {
	v := m.stripe_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeProductID returns the old "stripe_product_id" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldStripeProductID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeProductID: %w", err)
	}
	return oldValue.StripeProductID, nil
}

// ClearStripeProductID clears the value of the "stripe_product_id" field.
func (m *CreditTypeMutation) ClearStripeProductID() {
	m.stripe_product_id = nil
	m.clearedFields[credittype.FieldStripeProductID] = struct{}{}
}

// StripeProductIDCleared returns if the "stripe_product_id" field was cleared in this mutation.
func (m *CreditTypeMutation) StripeProductIDCleared() bool {
	_, ok := m.clearedFields[credittype.FieldStripeProductID]
	return ok
}

// ResetStripeProductID resets all changes to the "stripe_product_id" field.
func (m *CreditTypeMutation) ResetStripeProductID() {
	m.stripe_product_id = nil
	delete(m.clearedFields, credittype.FieldStripeProductID)
}

// SetType sets the "type" field.
func (m *CreditTypeMutation) SetType(c credittype.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CreditTypeMutation) GetType() (r credittype.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldType(ctx context.Context) (v credittype.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CreditTypeMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CreditTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CreditTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CreditTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CreditTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CreditTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CreditTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddCreditIDs adds the "credits" edge to the Credit entity by ids.
func (m *CreditTypeMutation) AddCreditIDs(ids ...uuid.UUID) {
	if m.credits == nil {
		m.credits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.credits[ids[i]] = struct{}{}
	}
}

// ClearCredits clears the "credits" edge to the Credit entity.
func (m *CreditTypeMutation) ClearCredits() {
	m.clearedcredits = true
}

// CreditsCleared reports if the "credits" edge to the Credit entity was cleared.
func (m *CreditTypeMutation) CreditsCleared() bool {
	return m.clearedcredits
}

// RemoveCreditIDs removes the "credits" edge to the Credit entity by IDs.
func (m *CreditTypeMutation) RemoveCreditIDs(ids ...uuid.UUID) {
	if m.removedcredits == nil {
		m.removedcredits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.credits, ids[i])
		m.removedcredits[ids[i]] = struct{}{}
	}
}

// RemovedCredits returns the removed IDs of the "credits" edge to the Credit entity.
func (m *CreditTypeMutation) RemovedCreditsIDs() (ids []uuid.UUID) {
	for id := range m.removedcredits {
		ids = append(ids, id)
	}
	return
}

// CreditsIDs returns the "credits" edge IDs in the mutation.
func (m *CreditTypeMutation) CreditsIDs() (ids []uuid.UUID) {
	for id := range m.credits {
		ids = append(ids, id)
	}
	return
}

// ResetCredits resets all changes to the "credits" edge.
func (m *CreditTypeMutation) ResetCredits() {
	m.credits = nil
	m.clearedcredits = false
	m.removedcredits = nil
}

// Where appends a list predicates to the CreditTypeMutation builder.
func (m *CreditTypeMutation) Where(ps ...predicate.CreditType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CreditTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CreditTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CreditType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CreditTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CreditTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CreditType).
func (m *CreditTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CreditTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, credittype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, credittype.FieldDescription)
	}
	if m.amount != nil {
		fields = append(fields, credittype.FieldAmount)
	}
	if m.stripe_product_id != nil {
		fields = append(fields, credittype.FieldStripeProductID)
	}
	if m._type != nil {
		fields = append(fields, credittype.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, credittype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, credittype.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CreditTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credittype.FieldName:
		return m.Name()
	case credittype.FieldDescription:
		return m.Description()
	case credittype.FieldAmount:
		return m.Amount()
	case credittype.FieldStripeProductID:
		return m.StripeProductID()
	case credittype.FieldType:
		return m.GetType()
	case credittype.FieldCreatedAt:
		return m.CreatedAt()
	case credittype.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CreditTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credittype.FieldName:
		return m.OldName(ctx)
	case credittype.FieldDescription:
		return m.OldDescription(ctx)
	case credittype.FieldAmount:
		return m.OldAmount(ctx)
	case credittype.FieldStripeProductID:
		return m.OldStripeProductID(ctx)
	case credittype.FieldType:
		return m.OldType(ctx)
	case credittype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case credittype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CreditType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credittype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case credittype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case credittype.FieldAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case credittype.FieldStripeProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeProductID(v)
		return nil
	case credittype.FieldType:
		v, ok := value.(credittype.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case credittype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case credittype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CreditType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CreditTypeMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, credittype.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CreditTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case credittype.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case credittype.FieldAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown CreditType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CreditTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credittype.FieldDescription) {
		fields = append(fields, credittype.FieldDescription)
	}
	if m.FieldCleared(credittype.FieldStripeProductID) {
		fields = append(fields, credittype.FieldStripeProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CreditTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CreditTypeMutation) ClearField(name string) error {
	switch name {
	case credittype.FieldDescription:
		m.ClearDescription()
		return nil
	case credittype.FieldStripeProductID:
		m.ClearStripeProductID()
		return nil
	}
	return fmt.Errorf("unknown CreditType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CreditTypeMutation) ResetField(name string) error {
	switch name {
	case credittype.FieldName:
		m.ResetName()
		return nil
	case credittype.FieldDescription:
		m.ResetDescription()
		return nil
	case credittype.FieldAmount:
		m.ResetAmount()
		return nil
	case credittype.FieldStripeProductID:
		m.ResetStripeProductID()
		return nil
	case credittype.FieldType:
		m.ResetType()
		return nil
	case credittype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case credittype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CreditType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CreditTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.credits != nil {
		edges = append(edges, credittype.EdgeCredits)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CreditTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credittype.EdgeCredits:
		ids := make([]ent.Value, 0, len(m.credits))
		for id := range m.credits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CreditTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcredits != nil {
		edges = append(edges, credittype.EdgeCredits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CreditTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case credittype.EdgeCredits:
		ids := make([]ent.Value, 0, len(m.removedcredits))
		for id := range m.removedcredits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CreditTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcredits {
		edges = append(edges, credittype.EdgeCredits)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CreditTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case credittype.EdgeCredits:
		return m.clearedcredits
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CreditTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CreditType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CreditTypeMutation) ResetEdge(name string) error {
	switch name {
	case credittype.EdgeCredits:
		m.ResetCredits()
		return nil
	}
	return fmt.Errorf("unknown CreditType edge %s", name)
}

// DeviceInfoMutation represents an operation that mutates the DeviceInfo nodes in the graph.
type DeviceInfoMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	_type              *string
	os                 *string
	browser            *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	upscales           map[uuid.UUID]struct{}
	removedupscales    map[uuid.UUID]struct{}
	clearedupscales    bool
	voiceovers         map[uuid.UUID]struct{}
	removedvoiceovers  map[uuid.UUID]struct{}
	clearedvoiceovers  bool
	done               bool
	oldValue           func(context.Context) (*DeviceInfo, error)
	predicates         []predicate.DeviceInfo
}

var _ ent.Mutation = (*DeviceInfoMutation)(nil)

// deviceinfoOption allows management of the mutation configuration using functional options.
type deviceinfoOption func(*DeviceInfoMutation)

// newDeviceInfoMutation creates new mutation for the DeviceInfo entity.
func newDeviceInfoMutation(c config, op Op, opts ...deviceinfoOption) *DeviceInfoMutation {
	m := &DeviceInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceInfoID sets the ID field of the mutation.
func withDeviceInfoID(id uuid.UUID) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceInfo
		)
		m.oldValue = func(ctx context.Context) (*DeviceInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceInfo sets the old DeviceInfo of the mutation.
func withDeviceInfo(node *DeviceInfo) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		m.oldValue = func(context.Context) (*DeviceInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceInfo entities.
func (m *DeviceInfoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceInfoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceInfoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *DeviceInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DeviceInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *DeviceInfoMutation) ClearType() {
	m._type = nil
	m.clearedFields[deviceinfo.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *DeviceInfoMutation) TypeCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *DeviceInfoMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, deviceinfo.FieldType)
}

// SetOs sets the "os" field.
func (m *DeviceInfoMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *DeviceInfoMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldOs(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ClearOs clears the value of the "os" field.
func (m *DeviceInfoMutation) ClearOs() {
	m.os = nil
	m.clearedFields[deviceinfo.FieldOs] = struct{}{}
}

// OsCleared returns if the "os" field was cleared in this mutation.
func (m *DeviceInfoMutation) OsCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldOs]
	return ok
}

// ResetOs resets all changes to the "os" field.
func (m *DeviceInfoMutation) ResetOs() {
	m.os = nil
	delete(m.clearedFields, deviceinfo.FieldOs)
}

// SetBrowser sets the "browser" field.
func (m *DeviceInfoMutation) SetBrowser(s string) {
	m.browser = &s
}

// Browser returns the value of the "browser" field in the mutation.
func (m *DeviceInfoMutation) Browser() (r string, exists bool) {
	v := m.browser
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowser returns the old "browser" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldBrowser(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowser: %w", err)
	}
	return oldValue.Browser, nil
}

// ClearBrowser clears the value of the "browser" field.
func (m *DeviceInfoMutation) ClearBrowser() {
	m.browser = nil
	m.clearedFields[deviceinfo.FieldBrowser] = struct{}{}
}

// BrowserCleared returns if the "browser" field was cleared in this mutation.
func (m *DeviceInfoMutation) BrowserCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldBrowser]
	return ok
}

// ResetBrowser resets all changes to the "browser" field.
func (m *DeviceInfoMutation) ResetBrowser() {
	m.browser = nil
	delete(m.clearedFields, deviceinfo.FieldBrowser)
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *DeviceInfoMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *DeviceInfoMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *DeviceInfoMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *DeviceInfoMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *DeviceInfoMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *DeviceInfoMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *DeviceInfoMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// AddUpscaleIDs adds the "upscales" edge to the Upscale entity by ids.
func (m *DeviceInfoMutation) AddUpscaleIDs(ids ...uuid.UUID) {
	if m.upscales == nil {
		m.upscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscales[ids[i]] = struct{}{}
	}
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *DeviceInfoMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *DeviceInfoMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// RemoveUpscaleIDs removes the "upscales" edge to the Upscale entity by IDs.
func (m *DeviceInfoMutation) RemoveUpscaleIDs(ids ...uuid.UUID) {
	if m.removedupscales == nil {
		m.removedupscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscales, ids[i])
		m.removedupscales[ids[i]] = struct{}{}
	}
}

// RemovedUpscales returns the removed IDs of the "upscales" edge to the Upscale entity.
func (m *DeviceInfoMutation) RemovedUpscalesIDs() (ids []uuid.UUID) {
	for id := range m.removedupscales {
		ids = append(ids, id)
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
func (m *DeviceInfoMutation) UpscalesIDs() (ids []uuid.UUID) {
	for id := range m.upscales {
		ids = append(ids, id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *DeviceInfoMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
	m.removedupscales = nil
}

// AddVoiceoverIDs adds the "voiceovers" edge to the Voiceover entity by ids.
func (m *DeviceInfoMutation) AddVoiceoverIDs(ids ...uuid.UUID) {
	if m.voiceovers == nil {
		m.voiceovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.voiceovers[ids[i]] = struct{}{}
	}
}

// ClearVoiceovers clears the "voiceovers" edge to the Voiceover entity.
func (m *DeviceInfoMutation) ClearVoiceovers() {
	m.clearedvoiceovers = true
}

// VoiceoversCleared reports if the "voiceovers" edge to the Voiceover entity was cleared.
func (m *DeviceInfoMutation) VoiceoversCleared() bool {
	return m.clearedvoiceovers
}

// RemoveVoiceoverIDs removes the "voiceovers" edge to the Voiceover entity by IDs.
func (m *DeviceInfoMutation) RemoveVoiceoverIDs(ids ...uuid.UUID) {
	if m.removedvoiceovers == nil {
		m.removedvoiceovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.voiceovers, ids[i])
		m.removedvoiceovers[ids[i]] = struct{}{}
	}
}

// RemovedVoiceovers returns the removed IDs of the "voiceovers" edge to the Voiceover entity.
func (m *DeviceInfoMutation) RemovedVoiceoversIDs() (ids []uuid.UUID) {
	for id := range m.removedvoiceovers {
		ids = append(ids, id)
	}
	return
}

// VoiceoversIDs returns the "voiceovers" edge IDs in the mutation.
func (m *DeviceInfoMutation) VoiceoversIDs() (ids []uuid.UUID) {
	for id := range m.voiceovers {
		ids = append(ids, id)
	}
	return
}

// ResetVoiceovers resets all changes to the "voiceovers" edge.
func (m *DeviceInfoMutation) ResetVoiceovers() {
	m.voiceovers = nil
	m.clearedvoiceovers = false
	m.removedvoiceovers = nil
}

// Where appends a list predicates to the DeviceInfoMutation builder.
func (m *DeviceInfoMutation) Where(ps ...predicate.DeviceInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceInfo).
func (m *DeviceInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceInfoMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, deviceinfo.FieldType)
	}
	if m.os != nil {
		fields = append(fields, deviceinfo.FieldOs)
	}
	if m.browser != nil {
		fields = append(fields, deviceinfo.FieldBrowser)
	}
	if m.created_at != nil {
		fields = append(fields, deviceinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceinfo.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceinfo.FieldType:
		return m.GetType()
	case deviceinfo.FieldOs:
		return m.Os()
	case deviceinfo.FieldBrowser:
		return m.Browser()
	case deviceinfo.FieldCreatedAt:
		return m.CreatedAt()
	case deviceinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceinfo.FieldType:
		return m.OldType(ctx)
	case deviceinfo.FieldOs:
		return m.OldOs(ctx)
	case deviceinfo.FieldBrowser:
		return m.OldBrowser(ctx)
	case deviceinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deviceinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceinfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case deviceinfo.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case deviceinfo.FieldBrowser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowser(v)
		return nil
	case deviceinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deviceinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deviceinfo.FieldType) {
		fields = append(fields, deviceinfo.FieldType)
	}
	if m.FieldCleared(deviceinfo.FieldOs) {
		fields = append(fields, deviceinfo.FieldOs)
	}
	if m.FieldCleared(deviceinfo.FieldBrowser) {
		fields = append(fields, deviceinfo.FieldBrowser)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ClearField(name string) error {
	switch name {
	case deviceinfo.FieldType:
		m.ClearType()
		return nil
	case deviceinfo.FieldOs:
		m.ClearOs()
		return nil
	case deviceinfo.FieldBrowser:
		m.ClearBrowser()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ResetField(name string) error {
	switch name {
	case deviceinfo.FieldType:
		m.ResetType()
		return nil
	case deviceinfo.FieldOs:
		m.ResetOs()
		return nil
	case deviceinfo.FieldBrowser:
		m.ResetBrowser()
		return nil
	case deviceinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deviceinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.generations != nil {
		edges = append(edges, deviceinfo.EdgeGenerations)
	}
	if m.upscales != nil {
		edges = append(edges, deviceinfo.EdgeUpscales)
	}
	if m.voiceovers != nil {
		edges = append(edges, deviceinfo.EdgeVoiceovers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deviceinfo.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	case deviceinfo.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.upscales))
		for id := range m.upscales {
			ids = append(ids, id)
		}
		return ids
	case deviceinfo.EdgeVoiceovers:
		ids := make([]ent.Value, 0, len(m.voiceovers))
		for id := range m.voiceovers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgenerations != nil {
		edges = append(edges, deviceinfo.EdgeGenerations)
	}
	if m.removedupscales != nil {
		edges = append(edges, deviceinfo.EdgeUpscales)
	}
	if m.removedvoiceovers != nil {
		edges = append(edges, deviceinfo.EdgeVoiceovers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deviceinfo.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	case deviceinfo.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.removedupscales))
		for id := range m.removedupscales {
			ids = append(ids, id)
		}
		return ids
	case deviceinfo.EdgeVoiceovers:
		ids := make([]ent.Value, 0, len(m.removedvoiceovers))
		for id := range m.removedvoiceovers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgenerations {
		edges = append(edges, deviceinfo.EdgeGenerations)
	}
	if m.clearedupscales {
		edges = append(edges, deviceinfo.EdgeUpscales)
	}
	if m.clearedvoiceovers {
		edges = append(edges, deviceinfo.EdgeVoiceovers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case deviceinfo.EdgeGenerations:
		return m.clearedgenerations
	case deviceinfo.EdgeUpscales:
		return m.clearedupscales
	case deviceinfo.EdgeVoiceovers:
		return m.clearedvoiceovers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceInfoMutation) ResetEdge(name string) error {
	switch name {
	case deviceinfo.EdgeGenerations:
		m.ResetGenerations()
		return nil
	case deviceinfo.EdgeUpscales:
		m.ResetUpscales()
		return nil
	case deviceinfo.EdgeVoiceovers:
		m.ResetVoiceovers()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo edge %s", name)
}

// DisposableEmailMutation represents an operation that mutates the DisposableEmail nodes in the graph.
type DisposableEmailMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	domain        *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DisposableEmail, error)
	predicates    []predicate.DisposableEmail
}

var _ ent.Mutation = (*DisposableEmailMutation)(nil)

// disposableemailOption allows management of the mutation configuration using functional options.
type disposableemailOption func(*DisposableEmailMutation)

// newDisposableEmailMutation creates new mutation for the DisposableEmail entity.
func newDisposableEmailMutation(c config, op Op, opts ...disposableemailOption) *DisposableEmailMutation {
	m := &DisposableEmailMutation{
		config:        c,
		op:            op,
		typ:           TypeDisposableEmail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDisposableEmailID sets the ID field of the mutation.
func withDisposableEmailID(id uuid.UUID) disposableemailOption {
	return func(m *DisposableEmailMutation) {
		var (
			err   error
			once  sync.Once
			value *DisposableEmail
		)
		m.oldValue = func(ctx context.Context) (*DisposableEmail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DisposableEmail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisposableEmail sets the old DisposableEmail of the mutation.
func withDisposableEmail(node *DisposableEmail) disposableemailOption {
	return func(m *DisposableEmailMutation) {
		m.oldValue = func(context.Context) (*DisposableEmail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DisposableEmailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DisposableEmailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DisposableEmail entities.
func (m *DisposableEmailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DisposableEmailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DisposableEmailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DisposableEmail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDomain sets the "domain" field.
func (m *DisposableEmailMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *DisposableEmailMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the DisposableEmail entity.
// If the DisposableEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DisposableEmailMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *DisposableEmailMutation) ResetDomain() {
	m.domain = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DisposableEmailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DisposableEmailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DisposableEmail entity.
// If the DisposableEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DisposableEmailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DisposableEmailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DisposableEmailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DisposableEmailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DisposableEmail entity.
// If the DisposableEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DisposableEmailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DisposableEmailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the DisposableEmailMutation builder.
func (m *DisposableEmailMutation) Where(ps ...predicate.DisposableEmail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DisposableEmailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DisposableEmailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DisposableEmail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DisposableEmailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DisposableEmailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DisposableEmail).
func (m *DisposableEmailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DisposableEmailMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.domain != nil {
		fields = append(fields, disposableemail.FieldDomain)
	}
	if m.created_at != nil {
		fields = append(fields, disposableemail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, disposableemail.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DisposableEmailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disposableemail.FieldDomain:
		return m.Domain()
	case disposableemail.FieldCreatedAt:
		return m.CreatedAt()
	case disposableemail.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DisposableEmailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disposableemail.FieldDomain:
		return m.OldDomain(ctx)
	case disposableemail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case disposableemail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DisposableEmail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DisposableEmailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disposableemail.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case disposableemail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case disposableemail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DisposableEmail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DisposableEmailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DisposableEmailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DisposableEmailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DisposableEmail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DisposableEmailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DisposableEmailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DisposableEmailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DisposableEmail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DisposableEmailMutation) ResetField(name string) error {
	switch name {
	case disposableemail.FieldDomain:
		m.ResetDomain()
		return nil
	case disposableemail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case disposableemail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DisposableEmail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DisposableEmailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DisposableEmailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DisposableEmailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DisposableEmailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DisposableEmailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DisposableEmailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DisposableEmailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DisposableEmail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DisposableEmailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DisposableEmail edge %s", name)
}

// GenerationMutation represents an operation that mutates the Generation nodes in the graph.
type GenerationMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	width                     *int32
	addwidth                  *int32
	height                    *int32
	addheight                 *int32
	inference_steps           *int32
	addinference_steps        *int32
	guidance_scale            *float32
	addguidance_scale         *float32
	num_outputs               *int32
	addnum_outputs            *int32
	nsfw_count                *int32
	addnsfw_count             *int32
	seed                      *int
	addseed                   *int
	status                    *generation.Status
	failure_reason            *string
	country_code              *string
	init_image_url            *string
	prompt_strength           *float32
	addprompt_strength        *float32
	was_auto_submitted        *bool
	stripe_product_id         *string
	source_type               *enttypes.SourceType
	started_at                *time.Time
	completed_at              *time.Time
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	device_info               *uuid.UUID
	cleareddevice_info        bool
	scheduler                 *uuid.UUID
	clearedscheduler          bool
	prompt                    *uuid.UUID
	clearedprompt             bool
	negative_prompt           *uuid.UUID
	clearednegative_prompt    bool
	generation_model          *uuid.UUID
	clearedgeneration_model   bool
	user                      *uuid.UUID
	cleareduser               bool
	api_tokens                *uuid.UUID
	clearedapi_tokens         bool
	generation_outputs        map[uuid.UUID]struct{}
	removedgeneration_outputs map[uuid.UUID]struct{}
	clearedgeneration_outputs bool
	done                      bool
	oldValue                  func(context.Context) (*Generation, error)
	predicates                []predicate.Generation
}

var _ ent.Mutation = (*GenerationMutation)(nil)

// generationOption allows management of the mutation configuration using functional options.
type generationOption func(*GenerationMutation)

// newGenerationMutation creates new mutation for the Generation entity.
func newGenerationMutation(c config, op Op, opts ...generationOption) *GenerationMutation {
	m := &GenerationMutation{
		config:        c,
		op:            op,
		typ:           TypeGeneration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenerationID sets the ID field of the mutation.
func withGenerationID(id uuid.UUID) generationOption {
	return func(m *GenerationMutation) {
		var (
			err   error
			once  sync.Once
			value *Generation
		)
		m.oldValue = func(ctx context.Context) (*Generation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Generation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGeneration sets the old Generation of the mutation.
func withGeneration(node *Generation) generationOption {
	return func(m *GenerationMutation) {
		m.oldValue = func(context.Context) (*Generation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenerationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenerationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Generation entities.
func (m *GenerationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenerationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenerationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Generation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWidth sets the "width" field.
func (m *GenerationMutation) SetWidth(i int32) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *GenerationMutation) Width() (r int32, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldWidth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *GenerationMutation) AddWidth(i int32) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *GenerationMutation) AddedWidth() (r int32, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *GenerationMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *GenerationMutation) SetHeight(i int32) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *GenerationMutation) Height() (r int32, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldHeight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *GenerationMutation) AddHeight(i int32) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *GenerationMutation) AddedHeight() (r int32, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *GenerationMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetInferenceSteps sets the "inference_steps" field.
func (m *GenerationMutation) SetInferenceSteps(i int32) {
	m.inference_steps = &i
	m.addinference_steps = nil
}

// InferenceSteps returns the value of the "inference_steps" field in the mutation.
func (m *GenerationMutation) InferenceSteps() (r int32, exists bool) {
	v := m.inference_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldInferenceSteps returns the old "inference_steps" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldInferenceSteps(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInferenceSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInferenceSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInferenceSteps: %w", err)
	}
	return oldValue.InferenceSteps, nil
}

// AddInferenceSteps adds i to the "inference_steps" field.
func (m *GenerationMutation) AddInferenceSteps(i int32) {
	if m.addinference_steps != nil {
		*m.addinference_steps += i
	} else {
		m.addinference_steps = &i
	}
}

// AddedInferenceSteps returns the value that was added to the "inference_steps" field in this mutation.
func (m *GenerationMutation) AddedInferenceSteps() (r int32, exists bool) {
	v := m.addinference_steps
	if v == nil {
		return
	}
	return *v, true
}

// ResetInferenceSteps resets all changes to the "inference_steps" field.
func (m *GenerationMutation) ResetInferenceSteps() {
	m.inference_steps = nil
	m.addinference_steps = nil
}

// SetGuidanceScale sets the "guidance_scale" field.
func (m *GenerationMutation) SetGuidanceScale(f float32) {
	m.guidance_scale = &f
	m.addguidance_scale = nil
}

// GuidanceScale returns the value of the "guidance_scale" field in the mutation.
func (m *GenerationMutation) GuidanceScale() (r float32, exists bool) {
	v := m.guidance_scale
	if v == nil {
		return
	}
	return *v, true
}

// OldGuidanceScale returns the old "guidance_scale" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldGuidanceScale(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuidanceScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuidanceScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuidanceScale: %w", err)
	}
	return oldValue.GuidanceScale, nil
}

// AddGuidanceScale adds f to the "guidance_scale" field.
func (m *GenerationMutation) AddGuidanceScale(f float32) {
	if m.addguidance_scale != nil {
		*m.addguidance_scale += f
	} else {
		m.addguidance_scale = &f
	}
}

// AddedGuidanceScale returns the value that was added to the "guidance_scale" field in this mutation.
func (m *GenerationMutation) AddedGuidanceScale() (r float32, exists bool) {
	v := m.addguidance_scale
	if v == nil {
		return
	}
	return *v, true
}

// ResetGuidanceScale resets all changes to the "guidance_scale" field.
func (m *GenerationMutation) ResetGuidanceScale() {
	m.guidance_scale = nil
	m.addguidance_scale = nil
}

// SetNumOutputs sets the "num_outputs" field.
func (m *GenerationMutation) SetNumOutputs(i int32) {
	m.num_outputs = &i
	m.addnum_outputs = nil
}

// NumOutputs returns the value of the "num_outputs" field in the mutation.
func (m *GenerationMutation) NumOutputs() (r int32, exists bool) {
	v := m.num_outputs
	if v == nil {
		return
	}
	return *v, true
}

// OldNumOutputs returns the old "num_outputs" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldNumOutputs(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumOutputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumOutputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumOutputs: %w", err)
	}
	return oldValue.NumOutputs, nil
}

// AddNumOutputs adds i to the "num_outputs" field.
func (m *GenerationMutation) AddNumOutputs(i int32) {
	if m.addnum_outputs != nil {
		*m.addnum_outputs += i
	} else {
		m.addnum_outputs = &i
	}
}

// AddedNumOutputs returns the value that was added to the "num_outputs" field in this mutation.
func (m *GenerationMutation) AddedNumOutputs() (r int32, exists bool) {
	v := m.addnum_outputs
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumOutputs resets all changes to the "num_outputs" field.
func (m *GenerationMutation) ResetNumOutputs() {
	m.num_outputs = nil
	m.addnum_outputs = nil
}

// SetNsfwCount sets the "nsfw_count" field.
func (m *GenerationMutation) SetNsfwCount(i int32) {
	m.nsfw_count = &i
	m.addnsfw_count = nil
}

// NsfwCount returns the value of the "nsfw_count" field in the mutation.
func (m *GenerationMutation) NsfwCount() (r int32, exists bool) {
	v := m.nsfw_count
	if v == nil {
		return
	}
	return *v, true
}

// OldNsfwCount returns the old "nsfw_count" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldNsfwCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNsfwCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNsfwCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNsfwCount: %w", err)
	}
	return oldValue.NsfwCount, nil
}

// AddNsfwCount adds i to the "nsfw_count" field.
func (m *GenerationMutation) AddNsfwCount(i int32) {
	if m.addnsfw_count != nil {
		*m.addnsfw_count += i
	} else {
		m.addnsfw_count = &i
	}
}

// AddedNsfwCount returns the value that was added to the "nsfw_count" field in this mutation.
func (m *GenerationMutation) AddedNsfwCount() (r int32, exists bool) {
	v := m.addnsfw_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetNsfwCount resets all changes to the "nsfw_count" field.
func (m *GenerationMutation) ResetNsfwCount() {
	m.nsfw_count = nil
	m.addnsfw_count = nil
}

// SetSeed sets the "seed" field.
func (m *GenerationMutation) SetSeed(i int) {
	m.seed = &i
	m.addseed = nil
}

// Seed returns the value of the "seed" field in the mutation.
func (m *GenerationMutation) Seed() (r int, exists bool) {
	v := m.seed
	if v == nil {
		return
	}
	return *v, true
}

// OldSeed returns the old "seed" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldSeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeed: %w", err)
	}
	return oldValue.Seed, nil
}

// AddSeed adds i to the "seed" field.
func (m *GenerationMutation) AddSeed(i int) {
	if m.addseed != nil {
		*m.addseed += i
	} else {
		m.addseed = &i
	}
}

// AddedSeed returns the value that was added to the "seed" field in this mutation.
func (m *GenerationMutation) AddedSeed() (r int, exists bool) {
	v := m.addseed
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeed resets all changes to the "seed" field.
func (m *GenerationMutation) ResetSeed() {
	m.seed = nil
	m.addseed = nil
}

// SetStatus sets the "status" field.
func (m *GenerationMutation) SetStatus(ge generation.Status) {
	m.status = &ge
}

// Status returns the value of the "status" field in the mutation.
func (m *GenerationMutation) Status() (r generation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldStatus(ctx context.Context) (v generation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GenerationMutation) ResetStatus() {
	m.status = nil
}

// SetFailureReason sets the "failure_reason" field.
func (m *GenerationMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *GenerationMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldFailureReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *GenerationMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[generation.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *GenerationMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[generation.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *GenerationMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, generation.FieldFailureReason)
}

// SetCountryCode sets the "country_code" field.
func (m *GenerationMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *GenerationMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldCountryCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ClearCountryCode clears the value of the "country_code" field.
func (m *GenerationMutation) ClearCountryCode() {
	m.country_code = nil
	m.clearedFields[generation.FieldCountryCode] = struct{}{}
}

// CountryCodeCleared returns if the "country_code" field was cleared in this mutation.
func (m *GenerationMutation) CountryCodeCleared() bool {
	_, ok := m.clearedFields[generation.FieldCountryCode]
	return ok
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *GenerationMutation) ResetCountryCode() {
	m.country_code = nil
	delete(m.clearedFields, generation.FieldCountryCode)
}

// SetInitImageURL sets the "init_image_url" field.
func (m *GenerationMutation) SetInitImageURL(s string) {
	m.init_image_url = &s
}

// InitImageURL returns the value of the "init_image_url" field in the mutation.
func (m *GenerationMutation) InitImageURL() (r string, exists bool) {
	v := m.init_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInitImageURL returns the old "init_image_url" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldInitImageURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitImageURL: %w", err)
	}
	return oldValue.InitImageURL, nil
}

// ClearInitImageURL clears the value of the "init_image_url" field.
func (m *GenerationMutation) ClearInitImageURL() {
	m.init_image_url = nil
	m.clearedFields[generation.FieldInitImageURL] = struct{}{}
}

// InitImageURLCleared returns if the "init_image_url" field was cleared in this mutation.
func (m *GenerationMutation) InitImageURLCleared() bool {
	_, ok := m.clearedFields[generation.FieldInitImageURL]
	return ok
}

// ResetInitImageURL resets all changes to the "init_image_url" field.
func (m *GenerationMutation) ResetInitImageURL() {
	m.init_image_url = nil
	delete(m.clearedFields, generation.FieldInitImageURL)
}

// SetPromptStrength sets the "prompt_strength" field.
func (m *GenerationMutation) SetPromptStrength(f float32) {
	m.prompt_strength = &f
	m.addprompt_strength = nil
}

// PromptStrength returns the value of the "prompt_strength" field in the mutation.
func (m *GenerationMutation) PromptStrength() (r float32, exists bool) {
	v := m.prompt_strength
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptStrength returns the old "prompt_strength" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldPromptStrength(ctx context.Context) (v *float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptStrength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptStrength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptStrength: %w", err)
	}
	return oldValue.PromptStrength, nil
}

// AddPromptStrength adds f to the "prompt_strength" field.
func (m *GenerationMutation) AddPromptStrength(f float32) {
	if m.addprompt_strength != nil {
		*m.addprompt_strength += f
	} else {
		m.addprompt_strength = &f
	}
}

// AddedPromptStrength returns the value that was added to the "prompt_strength" field in this mutation.
func (m *GenerationMutation) AddedPromptStrength() (r float32, exists bool) {
	v := m.addprompt_strength
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptStrength clears the value of the "prompt_strength" field.
func (m *GenerationMutation) ClearPromptStrength() {
	m.prompt_strength = nil
	m.addprompt_strength = nil
	m.clearedFields[generation.FieldPromptStrength] = struct{}{}
}

// PromptStrengthCleared returns if the "prompt_strength" field was cleared in this mutation.
func (m *GenerationMutation) PromptStrengthCleared() bool {
	_, ok := m.clearedFields[generation.FieldPromptStrength]
	return ok
}

// ResetPromptStrength resets all changes to the "prompt_strength" field.
func (m *GenerationMutation) ResetPromptStrength() {
	m.prompt_strength = nil
	m.addprompt_strength = nil
	delete(m.clearedFields, generation.FieldPromptStrength)
}

// SetWasAutoSubmitted sets the "was_auto_submitted" field.
func (m *GenerationMutation) SetWasAutoSubmitted(b bool) {
	m.was_auto_submitted = &b
}

// WasAutoSubmitted returns the value of the "was_auto_submitted" field in the mutation.
func (m *GenerationMutation) WasAutoSubmitted() (r bool, exists bool) {
	v := m.was_auto_submitted
	if v == nil {
		return
	}
	return *v, true
}

// OldWasAutoSubmitted returns the old "was_auto_submitted" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldWasAutoSubmitted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWasAutoSubmitted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWasAutoSubmitted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWasAutoSubmitted: %w", err)
	}
	return oldValue.WasAutoSubmitted, nil
}

// ResetWasAutoSubmitted resets all changes to the "was_auto_submitted" field.
func (m *GenerationMutation) ResetWasAutoSubmitted() {
	m.was_auto_submitted = nil
}

// SetStripeProductID sets the "stripe_product_id" field.
func (m *GenerationMutation) SetStripeProductID(s string) {
	m.stripe_product_id = &s
}

// StripeProductID returns the value of the "stripe_product_id" field in the mutation.
func (m *GenerationMutation) StripeProductID() (r string, exists bool) {
	v := m.stripe_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeProductID returns the old "stripe_product_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldStripeProductID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeProductID: %w", err)
	}
	return oldValue.StripeProductID, nil
}

// ClearStripeProductID clears the value of the "stripe_product_id" field.
func (m *GenerationMutation) ClearStripeProductID() {
	m.stripe_product_id = nil
	m.clearedFields[generation.FieldStripeProductID] = struct{}{}
}

// StripeProductIDCleared returns if the "stripe_product_id" field was cleared in this mutation.
func (m *GenerationMutation) StripeProductIDCleared() bool {
	_, ok := m.clearedFields[generation.FieldStripeProductID]
	return ok
}

// ResetStripeProductID resets all changes to the "stripe_product_id" field.
func (m *GenerationMutation) ResetStripeProductID() {
	m.stripe_product_id = nil
	delete(m.clearedFields, generation.FieldStripeProductID)
}

// SetSourceType sets the "source_type" field.
func (m *GenerationMutation) SetSourceType(et enttypes.SourceType) {
	m.source_type = &et
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *GenerationMutation) SourceType() (r enttypes.SourceType, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldSourceType(ctx context.Context) (v enttypes.SourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *GenerationMutation) ResetSourceType() {
	m.source_type = nil
}

// SetPromptID sets the "prompt_id" field.
func (m *GenerationMutation) SetPromptID(u uuid.UUID) {
	m.prompt = &u
}

// PromptID returns the value of the "prompt_id" field in the mutation.
func (m *GenerationMutation) PromptID() (r uuid.UUID, exists bool) {
	v := m.prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptID returns the old "prompt_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldPromptID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptID: %w", err)
	}
	return oldValue.PromptID, nil
}

// ClearPromptID clears the value of the "prompt_id" field.
func (m *GenerationMutation) ClearPromptID() {
	m.prompt = nil
	m.clearedFields[generation.FieldPromptID] = struct{}{}
}

// PromptIDCleared returns if the "prompt_id" field was cleared in this mutation.
func (m *GenerationMutation) PromptIDCleared() bool {
	_, ok := m.clearedFields[generation.FieldPromptID]
	return ok
}

// ResetPromptID resets all changes to the "prompt_id" field.
func (m *GenerationMutation) ResetPromptID() {
	m.prompt = nil
	delete(m.clearedFields, generation.FieldPromptID)
}

// SetNegativePromptID sets the "negative_prompt_id" field.
func (m *GenerationMutation) SetNegativePromptID(u uuid.UUID) {
	m.negative_prompt = &u
}

// NegativePromptID returns the value of the "negative_prompt_id" field in the mutation.
func (m *GenerationMutation) NegativePromptID() (r uuid.UUID, exists bool) {
	v := m.negative_prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldNegativePromptID returns the old "negative_prompt_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldNegativePromptID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNegativePromptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNegativePromptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNegativePromptID: %w", err)
	}
	return oldValue.NegativePromptID, nil
}

// ClearNegativePromptID clears the value of the "negative_prompt_id" field.
func (m *GenerationMutation) ClearNegativePromptID() {
	m.negative_prompt = nil
	m.clearedFields[generation.FieldNegativePromptID] = struct{}{}
}

// NegativePromptIDCleared returns if the "negative_prompt_id" field was cleared in this mutation.
func (m *GenerationMutation) NegativePromptIDCleared() bool {
	_, ok := m.clearedFields[generation.FieldNegativePromptID]
	return ok
}

// ResetNegativePromptID resets all changes to the "negative_prompt_id" field.
func (m *GenerationMutation) ResetNegativePromptID() {
	m.negative_prompt = nil
	delete(m.clearedFields, generation.FieldNegativePromptID)
}

// SetModelID sets the "model_id" field.
func (m *GenerationMutation) SetModelID(u uuid.UUID) {
	m.generation_model = &u
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *GenerationMutation) ModelID() (r uuid.UUID, exists bool) {
	v := m.generation_model
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldModelID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *GenerationMutation) ResetModelID() {
	m.generation_model = nil
}

// SetSchedulerID sets the "scheduler_id" field.
func (m *GenerationMutation) SetSchedulerID(u uuid.UUID) {
	m.scheduler = &u
}

// SchedulerID returns the value of the "scheduler_id" field in the mutation.
func (m *GenerationMutation) SchedulerID() (r uuid.UUID, exists bool) {
	v := m.scheduler
	if v == nil {
		return
	}
	return *v, true
}

// OldSchedulerID returns the old "scheduler_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldSchedulerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchedulerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchedulerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchedulerID: %w", err)
	}
	return oldValue.SchedulerID, nil
}

// ResetSchedulerID resets all changes to the "scheduler_id" field.
func (m *GenerationMutation) ResetSchedulerID() {
	m.scheduler = nil
}

// SetUserID sets the "user_id" field.
func (m *GenerationMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GenerationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GenerationMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceInfoID sets the "device_info_id" field.
func (m *GenerationMutation) SetDeviceInfoID(u uuid.UUID) {
	m.device_info = &u
}

// DeviceInfoID returns the value of the "device_info_id" field in the mutation.
func (m *GenerationMutation) DeviceInfoID() (r uuid.UUID, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfoID returns the old "device_info_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldDeviceInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfoID: %w", err)
	}
	return oldValue.DeviceInfoID, nil
}

// ResetDeviceInfoID resets all changes to the "device_info_id" field.
func (m *GenerationMutation) ResetDeviceInfoID() {
	m.device_info = nil
}

// SetAPITokenID sets the "api_token_id" field.
func (m *GenerationMutation) SetAPITokenID(u uuid.UUID) {
	m.api_tokens = &u
}

// APITokenID returns the value of the "api_token_id" field in the mutation.
func (m *GenerationMutation) APITokenID() (r uuid.UUID, exists bool) {
	v := m.api_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldAPITokenID returns the old "api_token_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldAPITokenID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPITokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPITokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPITokenID: %w", err)
	}
	return oldValue.APITokenID, nil
}

// ClearAPITokenID clears the value of the "api_token_id" field.
func (m *GenerationMutation) ClearAPITokenID() {
	m.api_tokens = nil
	m.clearedFields[generation.FieldAPITokenID] = struct{}{}
}

// APITokenIDCleared returns if the "api_token_id" field was cleared in this mutation.
func (m *GenerationMutation) APITokenIDCleared() bool {
	_, ok := m.clearedFields[generation.FieldAPITokenID]
	return ok
}

// ResetAPITokenID resets all changes to the "api_token_id" field.
func (m *GenerationMutation) ResetAPITokenID() {
	m.api_tokens = nil
	delete(m.clearedFields, generation.FieldAPITokenID)
}

// SetStartedAt sets the "started_at" field.
func (m *GenerationMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *GenerationMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *GenerationMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[generation.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *GenerationMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[generation.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *GenerationMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, generation.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *GenerationMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *GenerationMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *GenerationMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[generation.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *GenerationMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[generation.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *GenerationMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, generation.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *GenerationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GenerationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GenerationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GenerationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GenerationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GenerationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearDeviceInfo clears the "device_info" edge to the DeviceInfo entity.
func (m *GenerationMutation) ClearDeviceInfo() {
	m.cleareddevice_info = true
}

// DeviceInfoCleared reports if the "device_info" edge to the DeviceInfo entity was cleared.
func (m *GenerationMutation) DeviceInfoCleared() bool {
	return m.cleareddevice_info
}

// DeviceInfoIDs returns the "device_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceInfoID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) DeviceInfoIDs() (ids []uuid.UUID) {
	if id := m.device_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeviceInfo resets all changes to the "device_info" edge.
func (m *GenerationMutation) ResetDeviceInfo() {
	m.device_info = nil
	m.cleareddevice_info = false
}

// ClearScheduler clears the "scheduler" edge to the Scheduler entity.
func (m *GenerationMutation) ClearScheduler() {
	m.clearedscheduler = true
}

// SchedulerCleared reports if the "scheduler" edge to the Scheduler entity was cleared.
func (m *GenerationMutation) SchedulerCleared() bool {
	return m.clearedscheduler
}

// SchedulerIDs returns the "scheduler" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchedulerID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) SchedulerIDs() (ids []uuid.UUID) {
	if id := m.scheduler; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScheduler resets all changes to the "scheduler" edge.
func (m *GenerationMutation) ResetScheduler() {
	m.scheduler = nil
	m.clearedscheduler = false
}

// ClearPrompt clears the "prompt" edge to the Prompt entity.
func (m *GenerationMutation) ClearPrompt() {
	m.clearedprompt = true
}

// PromptCleared reports if the "prompt" edge to the Prompt entity was cleared.
func (m *GenerationMutation) PromptCleared() bool {
	return m.PromptIDCleared() || m.clearedprompt
}

// PromptIDs returns the "prompt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PromptID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) PromptIDs() (ids []uuid.UUID) {
	if id := m.prompt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrompt resets all changes to the "prompt" edge.
func (m *GenerationMutation) ResetPrompt() {
	m.prompt = nil
	m.clearedprompt = false
}

// ClearNegativePrompt clears the "negative_prompt" edge to the NegativePrompt entity.
func (m *GenerationMutation) ClearNegativePrompt() {
	m.clearednegative_prompt = true
}

// NegativePromptCleared reports if the "negative_prompt" edge to the NegativePrompt entity was cleared.
func (m *GenerationMutation) NegativePromptCleared() bool {
	return m.NegativePromptIDCleared() || m.clearednegative_prompt
}

// NegativePromptIDs returns the "negative_prompt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NegativePromptID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) NegativePromptIDs() (ids []uuid.UUID) {
	if id := m.negative_prompt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNegativePrompt resets all changes to the "negative_prompt" edge.
func (m *GenerationMutation) ResetNegativePrompt() {
	m.negative_prompt = nil
	m.clearednegative_prompt = false
}

// SetGenerationModelID sets the "generation_model" edge to the GenerationModel entity by id.
func (m *GenerationMutation) SetGenerationModelID(id uuid.UUID) {
	m.generation_model = &id
}

// ClearGenerationModel clears the "generation_model" edge to the GenerationModel entity.
func (m *GenerationMutation) ClearGenerationModel() {
	m.clearedgeneration_model = true
}

// GenerationModelCleared reports if the "generation_model" edge to the GenerationModel entity was cleared.
func (m *GenerationMutation) GenerationModelCleared() bool {
	return m.clearedgeneration_model
}

// GenerationModelID returns the "generation_model" edge ID in the mutation.
func (m *GenerationMutation) GenerationModelID() (id uuid.UUID, exists bool) {
	if m.generation_model != nil {
		return *m.generation_model, true
	}
	return
}

// GenerationModelIDs returns the "generation_model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenerationModelID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) GenerationModelIDs() (ids []uuid.UUID) {
	if id := m.generation_model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenerationModel resets all changes to the "generation_model" edge.
func (m *GenerationMutation) ResetGenerationModel() {
	m.generation_model = nil
	m.clearedgeneration_model = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *GenerationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *GenerationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *GenerationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAPITokensID sets the "api_tokens" edge to the ApiToken entity by id.
func (m *GenerationMutation) SetAPITokensID(id uuid.UUID) {
	m.api_tokens = &id
}

// ClearAPITokens clears the "api_tokens" edge to the ApiToken entity.
func (m *GenerationMutation) ClearAPITokens() {
	m.clearedapi_tokens = true
}

// APITokensCleared reports if the "api_tokens" edge to the ApiToken entity was cleared.
func (m *GenerationMutation) APITokensCleared() bool {
	return m.APITokenIDCleared() || m.clearedapi_tokens
}

// APITokensID returns the "api_tokens" edge ID in the mutation.
func (m *GenerationMutation) APITokensID() (id uuid.UUID, exists bool) {
	if m.api_tokens != nil {
		return *m.api_tokens, true
	}
	return
}

// APITokensIDs returns the "api_tokens" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// APITokensID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) APITokensIDs() (ids []uuid.UUID) {
	if id := m.api_tokens; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAPITokens resets all changes to the "api_tokens" edge.
func (m *GenerationMutation) ResetAPITokens() {
	m.api_tokens = nil
	m.clearedapi_tokens = false
}

// AddGenerationOutputIDs adds the "generation_outputs" edge to the GenerationOutput entity by ids.
func (m *GenerationMutation) AddGenerationOutputIDs(ids ...uuid.UUID) {
	if m.generation_outputs == nil {
		m.generation_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generation_outputs[ids[i]] = struct{}{}
	}
}

// ClearGenerationOutputs clears the "generation_outputs" edge to the GenerationOutput entity.
func (m *GenerationMutation) ClearGenerationOutputs() {
	m.clearedgeneration_outputs = true
}

// GenerationOutputsCleared reports if the "generation_outputs" edge to the GenerationOutput entity was cleared.
func (m *GenerationMutation) GenerationOutputsCleared() bool {
	return m.clearedgeneration_outputs
}

// RemoveGenerationOutputIDs removes the "generation_outputs" edge to the GenerationOutput entity by IDs.
func (m *GenerationMutation) RemoveGenerationOutputIDs(ids ...uuid.UUID) {
	if m.removedgeneration_outputs == nil {
		m.removedgeneration_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generation_outputs, ids[i])
		m.removedgeneration_outputs[ids[i]] = struct{}{}
	}
}

// RemovedGenerationOutputs returns the removed IDs of the "generation_outputs" edge to the GenerationOutput entity.
func (m *GenerationMutation) RemovedGenerationOutputsIDs() (ids []uuid.UUID) {
	for id := range m.removedgeneration_outputs {
		ids = append(ids, id)
	}
	return
}

// GenerationOutputsIDs returns the "generation_outputs" edge IDs in the mutation.
func (m *GenerationMutation) GenerationOutputsIDs() (ids []uuid.UUID) {
	for id := range m.generation_outputs {
		ids = append(ids, id)
	}
	return
}

// ResetGenerationOutputs resets all changes to the "generation_outputs" edge.
func (m *GenerationMutation) ResetGenerationOutputs() {
	m.generation_outputs = nil
	m.clearedgeneration_outputs = false
	m.removedgeneration_outputs = nil
}

// Where appends a list predicates to the GenerationMutation builder.
func (m *GenerationMutation) Where(ps ...predicate.Generation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GenerationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GenerationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Generation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GenerationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GenerationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Generation).
func (m *GenerationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenerationMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.width != nil {
		fields = append(fields, generation.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, generation.FieldHeight)
	}
	if m.inference_steps != nil {
		fields = append(fields, generation.FieldInferenceSteps)
	}
	if m.guidance_scale != nil {
		fields = append(fields, generation.FieldGuidanceScale)
	}
	if m.num_outputs != nil {
		fields = append(fields, generation.FieldNumOutputs)
	}
	if m.nsfw_count != nil {
		fields = append(fields, generation.FieldNsfwCount)
	}
	if m.seed != nil {
		fields = append(fields, generation.FieldSeed)
	}
	if m.status != nil {
		fields = append(fields, generation.FieldStatus)
	}
	if m.failure_reason != nil {
		fields = append(fields, generation.FieldFailureReason)
	}
	if m.country_code != nil {
		fields = append(fields, generation.FieldCountryCode)
	}
	if m.init_image_url != nil {
		fields = append(fields, generation.FieldInitImageURL)
	}
	if m.prompt_strength != nil {
		fields = append(fields, generation.FieldPromptStrength)
	}
	if m.was_auto_submitted != nil {
		fields = append(fields, generation.FieldWasAutoSubmitted)
	}
	if m.stripe_product_id != nil {
		fields = append(fields, generation.FieldStripeProductID)
	}
	if m.source_type != nil {
		fields = append(fields, generation.FieldSourceType)
	}
	if m.prompt != nil {
		fields = append(fields, generation.FieldPromptID)
	}
	if m.negative_prompt != nil {
		fields = append(fields, generation.FieldNegativePromptID)
	}
	if m.generation_model != nil {
		fields = append(fields, generation.FieldModelID)
	}
	if m.scheduler != nil {
		fields = append(fields, generation.FieldSchedulerID)
	}
	if m.user != nil {
		fields = append(fields, generation.FieldUserID)
	}
	if m.device_info != nil {
		fields = append(fields, generation.FieldDeviceInfoID)
	}
	if m.api_tokens != nil {
		fields = append(fields, generation.FieldAPITokenID)
	}
	if m.started_at != nil {
		fields = append(fields, generation.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, generation.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, generation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenerationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generation.FieldWidth:
		return m.Width()
	case generation.FieldHeight:
		return m.Height()
	case generation.FieldInferenceSteps:
		return m.InferenceSteps()
	case generation.FieldGuidanceScale:
		return m.GuidanceScale()
	case generation.FieldNumOutputs:
		return m.NumOutputs()
	case generation.FieldNsfwCount:
		return m.NsfwCount()
	case generation.FieldSeed:
		return m.Seed()
	case generation.FieldStatus:
		return m.Status()
	case generation.FieldFailureReason:
		return m.FailureReason()
	case generation.FieldCountryCode:
		return m.CountryCode()
	case generation.FieldInitImageURL:
		return m.InitImageURL()
	case generation.FieldPromptStrength:
		return m.PromptStrength()
	case generation.FieldWasAutoSubmitted:
		return m.WasAutoSubmitted()
	case generation.FieldStripeProductID:
		return m.StripeProductID()
	case generation.FieldSourceType:
		return m.SourceType()
	case generation.FieldPromptID:
		return m.PromptID()
	case generation.FieldNegativePromptID:
		return m.NegativePromptID()
	case generation.FieldModelID:
		return m.ModelID()
	case generation.FieldSchedulerID:
		return m.SchedulerID()
	case generation.FieldUserID:
		return m.UserID()
	case generation.FieldDeviceInfoID:
		return m.DeviceInfoID()
	case generation.FieldAPITokenID:
		return m.APITokenID()
	case generation.FieldStartedAt:
		return m.StartedAt()
	case generation.FieldCompletedAt:
		return m.CompletedAt()
	case generation.FieldCreatedAt:
		return m.CreatedAt()
	case generation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenerationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generation.FieldWidth:
		return m.OldWidth(ctx)
	case generation.FieldHeight:
		return m.OldHeight(ctx)
	case generation.FieldInferenceSteps:
		return m.OldInferenceSteps(ctx)
	case generation.FieldGuidanceScale:
		return m.OldGuidanceScale(ctx)
	case generation.FieldNumOutputs:
		return m.OldNumOutputs(ctx)
	case generation.FieldNsfwCount:
		return m.OldNsfwCount(ctx)
	case generation.FieldSeed:
		return m.OldSeed(ctx)
	case generation.FieldStatus:
		return m.OldStatus(ctx)
	case generation.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case generation.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case generation.FieldInitImageURL:
		return m.OldInitImageURL(ctx)
	case generation.FieldPromptStrength:
		return m.OldPromptStrength(ctx)
	case generation.FieldWasAutoSubmitted:
		return m.OldWasAutoSubmitted(ctx)
	case generation.FieldStripeProductID:
		return m.OldStripeProductID(ctx)
	case generation.FieldSourceType:
		return m.OldSourceType(ctx)
	case generation.FieldPromptID:
		return m.OldPromptID(ctx)
	case generation.FieldNegativePromptID:
		return m.OldNegativePromptID(ctx)
	case generation.FieldModelID:
		return m.OldModelID(ctx)
	case generation.FieldSchedulerID:
		return m.OldSchedulerID(ctx)
	case generation.FieldUserID:
		return m.OldUserID(ctx)
	case generation.FieldDeviceInfoID:
		return m.OldDeviceInfoID(ctx)
	case generation.FieldAPITokenID:
		return m.OldAPITokenID(ctx)
	case generation.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case generation.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case generation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Generation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generation.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case generation.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case generation.FieldInferenceSteps:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInferenceSteps(v)
		return nil
	case generation.FieldGuidanceScale:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuidanceScale(v)
		return nil
	case generation.FieldNumOutputs:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumOutputs(v)
		return nil
	case generation.FieldNsfwCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNsfwCount(v)
		return nil
	case generation.FieldSeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeed(v)
		return nil
	case generation.FieldStatus:
		v, ok := value.(generation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case generation.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case generation.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case generation.FieldInitImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitImageURL(v)
		return nil
	case generation.FieldPromptStrength:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptStrength(v)
		return nil
	case generation.FieldWasAutoSubmitted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWasAutoSubmitted(v)
		return nil
	case generation.FieldStripeProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeProductID(v)
		return nil
	case generation.FieldSourceType:
		v, ok := value.(enttypes.SourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case generation.FieldPromptID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptID(v)
		return nil
	case generation.FieldNegativePromptID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNegativePromptID(v)
		return nil
	case generation.FieldModelID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case generation.FieldSchedulerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchedulerID(v)
		return nil
	case generation.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case generation.FieldDeviceInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfoID(v)
		return nil
	case generation.FieldAPITokenID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPITokenID(v)
		return nil
	case generation.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case generation.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case generation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Generation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenerationMutation) AddedFields() []string {
	var fields []string
	if m.addwidth != nil {
		fields = append(fields, generation.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, generation.FieldHeight)
	}
	if m.addinference_steps != nil {
		fields = append(fields, generation.FieldInferenceSteps)
	}
	if m.addguidance_scale != nil {
		fields = append(fields, generation.FieldGuidanceScale)
	}
	if m.addnum_outputs != nil {
		fields = append(fields, generation.FieldNumOutputs)
	}
	if m.addnsfw_count != nil {
		fields = append(fields, generation.FieldNsfwCount)
	}
	if m.addseed != nil {
		fields = append(fields, generation.FieldSeed)
	}
	if m.addprompt_strength != nil {
		fields = append(fields, generation.FieldPromptStrength)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenerationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case generation.FieldWidth:
		return m.AddedWidth()
	case generation.FieldHeight:
		return m.AddedHeight()
	case generation.FieldInferenceSteps:
		return m.AddedInferenceSteps()
	case generation.FieldGuidanceScale:
		return m.AddedGuidanceScale()
	case generation.FieldNumOutputs:
		return m.AddedNumOutputs()
	case generation.FieldNsfwCount:
		return m.AddedNsfwCount()
	case generation.FieldSeed:
		return m.AddedSeed()
	case generation.FieldPromptStrength:
		return m.AddedPromptStrength()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case generation.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case generation.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case generation.FieldInferenceSteps:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInferenceSteps(v)
		return nil
	case generation.FieldGuidanceScale:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGuidanceScale(v)
		return nil
	case generation.FieldNumOutputs:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumOutputs(v)
		return nil
	case generation.FieldNsfwCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNsfwCount(v)
		return nil
	case generation.FieldSeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeed(v)
		return nil
	case generation.FieldPromptStrength:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptStrength(v)
		return nil
	}
	return fmt.Errorf("unknown Generation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenerationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(generation.FieldFailureReason) {
		fields = append(fields, generation.FieldFailureReason)
	}
	if m.FieldCleared(generation.FieldCountryCode) {
		fields = append(fields, generation.FieldCountryCode)
	}
	if m.FieldCleared(generation.FieldInitImageURL) {
		fields = append(fields, generation.FieldInitImageURL)
	}
	if m.FieldCleared(generation.FieldPromptStrength) {
		fields = append(fields, generation.FieldPromptStrength)
	}
	if m.FieldCleared(generation.FieldStripeProductID) {
		fields = append(fields, generation.FieldStripeProductID)
	}
	if m.FieldCleared(generation.FieldPromptID) {
		fields = append(fields, generation.FieldPromptID)
	}
	if m.FieldCleared(generation.FieldNegativePromptID) {
		fields = append(fields, generation.FieldNegativePromptID)
	}
	if m.FieldCleared(generation.FieldAPITokenID) {
		fields = append(fields, generation.FieldAPITokenID)
	}
	if m.FieldCleared(generation.FieldStartedAt) {
		fields = append(fields, generation.FieldStartedAt)
	}
	if m.FieldCleared(generation.FieldCompletedAt) {
		fields = append(fields, generation.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenerationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenerationMutation) ClearField(name string) error {
	switch name {
	case generation.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	case generation.FieldCountryCode:
		m.ClearCountryCode()
		return nil
	case generation.FieldInitImageURL:
		m.ClearInitImageURL()
		return nil
	case generation.FieldPromptStrength:
		m.ClearPromptStrength()
		return nil
	case generation.FieldStripeProductID:
		m.ClearStripeProductID()
		return nil
	case generation.FieldPromptID:
		m.ClearPromptID()
		return nil
	case generation.FieldNegativePromptID:
		m.ClearNegativePromptID()
		return nil
	case generation.FieldAPITokenID:
		m.ClearAPITokenID()
		return nil
	case generation.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case generation.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Generation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenerationMutation) ResetField(name string) error {
	switch name {
	case generation.FieldWidth:
		m.ResetWidth()
		return nil
	case generation.FieldHeight:
		m.ResetHeight()
		return nil
	case generation.FieldInferenceSteps:
		m.ResetInferenceSteps()
		return nil
	case generation.FieldGuidanceScale:
		m.ResetGuidanceScale()
		return nil
	case generation.FieldNumOutputs:
		m.ResetNumOutputs()
		return nil
	case generation.FieldNsfwCount:
		m.ResetNsfwCount()
		return nil
	case generation.FieldSeed:
		m.ResetSeed()
		return nil
	case generation.FieldStatus:
		m.ResetStatus()
		return nil
	case generation.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case generation.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case generation.FieldInitImageURL:
		m.ResetInitImageURL()
		return nil
	case generation.FieldPromptStrength:
		m.ResetPromptStrength()
		return nil
	case generation.FieldWasAutoSubmitted:
		m.ResetWasAutoSubmitted()
		return nil
	case generation.FieldStripeProductID:
		m.ResetStripeProductID()
		return nil
	case generation.FieldSourceType:
		m.ResetSourceType()
		return nil
	case generation.FieldPromptID:
		m.ResetPromptID()
		return nil
	case generation.FieldNegativePromptID:
		m.ResetNegativePromptID()
		return nil
	case generation.FieldModelID:
		m.ResetModelID()
		return nil
	case generation.FieldSchedulerID:
		m.ResetSchedulerID()
		return nil
	case generation.FieldUserID:
		m.ResetUserID()
		return nil
	case generation.FieldDeviceInfoID:
		m.ResetDeviceInfoID()
		return nil
	case generation.FieldAPITokenID:
		m.ResetAPITokenID()
		return nil
	case generation.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case generation.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case generation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Generation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenerationMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.device_info != nil {
		edges = append(edges, generation.EdgeDeviceInfo)
	}
	if m.scheduler != nil {
		edges = append(edges, generation.EdgeScheduler)
	}
	if m.prompt != nil {
		edges = append(edges, generation.EdgePrompt)
	}
	if m.negative_prompt != nil {
		edges = append(edges, generation.EdgeNegativePrompt)
	}
	if m.generation_model != nil {
		edges = append(edges, generation.EdgeGenerationModel)
	}
	if m.user != nil {
		edges = append(edges, generation.EdgeUser)
	}
	if m.api_tokens != nil {
		edges = append(edges, generation.EdgeAPITokens)
	}
	if m.generation_outputs != nil {
		edges = append(edges, generation.EdgeGenerationOutputs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenerationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generation.EdgeDeviceInfo:
		if id := m.device_info; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeScheduler:
		if id := m.scheduler; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgePrompt:
		if id := m.prompt; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeNegativePrompt:
		if id := m.negative_prompt; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeGenerationModel:
		if id := m.generation_model; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeAPITokens:
		if id := m.api_tokens; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeGenerationOutputs:
		ids := make([]ent.Value, 0, len(m.generation_outputs))
		for id := range m.generation_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenerationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedgeneration_outputs != nil {
		edges = append(edges, generation.EdgeGenerationOutputs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenerationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case generation.EdgeGenerationOutputs:
		ids := make([]ent.Value, 0, len(m.removedgeneration_outputs))
		for id := range m.removedgeneration_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenerationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.cleareddevice_info {
		edges = append(edges, generation.EdgeDeviceInfo)
	}
	if m.clearedscheduler {
		edges = append(edges, generation.EdgeScheduler)
	}
	if m.clearedprompt {
		edges = append(edges, generation.EdgePrompt)
	}
	if m.clearednegative_prompt {
		edges = append(edges, generation.EdgeNegativePrompt)
	}
	if m.clearedgeneration_model {
		edges = append(edges, generation.EdgeGenerationModel)
	}
	if m.cleareduser {
		edges = append(edges, generation.EdgeUser)
	}
	if m.clearedapi_tokens {
		edges = append(edges, generation.EdgeAPITokens)
	}
	if m.clearedgeneration_outputs {
		edges = append(edges, generation.EdgeGenerationOutputs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenerationMutation) EdgeCleared(name string) bool {
	switch name {
	case generation.EdgeDeviceInfo:
		return m.cleareddevice_info
	case generation.EdgeScheduler:
		return m.clearedscheduler
	case generation.EdgePrompt:
		return m.clearedprompt
	case generation.EdgeNegativePrompt:
		return m.clearednegative_prompt
	case generation.EdgeGenerationModel:
		return m.clearedgeneration_model
	case generation.EdgeUser:
		return m.cleareduser
	case generation.EdgeAPITokens:
		return m.clearedapi_tokens
	case generation.EdgeGenerationOutputs:
		return m.clearedgeneration_outputs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenerationMutation) ClearEdge(name string) error {
	switch name {
	case generation.EdgeDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case generation.EdgeScheduler:
		m.ClearScheduler()
		return nil
	case generation.EdgePrompt:
		m.ClearPrompt()
		return nil
	case generation.EdgeNegativePrompt:
		m.ClearNegativePrompt()
		return nil
	case generation.EdgeGenerationModel:
		m.ClearGenerationModel()
		return nil
	case generation.EdgeUser:
		m.ClearUser()
		return nil
	case generation.EdgeAPITokens:
		m.ClearAPITokens()
		return nil
	}
	return fmt.Errorf("unknown Generation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenerationMutation) ResetEdge(name string) error {
	switch name {
	case generation.EdgeDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case generation.EdgeScheduler:
		m.ResetScheduler()
		return nil
	case generation.EdgePrompt:
		m.ResetPrompt()
		return nil
	case generation.EdgeNegativePrompt:
		m.ResetNegativePrompt()
		return nil
	case generation.EdgeGenerationModel:
		m.ResetGenerationModel()
		return nil
	case generation.EdgeUser:
		m.ResetUser()
		return nil
	case generation.EdgeAPITokens:
		m.ResetAPITokens()
		return nil
	case generation.EdgeGenerationOutputs:
		m.ResetGenerationOutputs()
		return nil
	}
	return fmt.Errorf("unknown Generation edge %s", name)
}

// GenerationModelMutation represents an operation that mutates the GenerationModel nodes in the graph.
type GenerationModelMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	name_in_worker       *string
	is_active            *bool
	is_default           *bool
	is_hidden            *bool
	display_weight       *int32
	adddisplay_weight    *int32
	default_scheduler_id *uuid.UUID
	default_width        *int32
	adddefault_width     *int32
	default_height       *int32
	adddefault_height    *int32
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	generations          map[uuid.UUID]struct{}
	removedgenerations   map[uuid.UUID]struct{}
	clearedgenerations   bool
	schedulers           map[uuid.UUID]struct{}
	removedschedulers    map[uuid.UUID]struct{}
	clearedschedulers    bool
	done                 bool
	oldValue             func(context.Context) (*GenerationModel, error)
	predicates           []predicate.GenerationModel
}

var _ ent.Mutation = (*GenerationModelMutation)(nil)

// generationmodelOption allows management of the mutation configuration using functional options.
type generationmodelOption func(*GenerationModelMutation)

// newGenerationModelMutation creates new mutation for the GenerationModel entity.
func newGenerationModelMutation(c config, op Op, opts ...generationmodelOption) *GenerationModelMutation {
	m := &GenerationModelMutation{
		config:        c,
		op:            op,
		typ:           TypeGenerationModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenerationModelID sets the ID field of the mutation.
func withGenerationModelID(id uuid.UUID) generationmodelOption {
	return func(m *GenerationModelMutation) {
		var (
			err   error
			once  sync.Once
			value *GenerationModel
		)
		m.oldValue = func(ctx context.Context) (*GenerationModel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GenerationModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGenerationModel sets the old GenerationModel of the mutation.
func withGenerationModel(node *GenerationModel) generationmodelOption {
	return func(m *GenerationModelMutation) {
		m.oldValue = func(context.Context) (*GenerationModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenerationModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenerationModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GenerationModel entities.
func (m *GenerationModelMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenerationModelMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenerationModelMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GenerationModel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameInWorker sets the "name_in_worker" field.
func (m *GenerationModelMutation) SetNameInWorker(s string) {
	m.name_in_worker = &s
}

// NameInWorker returns the value of the "name_in_worker" field in the mutation.
func (m *GenerationModelMutation) NameInWorker() (r string, exists bool) {
	v := m.name_in_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldNameInWorker returns the old "name_in_worker" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldNameInWorker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameInWorker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameInWorker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameInWorker: %w", err)
	}
	return oldValue.NameInWorker, nil
}

// ResetNameInWorker resets all changes to the "name_in_worker" field.
func (m *GenerationModelMutation) ResetNameInWorker() {
	m.name_in_worker = nil
}

// SetIsActive sets the "is_active" field.
func (m *GenerationModelMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *GenerationModelMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *GenerationModelMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsDefault sets the "is_default" field.
func (m *GenerationModelMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *GenerationModelMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *GenerationModelMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *GenerationModelMutation) SetIsHidden(b bool) {
	m.is_hidden = &b
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *GenerationModelMutation) IsHidden() (r bool, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *GenerationModelMutation) ResetIsHidden() {
	m.is_hidden = nil
}

// SetDisplayWeight sets the "display_weight" field.
func (m *GenerationModelMutation) SetDisplayWeight(i int32) {
	m.display_weight = &i
	m.adddisplay_weight = nil
}

// DisplayWeight returns the value of the "display_weight" field in the mutation.
func (m *GenerationModelMutation) DisplayWeight() (r int32, exists bool) {
	v := m.display_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayWeight returns the old "display_weight" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldDisplayWeight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayWeight: %w", err)
	}
	return oldValue.DisplayWeight, nil
}

// AddDisplayWeight adds i to the "display_weight" field.
func (m *GenerationModelMutation) AddDisplayWeight(i int32) {
	if m.adddisplay_weight != nil {
		*m.adddisplay_weight += i
	} else {
		m.adddisplay_weight = &i
	}
}

// AddedDisplayWeight returns the value that was added to the "display_weight" field in this mutation.
func (m *GenerationModelMutation) AddedDisplayWeight() (r int32, exists bool) {
	v := m.adddisplay_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayWeight resets all changes to the "display_weight" field.
func (m *GenerationModelMutation) ResetDisplayWeight() {
	m.display_weight = nil
	m.adddisplay_weight = nil
}

// SetDefaultSchedulerID sets the "default_scheduler_id" field.
func (m *GenerationModelMutation) SetDefaultSchedulerID(u uuid.UUID) {
	m.default_scheduler_id = &u
}

// DefaultSchedulerID returns the value of the "default_scheduler_id" field in the mutation.
func (m *GenerationModelMutation) DefaultSchedulerID() (r uuid.UUID, exists bool) {
	v := m.default_scheduler_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultSchedulerID returns the old "default_scheduler_id" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldDefaultSchedulerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultSchedulerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultSchedulerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultSchedulerID: %w", err)
	}
	return oldValue.DefaultSchedulerID, nil
}

// ClearDefaultSchedulerID clears the value of the "default_scheduler_id" field.
func (m *GenerationModelMutation) ClearDefaultSchedulerID() {
	m.default_scheduler_id = nil
	m.clearedFields[generationmodel.FieldDefaultSchedulerID] = struct{}{}
}

// DefaultSchedulerIDCleared returns if the "default_scheduler_id" field was cleared in this mutation.
func (m *GenerationModelMutation) DefaultSchedulerIDCleared() bool {
	_, ok := m.clearedFields[generationmodel.FieldDefaultSchedulerID]
	return ok
}

// ResetDefaultSchedulerID resets all changes to the "default_scheduler_id" field.
func (m *GenerationModelMutation) ResetDefaultSchedulerID() {
	m.default_scheduler_id = nil
	delete(m.clearedFields, generationmodel.FieldDefaultSchedulerID)
}

// SetDefaultWidth sets the "default_width" field.
func (m *GenerationModelMutation) SetDefaultWidth(i int32) {
	m.default_width = &i
	m.adddefault_width = nil
}

// DefaultWidth returns the value of the "default_width" field in the mutation.
func (m *GenerationModelMutation) DefaultWidth() (r int32, exists bool) {
	v := m.default_width
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultWidth returns the old "default_width" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldDefaultWidth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultWidth: %w", err)
	}
	return oldValue.DefaultWidth, nil
}

// AddDefaultWidth adds i to the "default_width" field.
func (m *GenerationModelMutation) AddDefaultWidth(i int32) {
	if m.adddefault_width != nil {
		*m.adddefault_width += i
	} else {
		m.adddefault_width = &i
	}
}

// AddedDefaultWidth returns the value that was added to the "default_width" field in this mutation.
func (m *GenerationModelMutation) AddedDefaultWidth() (r int32, exists bool) {
	v := m.adddefault_width
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultWidth resets all changes to the "default_width" field.
func (m *GenerationModelMutation) ResetDefaultWidth() {
	m.default_width = nil
	m.adddefault_width = nil
}

// SetDefaultHeight sets the "default_height" field.
func (m *GenerationModelMutation) SetDefaultHeight(i int32) {
	m.default_height = &i
	m.adddefault_height = nil
}

// DefaultHeight returns the value of the "default_height" field in the mutation.
func (m *GenerationModelMutation) DefaultHeight() (r int32, exists bool) {
	v := m.default_height
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultHeight returns the old "default_height" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldDefaultHeight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultHeight: %w", err)
	}
	return oldValue.DefaultHeight, nil
}

// AddDefaultHeight adds i to the "default_height" field.
func (m *GenerationModelMutation) AddDefaultHeight(i int32) {
	if m.adddefault_height != nil {
		*m.adddefault_height += i
	} else {
		m.adddefault_height = &i
	}
}

// AddedDefaultHeight returns the value that was added to the "default_height" field in this mutation.
func (m *GenerationModelMutation) AddedDefaultHeight() (r int32, exists bool) {
	v := m.adddefault_height
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultHeight resets all changes to the "default_height" field.
func (m *GenerationModelMutation) ResetDefaultHeight() {
	m.default_height = nil
	m.adddefault_height = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GenerationModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GenerationModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GenerationModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GenerationModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GenerationModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GenerationModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *GenerationModelMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *GenerationModelMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *GenerationModelMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *GenerationModelMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *GenerationModelMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *GenerationModelMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *GenerationModelMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// AddSchedulerIDs adds the "schedulers" edge to the Scheduler entity by ids.
func (m *GenerationModelMutation) AddSchedulerIDs(ids ...uuid.UUID) {
	if m.schedulers == nil {
		m.schedulers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.schedulers[ids[i]] = struct{}{}
	}
}

// ClearSchedulers clears the "schedulers" edge to the Scheduler entity.
func (m *GenerationModelMutation) ClearSchedulers() {
	m.clearedschedulers = true
}

// SchedulersCleared reports if the "schedulers" edge to the Scheduler entity was cleared.
func (m *GenerationModelMutation) SchedulersCleared() bool {
	return m.clearedschedulers
}

// RemoveSchedulerIDs removes the "schedulers" edge to the Scheduler entity by IDs.
func (m *GenerationModelMutation) RemoveSchedulerIDs(ids ...uuid.UUID) {
	if m.removedschedulers == nil {
		m.removedschedulers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.schedulers, ids[i])
		m.removedschedulers[ids[i]] = struct{}{}
	}
}

// RemovedSchedulers returns the removed IDs of the "schedulers" edge to the Scheduler entity.
func (m *GenerationModelMutation) RemovedSchedulersIDs() (ids []uuid.UUID) {
	for id := range m.removedschedulers {
		ids = append(ids, id)
	}
	return
}

// SchedulersIDs returns the "schedulers" edge IDs in the mutation.
func (m *GenerationModelMutation) SchedulersIDs() (ids []uuid.UUID) {
	for id := range m.schedulers {
		ids = append(ids, id)
	}
	return
}

// ResetSchedulers resets all changes to the "schedulers" edge.
func (m *GenerationModelMutation) ResetSchedulers() {
	m.schedulers = nil
	m.clearedschedulers = false
	m.removedschedulers = nil
}

// Where appends a list predicates to the GenerationModelMutation builder.
func (m *GenerationModelMutation) Where(ps ...predicate.GenerationModel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GenerationModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GenerationModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GenerationModel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GenerationModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GenerationModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GenerationModel).
func (m *GenerationModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenerationModelMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name_in_worker != nil {
		fields = append(fields, generationmodel.FieldNameInWorker)
	}
	if m.is_active != nil {
		fields = append(fields, generationmodel.FieldIsActive)
	}
	if m.is_default != nil {
		fields = append(fields, generationmodel.FieldIsDefault)
	}
	if m.is_hidden != nil {
		fields = append(fields, generationmodel.FieldIsHidden)
	}
	if m.display_weight != nil {
		fields = append(fields, generationmodel.FieldDisplayWeight)
	}
	if m.default_scheduler_id != nil {
		fields = append(fields, generationmodel.FieldDefaultSchedulerID)
	}
	if m.default_width != nil {
		fields = append(fields, generationmodel.FieldDefaultWidth)
	}
	if m.default_height != nil {
		fields = append(fields, generationmodel.FieldDefaultHeight)
	}
	if m.created_at != nil {
		fields = append(fields, generationmodel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generationmodel.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenerationModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generationmodel.FieldNameInWorker:
		return m.NameInWorker()
	case generationmodel.FieldIsActive:
		return m.IsActive()
	case generationmodel.FieldIsDefault:
		return m.IsDefault()
	case generationmodel.FieldIsHidden:
		return m.IsHidden()
	case generationmodel.FieldDisplayWeight:
		return m.DisplayWeight()
	case generationmodel.FieldDefaultSchedulerID:
		return m.DefaultSchedulerID()
	case generationmodel.FieldDefaultWidth:
		return m.DefaultWidth()
	case generationmodel.FieldDefaultHeight:
		return m.DefaultHeight()
	case generationmodel.FieldCreatedAt:
		return m.CreatedAt()
	case generationmodel.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenerationModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generationmodel.FieldNameInWorker:
		return m.OldNameInWorker(ctx)
	case generationmodel.FieldIsActive:
		return m.OldIsActive(ctx)
	case generationmodel.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case generationmodel.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case generationmodel.FieldDisplayWeight:
		return m.OldDisplayWeight(ctx)
	case generationmodel.FieldDefaultSchedulerID:
		return m.OldDefaultSchedulerID(ctx)
	case generationmodel.FieldDefaultWidth:
		return m.OldDefaultWidth(ctx)
	case generationmodel.FieldDefaultHeight:
		return m.OldDefaultHeight(ctx)
	case generationmodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generationmodel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GenerationModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generationmodel.FieldNameInWorker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameInWorker(v)
		return nil
	case generationmodel.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case generationmodel.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case generationmodel.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case generationmodel.FieldDisplayWeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayWeight(v)
		return nil
	case generationmodel.FieldDefaultSchedulerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultSchedulerID(v)
		return nil
	case generationmodel.FieldDefaultWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultWidth(v)
		return nil
	case generationmodel.FieldDefaultHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultHeight(v)
		return nil
	case generationmodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generationmodel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GenerationModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenerationModelMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_weight != nil {
		fields = append(fields, generationmodel.FieldDisplayWeight)
	}
	if m.adddefault_width != nil {
		fields = append(fields, generationmodel.FieldDefaultWidth)
	}
	if m.adddefault_height != nil {
		fields = append(fields, generationmodel.FieldDefaultHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenerationModelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case generationmodel.FieldDisplayWeight:
		return m.AddedDisplayWeight()
	case generationmodel.FieldDefaultWidth:
		return m.AddedDefaultWidth()
	case generationmodel.FieldDefaultHeight:
		return m.AddedDefaultHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case generationmodel.FieldDisplayWeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayWeight(v)
		return nil
	case generationmodel.FieldDefaultWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultWidth(v)
		return nil
	case generationmodel.FieldDefaultHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultHeight(v)
		return nil
	}
	return fmt.Errorf("unknown GenerationModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenerationModelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(generationmodel.FieldDefaultSchedulerID) {
		fields = append(fields, generationmodel.FieldDefaultSchedulerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenerationModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenerationModelMutation) ClearField(name string) error {
	switch name {
	case generationmodel.FieldDefaultSchedulerID:
		m.ClearDefaultSchedulerID()
		return nil
	}
	return fmt.Errorf("unknown GenerationModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenerationModelMutation) ResetField(name string) error {
	switch name {
	case generationmodel.FieldNameInWorker:
		m.ResetNameInWorker()
		return nil
	case generationmodel.FieldIsActive:
		m.ResetIsActive()
		return nil
	case generationmodel.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case generationmodel.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case generationmodel.FieldDisplayWeight:
		m.ResetDisplayWeight()
		return nil
	case generationmodel.FieldDefaultSchedulerID:
		m.ResetDefaultSchedulerID()
		return nil
	case generationmodel.FieldDefaultWidth:
		m.ResetDefaultWidth()
		return nil
	case generationmodel.FieldDefaultHeight:
		m.ResetDefaultHeight()
		return nil
	case generationmodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generationmodel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GenerationModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenerationModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.generations != nil {
		edges = append(edges, generationmodel.EdgeGenerations)
	}
	if m.schedulers != nil {
		edges = append(edges, generationmodel.EdgeSchedulers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenerationModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generationmodel.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	case generationmodel.EdgeSchedulers:
		ids := make([]ent.Value, 0, len(m.schedulers))
		for id := range m.schedulers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenerationModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgenerations != nil {
		edges = append(edges, generationmodel.EdgeGenerations)
	}
	if m.removedschedulers != nil {
		edges = append(edges, generationmodel.EdgeSchedulers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenerationModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case generationmodel.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	case generationmodel.EdgeSchedulers:
		ids := make([]ent.Value, 0, len(m.removedschedulers))
		for id := range m.removedschedulers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenerationModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgenerations {
		edges = append(edges, generationmodel.EdgeGenerations)
	}
	if m.clearedschedulers {
		edges = append(edges, generationmodel.EdgeSchedulers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenerationModelMutation) EdgeCleared(name string) bool {
	switch name {
	case generationmodel.EdgeGenerations:
		return m.clearedgenerations
	case generationmodel.EdgeSchedulers:
		return m.clearedschedulers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenerationModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GenerationModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenerationModelMutation) ResetEdge(name string) error {
	switch name {
	case generationmodel.EdgeGenerations:
		m.ResetGenerations()
		return nil
	case generationmodel.EdgeSchedulers:
		m.ResetSchedulers()
		return nil
	}
	return fmt.Errorf("unknown GenerationModel edge %s", name)
}

// GenerationOutputMutation represents an operation that mutates the GenerationOutput nodes in the graph.
type GenerationOutputMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	image_path                     *string
	upscaled_image_path            *string
	gallery_status                 *generationoutput.GalleryStatus
	is_favorited                   *bool
	has_embeddings                 *bool
	is_public                      *bool
	like_count                     *int
	addlike_count                  *int
	deleted_at                     *time.Time
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	generations                    *uuid.UUID
	clearedgenerations             bool
	upscale_outputs                *uuid.UUID
	clearedupscale_outputs         bool
	generation_output_likes        map[uuid.UUID]struct{}
	removedgeneration_output_likes map[uuid.UUID]struct{}
	clearedgeneration_output_likes bool
	done                           bool
	oldValue                       func(context.Context) (*GenerationOutput, error)
	predicates                     []predicate.GenerationOutput
}

var _ ent.Mutation = (*GenerationOutputMutation)(nil)

// generationoutputOption allows management of the mutation configuration using functional options.
type generationoutputOption func(*GenerationOutputMutation)

// newGenerationOutputMutation creates new mutation for the GenerationOutput entity.
func newGenerationOutputMutation(c config, op Op, opts ...generationoutputOption) *GenerationOutputMutation {
	m := &GenerationOutputMutation{
		config:        c,
		op:            op,
		typ:           TypeGenerationOutput,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenerationOutputID sets the ID field of the mutation.
func withGenerationOutputID(id uuid.UUID) generationoutputOption {
	return func(m *GenerationOutputMutation) {
		var (
			err   error
			once  sync.Once
			value *GenerationOutput
		)
		m.oldValue = func(ctx context.Context) (*GenerationOutput, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GenerationOutput.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGenerationOutput sets the old GenerationOutput of the mutation.
func withGenerationOutput(node *GenerationOutput) generationoutputOption {
	return func(m *GenerationOutputMutation) {
		m.oldValue = func(context.Context) (*GenerationOutput, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenerationOutputMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenerationOutputMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GenerationOutput entities.
func (m *GenerationOutputMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenerationOutputMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenerationOutputMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GenerationOutput.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImagePath sets the "image_path" field.
func (m *GenerationOutputMutation) SetImagePath(s string) {
	m.image_path = &s
}

// ImagePath returns the value of the "image_path" field in the mutation.
func (m *GenerationOutputMutation) ImagePath() (r string, exists bool) {
	v := m.image_path
	if v == nil {
		return
	}
	return *v, true
}

// OldImagePath returns the old "image_path" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldImagePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImagePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImagePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImagePath: %w", err)
	}
	return oldValue.ImagePath, nil
}

// ResetImagePath resets all changes to the "image_path" field.
func (m *GenerationOutputMutation) ResetImagePath() {
	m.image_path = nil
}

// SetUpscaledImagePath sets the "upscaled_image_path" field.
func (m *GenerationOutputMutation) SetUpscaledImagePath(s string) {
	m.upscaled_image_path = &s
}

// UpscaledImagePath returns the value of the "upscaled_image_path" field in the mutation.
func (m *GenerationOutputMutation) UpscaledImagePath() (r string, exists bool) {
	v := m.upscaled_image_path
	if v == nil {
		return
	}
	return *v, true
}

// OldUpscaledImagePath returns the old "upscaled_image_path" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldUpscaledImagePath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpscaledImagePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpscaledImagePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpscaledImagePath: %w", err)
	}
	return oldValue.UpscaledImagePath, nil
}

// ClearUpscaledImagePath clears the value of the "upscaled_image_path" field.
func (m *GenerationOutputMutation) ClearUpscaledImagePath() {
	m.upscaled_image_path = nil
	m.clearedFields[generationoutput.FieldUpscaledImagePath] = struct{}{}
}

// UpscaledImagePathCleared returns if the "upscaled_image_path" field was cleared in this mutation.
func (m *GenerationOutputMutation) UpscaledImagePathCleared() bool {
	_, ok := m.clearedFields[generationoutput.FieldUpscaledImagePath]
	return ok
}

// ResetUpscaledImagePath resets all changes to the "upscaled_image_path" field.
func (m *GenerationOutputMutation) ResetUpscaledImagePath() {
	m.upscaled_image_path = nil
	delete(m.clearedFields, generationoutput.FieldUpscaledImagePath)
}

// SetGalleryStatus sets the "gallery_status" field.
func (m *GenerationOutputMutation) SetGalleryStatus(gs generationoutput.GalleryStatus) {
	m.gallery_status = &gs
}

// GalleryStatus returns the value of the "gallery_status" field in the mutation.
func (m *GenerationOutputMutation) GalleryStatus() (r generationoutput.GalleryStatus, exists bool) {
	v := m.gallery_status
	if v == nil {
		return
	}
	return *v, true
}

// OldGalleryStatus returns the old "gallery_status" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldGalleryStatus(ctx context.Context) (v generationoutput.GalleryStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGalleryStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGalleryStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGalleryStatus: %w", err)
	}
	return oldValue.GalleryStatus, nil
}

// ResetGalleryStatus resets all changes to the "gallery_status" field.
func (m *GenerationOutputMutation) ResetGalleryStatus() {
	m.gallery_status = nil
}

// SetIsFavorited sets the "is_favorited" field.
func (m *GenerationOutputMutation) SetIsFavorited(b bool) {
	m.is_favorited = &b
}

// IsFavorited returns the value of the "is_favorited" field in the mutation.
func (m *GenerationOutputMutation) IsFavorited() (r bool, exists bool) {
	v := m.is_favorited
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFavorited returns the old "is_favorited" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldIsFavorited(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFavorited is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFavorited requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFavorited: %w", err)
	}
	return oldValue.IsFavorited, nil
}

// ResetIsFavorited resets all changes to the "is_favorited" field.
func (m *GenerationOutputMutation) ResetIsFavorited() {
	m.is_favorited = nil
}

// SetHasEmbeddings sets the "has_embeddings" field.
func (m *GenerationOutputMutation) SetHasEmbeddings(b bool) {
	m.has_embeddings = &b
}

// HasEmbeddings returns the value of the "has_embeddings" field in the mutation.
func (m *GenerationOutputMutation) HasEmbeddings() (r bool, exists bool) {
	v := m.has_embeddings
	if v == nil {
		return
	}
	return *v, true
}

// OldHasEmbeddings returns the old "has_embeddings" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldHasEmbeddings(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasEmbeddings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasEmbeddings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasEmbeddings: %w", err)
	}
	return oldValue.HasEmbeddings, nil
}

// ResetHasEmbeddings resets all changes to the "has_embeddings" field.
func (m *GenerationOutputMutation) ResetHasEmbeddings() {
	m.has_embeddings = nil
}

// SetIsPublic sets the "is_public" field.
func (m *GenerationOutputMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *GenerationOutputMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *GenerationOutputMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetLikeCount sets the "like_count" field.
func (m *GenerationOutputMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *GenerationOutputMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *GenerationOutputMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *GenerationOutputMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *GenerationOutputMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetGenerationID sets the "generation_id" field.
func (m *GenerationOutputMutation) SetGenerationID(u uuid.UUID) {
	m.generations = &u
}

// GenerationID returns the value of the "generation_id" field in the mutation.
func (m *GenerationOutputMutation) GenerationID() (r uuid.UUID, exists bool) {
	v := m.generations
	if v == nil {
		return
	}
	return *v, true
}

// OldGenerationID returns the old "generation_id" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldGenerationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenerationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenerationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenerationID: %w", err)
	}
	return oldValue.GenerationID, nil
}

// ResetGenerationID resets all changes to the "generation_id" field.
func (m *GenerationOutputMutation) ResetGenerationID() {
	m.generations = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GenerationOutputMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GenerationOutputMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GenerationOutputMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[generationoutput.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GenerationOutputMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[generationoutput.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GenerationOutputMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, generationoutput.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *GenerationOutputMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GenerationOutputMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GenerationOutputMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GenerationOutputMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GenerationOutputMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GenerationOutputMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGenerationsID sets the "generations" edge to the Generation entity by id.
func (m *GenerationOutputMutation) SetGenerationsID(id uuid.UUID) {
	m.generations = &id
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *GenerationOutputMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *GenerationOutputMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// GenerationsID returns the "generations" edge ID in the mutation.
func (m *GenerationOutputMutation) GenerationsID() (id uuid.UUID, exists bool) {
	if m.generations != nil {
		return *m.generations, true
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenerationsID instead. It exists only for internal usage by the builders.
func (m *GenerationOutputMutation) GenerationsIDs() (ids []uuid.UUID) {
	if id := m.generations; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *GenerationOutputMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
}

// SetUpscaleOutputsID sets the "upscale_outputs" edge to the UpscaleOutput entity by id.
func (m *GenerationOutputMutation) SetUpscaleOutputsID(id uuid.UUID) {
	m.upscale_outputs = &id
}

// ClearUpscaleOutputs clears the "upscale_outputs" edge to the UpscaleOutput entity.
func (m *GenerationOutputMutation) ClearUpscaleOutputs() {
	m.clearedupscale_outputs = true
}

// UpscaleOutputsCleared reports if the "upscale_outputs" edge to the UpscaleOutput entity was cleared.
func (m *GenerationOutputMutation) UpscaleOutputsCleared() bool {
	return m.clearedupscale_outputs
}

// UpscaleOutputsID returns the "upscale_outputs" edge ID in the mutation.
func (m *GenerationOutputMutation) UpscaleOutputsID() (id uuid.UUID, exists bool) {
	if m.upscale_outputs != nil {
		return *m.upscale_outputs, true
	}
	return
}

// UpscaleOutputsIDs returns the "upscale_outputs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpscaleOutputsID instead. It exists only for internal usage by the builders.
func (m *GenerationOutputMutation) UpscaleOutputsIDs() (ids []uuid.UUID) {
	if id := m.upscale_outputs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpscaleOutputs resets all changes to the "upscale_outputs" edge.
func (m *GenerationOutputMutation) ResetUpscaleOutputs() {
	m.upscale_outputs = nil
	m.clearedupscale_outputs = false
}

// AddGenerationOutputLikeIDs adds the "generation_output_likes" edge to the GenerationOutputLike entity by ids.
func (m *GenerationOutputMutation) AddGenerationOutputLikeIDs(ids ...uuid.UUID) {
	if m.generation_output_likes == nil {
		m.generation_output_likes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generation_output_likes[ids[i]] = struct{}{}
	}
}

// ClearGenerationOutputLikes clears the "generation_output_likes" edge to the GenerationOutputLike entity.
func (m *GenerationOutputMutation) ClearGenerationOutputLikes() {
	m.clearedgeneration_output_likes = true
}

// GenerationOutputLikesCleared reports if the "generation_output_likes" edge to the GenerationOutputLike entity was cleared.
func (m *GenerationOutputMutation) GenerationOutputLikesCleared() bool {
	return m.clearedgeneration_output_likes
}

// RemoveGenerationOutputLikeIDs removes the "generation_output_likes" edge to the GenerationOutputLike entity by IDs.
func (m *GenerationOutputMutation) RemoveGenerationOutputLikeIDs(ids ...uuid.UUID) {
	if m.removedgeneration_output_likes == nil {
		m.removedgeneration_output_likes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generation_output_likes, ids[i])
		m.removedgeneration_output_likes[ids[i]] = struct{}{}
	}
}

// RemovedGenerationOutputLikes returns the removed IDs of the "generation_output_likes" edge to the GenerationOutputLike entity.
func (m *GenerationOutputMutation) RemovedGenerationOutputLikesIDs() (ids []uuid.UUID) {
	for id := range m.removedgeneration_output_likes {
		ids = append(ids, id)
	}
	return
}

// GenerationOutputLikesIDs returns the "generation_output_likes" edge IDs in the mutation.
func (m *GenerationOutputMutation) GenerationOutputLikesIDs() (ids []uuid.UUID) {
	for id := range m.generation_output_likes {
		ids = append(ids, id)
	}
	return
}

// ResetGenerationOutputLikes resets all changes to the "generation_output_likes" edge.
func (m *GenerationOutputMutation) ResetGenerationOutputLikes() {
	m.generation_output_likes = nil
	m.clearedgeneration_output_likes = false
	m.removedgeneration_output_likes = nil
}

// Where appends a list predicates to the GenerationOutputMutation builder.
func (m *GenerationOutputMutation) Where(ps ...predicate.GenerationOutput) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GenerationOutputMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GenerationOutputMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GenerationOutput, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GenerationOutputMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GenerationOutputMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GenerationOutput).
func (m *GenerationOutputMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenerationOutputMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.image_path != nil {
		fields = append(fields, generationoutput.FieldImagePath)
	}
	if m.upscaled_image_path != nil {
		fields = append(fields, generationoutput.FieldUpscaledImagePath)
	}
	if m.gallery_status != nil {
		fields = append(fields, generationoutput.FieldGalleryStatus)
	}
	if m.is_favorited != nil {
		fields = append(fields, generationoutput.FieldIsFavorited)
	}
	if m.has_embeddings != nil {
		fields = append(fields, generationoutput.FieldHasEmbeddings)
	}
	if m.is_public != nil {
		fields = append(fields, generationoutput.FieldIsPublic)
	}
	if m.like_count != nil {
		fields = append(fields, generationoutput.FieldLikeCount)
	}
	if m.generations != nil {
		fields = append(fields, generationoutput.FieldGenerationID)
	}
	if m.deleted_at != nil {
		fields = append(fields, generationoutput.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, generationoutput.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generationoutput.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenerationOutputMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generationoutput.FieldImagePath:
		return m.ImagePath()
	case generationoutput.FieldUpscaledImagePath:
		return m.UpscaledImagePath()
	case generationoutput.FieldGalleryStatus:
		return m.GalleryStatus()
	case generationoutput.FieldIsFavorited:
		return m.IsFavorited()
	case generationoutput.FieldHasEmbeddings:
		return m.HasEmbeddings()
	case generationoutput.FieldIsPublic:
		return m.IsPublic()
	case generationoutput.FieldLikeCount:
		return m.LikeCount()
	case generationoutput.FieldGenerationID:
		return m.GenerationID()
	case generationoutput.FieldDeletedAt:
		return m.DeletedAt()
	case generationoutput.FieldCreatedAt:
		return m.CreatedAt()
	case generationoutput.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenerationOutputMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generationoutput.FieldImagePath:
		return m.OldImagePath(ctx)
	case generationoutput.FieldUpscaledImagePath:
		return m.OldUpscaledImagePath(ctx)
	case generationoutput.FieldGalleryStatus:
		return m.OldGalleryStatus(ctx)
	case generationoutput.FieldIsFavorited:
		return m.OldIsFavorited(ctx)
	case generationoutput.FieldHasEmbeddings:
		return m.OldHasEmbeddings(ctx)
	case generationoutput.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case generationoutput.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case generationoutput.FieldGenerationID:
		return m.OldGenerationID(ctx)
	case generationoutput.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case generationoutput.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generationoutput.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GenerationOutput field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationOutputMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generationoutput.FieldImagePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImagePath(v)
		return nil
	case generationoutput.FieldUpscaledImagePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpscaledImagePath(v)
		return nil
	case generationoutput.FieldGalleryStatus:
		v, ok := value.(generationoutput.GalleryStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGalleryStatus(v)
		return nil
	case generationoutput.FieldIsFavorited:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFavorited(v)
		return nil
	case generationoutput.FieldHasEmbeddings:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasEmbeddings(v)
		return nil
	case generationoutput.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case generationoutput.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case generationoutput.FieldGenerationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenerationID(v)
		return nil
	case generationoutput.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case generationoutput.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generationoutput.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenerationOutputMutation) AddedFields() []string {
	var fields []string
	if m.addlike_count != nil {
		fields = append(fields, generationoutput.FieldLikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenerationOutputMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case generationoutput.FieldLikeCount:
		return m.AddedLikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationOutputMutation) AddField(name string, value ent.Value) error {
	switch name {
	case generationoutput.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenerationOutputMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(generationoutput.FieldUpscaledImagePath) {
		fields = append(fields, generationoutput.FieldUpscaledImagePath)
	}
	if m.FieldCleared(generationoutput.FieldDeletedAt) {
		fields = append(fields, generationoutput.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenerationOutputMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenerationOutputMutation) ClearField(name string) error {
	switch name {
	case generationoutput.FieldUpscaledImagePath:
		m.ClearUpscaledImagePath()
		return nil
	case generationoutput.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenerationOutputMutation) ResetField(name string) error {
	switch name {
	case generationoutput.FieldImagePath:
		m.ResetImagePath()
		return nil
	case generationoutput.FieldUpscaledImagePath:
		m.ResetUpscaledImagePath()
		return nil
	case generationoutput.FieldGalleryStatus:
		m.ResetGalleryStatus()
		return nil
	case generationoutput.FieldIsFavorited:
		m.ResetIsFavorited()
		return nil
	case generationoutput.FieldHasEmbeddings:
		m.ResetHasEmbeddings()
		return nil
	case generationoutput.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case generationoutput.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case generationoutput.FieldGenerationID:
		m.ResetGenerationID()
		return nil
	case generationoutput.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case generationoutput.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generationoutput.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenerationOutputMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.generations != nil {
		edges = append(edges, generationoutput.EdgeGenerations)
	}
	if m.upscale_outputs != nil {
		edges = append(edges, generationoutput.EdgeUpscaleOutputs)
	}
	if m.generation_output_likes != nil {
		edges = append(edges, generationoutput.EdgeGenerationOutputLikes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenerationOutputMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generationoutput.EdgeGenerations:
		if id := m.generations; id != nil {
			return []ent.Value{*id}
		}
	case generationoutput.EdgeUpscaleOutputs:
		if id := m.upscale_outputs; id != nil {
			return []ent.Value{*id}
		}
	case generationoutput.EdgeGenerationOutputLikes:
		ids := make([]ent.Value, 0, len(m.generation_output_likes))
		for id := range m.generation_output_likes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenerationOutputMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgeneration_output_likes != nil {
		edges = append(edges, generationoutput.EdgeGenerationOutputLikes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenerationOutputMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case generationoutput.EdgeGenerationOutputLikes:
		ids := make([]ent.Value, 0, len(m.removedgeneration_output_likes))
		for id := range m.removedgeneration_output_likes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenerationOutputMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgenerations {
		edges = append(edges, generationoutput.EdgeGenerations)
	}
	if m.clearedupscale_outputs {
		edges = append(edges, generationoutput.EdgeUpscaleOutputs)
	}
	if m.clearedgeneration_output_likes {
		edges = append(edges, generationoutput.EdgeGenerationOutputLikes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenerationOutputMutation) EdgeCleared(name string) bool {
	switch name {
	case generationoutput.EdgeGenerations:
		return m.clearedgenerations
	case generationoutput.EdgeUpscaleOutputs:
		return m.clearedupscale_outputs
	case generationoutput.EdgeGenerationOutputLikes:
		return m.clearedgeneration_output_likes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenerationOutputMutation) ClearEdge(name string) error {
	switch name {
	case generationoutput.EdgeGenerations:
		m.ClearGenerations()
		return nil
	case generationoutput.EdgeUpscaleOutputs:
		m.ClearUpscaleOutputs()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenerationOutputMutation) ResetEdge(name string) error {
	switch name {
	case generationoutput.EdgeGenerations:
		m.ResetGenerations()
		return nil
	case generationoutput.EdgeUpscaleOutputs:
		m.ResetUpscaleOutputs()
		return nil
	case generationoutput.EdgeGenerationOutputLikes:
		m.ResetGenerationOutputLikes()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput edge %s", name)
}

// GenerationOutputLikeMutation represents an operation that mutates the GenerationOutputLike nodes in the graph.
type GenerationOutputLikeMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	clearedFields             map[string]struct{}
	generation_outputs        *uuid.UUID
	clearedgeneration_outputs bool
	users                     *uuid.UUID
	clearedusers              bool
	done                      bool
	oldValue                  func(context.Context) (*GenerationOutputLike, error)
	predicates                []predicate.GenerationOutputLike
}

var _ ent.Mutation = (*GenerationOutputLikeMutation)(nil)

// generationoutputlikeOption allows management of the mutation configuration using functional options.
type generationoutputlikeOption func(*GenerationOutputLikeMutation)

// newGenerationOutputLikeMutation creates new mutation for the GenerationOutputLike entity.
func newGenerationOutputLikeMutation(c config, op Op, opts ...generationoutputlikeOption) *GenerationOutputLikeMutation {
	m := &GenerationOutputLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeGenerationOutputLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenerationOutputLikeID sets the ID field of the mutation.
func withGenerationOutputLikeID(id uuid.UUID) generationoutputlikeOption {
	return func(m *GenerationOutputLikeMutation) {
		var (
			err   error
			once  sync.Once
			value *GenerationOutputLike
		)
		m.oldValue = func(ctx context.Context) (*GenerationOutputLike, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GenerationOutputLike.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGenerationOutputLike sets the old GenerationOutputLike of the mutation.
func withGenerationOutputLike(node *GenerationOutputLike) generationoutputlikeOption {
	return func(m *GenerationOutputLikeMutation) {
		m.oldValue = func(context.Context) (*GenerationOutputLike, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenerationOutputLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenerationOutputLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GenerationOutputLike entities.
func (m *GenerationOutputLikeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenerationOutputLikeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenerationOutputLikeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GenerationOutputLike.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutputID sets the "output_id" field.
func (m *GenerationOutputLikeMutation) SetOutputID(u uuid.UUID) {
	m.generation_outputs = &u
}

// OutputID returns the value of the "output_id" field in the mutation.
func (m *GenerationOutputLikeMutation) OutputID() (r uuid.UUID, exists bool) {
	v := m.generation_outputs
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputID returns the old "output_id" field's value of the GenerationOutputLike entity.
// If the GenerationOutputLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputLikeMutation) OldOutputID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputID: %w", err)
	}
	return oldValue.OutputID, nil
}

// ResetOutputID resets all changes to the "output_id" field.
func (m *GenerationOutputLikeMutation) ResetOutputID() {
	m.generation_outputs = nil
}

// SetLikedByUserID sets the "liked_by_user_id" field.
func (m *GenerationOutputLikeMutation) SetLikedByUserID(u uuid.UUID) {
	m.users = &u
}

// LikedByUserID returns the value of the "liked_by_user_id" field in the mutation.
func (m *GenerationOutputLikeMutation) LikedByUserID() (r uuid.UUID, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldLikedByUserID returns the old "liked_by_user_id" field's value of the GenerationOutputLike entity.
// If the GenerationOutputLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputLikeMutation) OldLikedByUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikedByUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikedByUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikedByUserID: %w", err)
	}
	return oldValue.LikedByUserID, nil
}

// ResetLikedByUserID resets all changes to the "liked_by_user_id" field.
func (m *GenerationOutputLikeMutation) ResetLikedByUserID() {
	m.users = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GenerationOutputLikeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GenerationOutputLikeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GenerationOutputLike entity.
// If the GenerationOutputLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputLikeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GenerationOutputLikeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetGenerationOutputsID sets the "generation_outputs" edge to the GenerationOutput entity by id.
func (m *GenerationOutputLikeMutation) SetGenerationOutputsID(id uuid.UUID) {
	m.generation_outputs = &id
}

// ClearGenerationOutputs clears the "generation_outputs" edge to the GenerationOutput entity.
func (m *GenerationOutputLikeMutation) ClearGenerationOutputs() {
	m.clearedgeneration_outputs = true
}

// GenerationOutputsCleared reports if the "generation_outputs" edge to the GenerationOutput entity was cleared.
func (m *GenerationOutputLikeMutation) GenerationOutputsCleared() bool {
	return m.clearedgeneration_outputs
}

// GenerationOutputsID returns the "generation_outputs" edge ID in the mutation.
func (m *GenerationOutputLikeMutation) GenerationOutputsID() (id uuid.UUID, exists bool) {
	if m.generation_outputs != nil {
		return *m.generation_outputs, true
	}
	return
}

// GenerationOutputsIDs returns the "generation_outputs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenerationOutputsID instead. It exists only for internal usage by the builders.
func (m *GenerationOutputLikeMutation) GenerationOutputsIDs() (ids []uuid.UUID) {
	if id := m.generation_outputs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenerationOutputs resets all changes to the "generation_outputs" edge.
func (m *GenerationOutputLikeMutation) ResetGenerationOutputs() {
	m.generation_outputs = nil
	m.clearedgeneration_outputs = false
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *GenerationOutputLikeMutation) SetUsersID(id uuid.UUID) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *GenerationOutputLikeMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *GenerationOutputLikeMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *GenerationOutputLikeMutation) UsersID() (id uuid.UUID, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *GenerationOutputLikeMutation) UsersIDs() (ids []uuid.UUID) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *GenerationOutputLikeMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the GenerationOutputLikeMutation builder.
func (m *GenerationOutputLikeMutation) Where(ps ...predicate.GenerationOutputLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GenerationOutputLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GenerationOutputLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GenerationOutputLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GenerationOutputLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GenerationOutputLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GenerationOutputLike).
func (m *GenerationOutputLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenerationOutputLikeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.generation_outputs != nil {
		fields = append(fields, generationoutputlike.FieldOutputID)
	}
	if m.users != nil {
		fields = append(fields, generationoutputlike.FieldLikedByUserID)
	}
	if m.created_at != nil {
		fields = append(fields, generationoutputlike.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenerationOutputLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generationoutputlike.FieldOutputID:
		return m.OutputID()
	case generationoutputlike.FieldLikedByUserID:
		return m.LikedByUserID()
	case generationoutputlike.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenerationOutputLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generationoutputlike.FieldOutputID:
		return m.OldOutputID(ctx)
	case generationoutputlike.FieldLikedByUserID:
		return m.OldLikedByUserID(ctx)
	case generationoutputlike.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GenerationOutputLike field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationOutputLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generationoutputlike.FieldOutputID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputID(v)
		return nil
	case generationoutputlike.FieldLikedByUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikedByUserID(v)
		return nil
	case generationoutputlike.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GenerationOutputLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenerationOutputLikeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenerationOutputLikeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationOutputLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GenerationOutputLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenerationOutputLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenerationOutputLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenerationOutputLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GenerationOutputLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenerationOutputLikeMutation) ResetField(name string) error {
	switch name {
	case generationoutputlike.FieldOutputID:
		m.ResetOutputID()
		return nil
	case generationoutputlike.FieldLikedByUserID:
		m.ResetLikedByUserID()
		return nil
	case generationoutputlike.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutputLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenerationOutputLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.generation_outputs != nil {
		edges = append(edges, generationoutputlike.EdgeGenerationOutputs)
	}
	if m.users != nil {
		edges = append(edges, generationoutputlike.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenerationOutputLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generationoutputlike.EdgeGenerationOutputs:
		if id := m.generation_outputs; id != nil {
			return []ent.Value{*id}
		}
	case generationoutputlike.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenerationOutputLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenerationOutputLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenerationOutputLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgeneration_outputs {
		edges = append(edges, generationoutputlike.EdgeGenerationOutputs)
	}
	if m.clearedusers {
		edges = append(edges, generationoutputlike.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenerationOutputLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case generationoutputlike.EdgeGenerationOutputs:
		return m.clearedgeneration_outputs
	case generationoutputlike.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenerationOutputLikeMutation) ClearEdge(name string) error {
	switch name {
	case generationoutputlike.EdgeGenerationOutputs:
		m.ClearGenerationOutputs()
		return nil
	case generationoutputlike.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutputLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenerationOutputLikeMutation) ResetEdge(name string) error {
	switch name {
	case generationoutputlike.EdgeGenerationOutputs:
		m.ResetGenerationOutputs()
		return nil
	case generationoutputlike.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutputLike edge %s", name)
}

// IPBlackListMutation represents an operation that mutates the IPBlackList nodes in the graph.
type IPBlackListMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	ip            *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*IPBlackList, error)
	predicates    []predicate.IPBlackList
}

var _ ent.Mutation = (*IPBlackListMutation)(nil)

// ipblacklistOption allows management of the mutation configuration using functional options.
type ipblacklistOption func(*IPBlackListMutation)

// newIPBlackListMutation creates new mutation for the IPBlackList entity.
func newIPBlackListMutation(c config, op Op, opts ...ipblacklistOption) *IPBlackListMutation {
	m := &IPBlackListMutation{
		config:        c,
		op:            op,
		typ:           TypeIPBlackList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIPBlackListID sets the ID field of the mutation.
func withIPBlackListID(id uuid.UUID) ipblacklistOption {
	return func(m *IPBlackListMutation) {
		var (
			err   error
			once  sync.Once
			value *IPBlackList
		)
		m.oldValue = func(ctx context.Context) (*IPBlackList, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IPBlackList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIPBlackList sets the old IPBlackList of the mutation.
func withIPBlackList(node *IPBlackList) ipblacklistOption {
	return func(m *IPBlackListMutation) {
		m.oldValue = func(context.Context) (*IPBlackList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IPBlackListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IPBlackListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IPBlackList entities.
func (m *IPBlackListMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IPBlackListMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IPBlackListMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IPBlackList.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIP sets the "ip" field.
func (m *IPBlackListMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *IPBlackListMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the IPBlackList entity.
// If the IPBlackList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPBlackListMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *IPBlackListMutation) ResetIP() {
	m.ip = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IPBlackListMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IPBlackListMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IPBlackList entity.
// If the IPBlackList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPBlackListMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IPBlackListMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IPBlackListMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IPBlackListMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IPBlackList entity.
// If the IPBlackList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPBlackListMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IPBlackListMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the IPBlackListMutation builder.
func (m *IPBlackListMutation) Where(ps ...predicate.IPBlackList) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IPBlackListMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IPBlackListMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IPBlackList, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IPBlackListMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IPBlackListMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IPBlackList).
func (m *IPBlackListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IPBlackListMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.ip != nil {
		fields = append(fields, ipblacklist.FieldIP)
	}
	if m.created_at != nil {
		fields = append(fields, ipblacklist.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ipblacklist.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IPBlackListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ipblacklist.FieldIP:
		return m.IP()
	case ipblacklist.FieldCreatedAt:
		return m.CreatedAt()
	case ipblacklist.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IPBlackListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ipblacklist.FieldIP:
		return m.OldIP(ctx)
	case ipblacklist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ipblacklist.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IPBlackList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPBlackListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ipblacklist.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case ipblacklist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ipblacklist.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IPBlackList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IPBlackListMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IPBlackListMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPBlackListMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IPBlackList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IPBlackListMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IPBlackListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IPBlackListMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IPBlackList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IPBlackListMutation) ResetField(name string) error {
	switch name {
	case ipblacklist.FieldIP:
		m.ResetIP()
		return nil
	case ipblacklist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ipblacklist.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown IPBlackList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IPBlackListMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IPBlackListMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IPBlackListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IPBlackListMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IPBlackListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IPBlackListMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IPBlackListMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IPBlackList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IPBlackListMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IPBlackList edge %s", name)
}

// MqLogMutation represents an operation that mutates the MqLog nodes in the graph.
type MqLogMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	message_id    *string
	priority      *int
	addpriority   *int
	is_processing *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MqLog, error)
	predicates    []predicate.MqLog
}

var _ ent.Mutation = (*MqLogMutation)(nil)

// mqlogOption allows management of the mutation configuration using functional options.
type mqlogOption func(*MqLogMutation)

// newMqLogMutation creates new mutation for the MqLog entity.
func newMqLogMutation(c config, op Op, opts ...mqlogOption) *MqLogMutation {
	m := &MqLogMutation{
		config:        c,
		op:            op,
		typ:           TypeMqLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMqLogID sets the ID field of the mutation.
func withMqLogID(id uuid.UUID) mqlogOption {
	return func(m *MqLogMutation) {
		var (
			err   error
			once  sync.Once
			value *MqLog
		)
		m.oldValue = func(ctx context.Context) (*MqLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MqLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMqLog sets the old MqLog of the mutation.
func withMqLog(node *MqLog) mqlogOption {
	return func(m *MqLogMutation) {
		m.oldValue = func(context.Context) (*MqLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MqLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MqLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MqLog entities.
func (m *MqLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MqLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MqLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MqLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMessageID sets the "message_id" field.
func (m *MqLogMutation) SetMessageID(s string) {
	m.message_id = &s
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *MqLogMutation) MessageID() (r string, exists bool) {
	v := m.message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the MqLog entity.
// If the MqLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MqLogMutation) OldMessageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *MqLogMutation) ResetMessageID() {
	m.message_id = nil
}

// SetPriority sets the "priority" field.
func (m *MqLogMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *MqLogMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the MqLog entity.
// If the MqLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MqLogMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *MqLogMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *MqLogMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *MqLogMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetIsProcessing sets the "is_processing" field.
func (m *MqLogMutation) SetIsProcessing(b bool) {
	m.is_processing = &b
}

// IsProcessing returns the value of the "is_processing" field in the mutation.
func (m *MqLogMutation) IsProcessing() (r bool, exists bool) {
	v := m.is_processing
	if v == nil {
		return
	}
	return *v, true
}

// OldIsProcessing returns the old "is_processing" field's value of the MqLog entity.
// If the MqLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MqLogMutation) OldIsProcessing(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsProcessing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsProcessing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsProcessing: %w", err)
	}
	return oldValue.IsProcessing, nil
}

// ResetIsProcessing resets all changes to the "is_processing" field.
func (m *MqLogMutation) ResetIsProcessing() {
	m.is_processing = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MqLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MqLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MqLog entity.
// If the MqLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MqLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MqLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MqLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MqLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MqLog entity.
// If the MqLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MqLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MqLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the MqLogMutation builder.
func (m *MqLogMutation) Where(ps ...predicate.MqLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MqLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MqLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MqLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MqLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MqLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MqLog).
func (m *MqLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MqLogMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.message_id != nil {
		fields = append(fields, mqlog.FieldMessageID)
	}
	if m.priority != nil {
		fields = append(fields, mqlog.FieldPriority)
	}
	if m.is_processing != nil {
		fields = append(fields, mqlog.FieldIsProcessing)
	}
	if m.created_at != nil {
		fields = append(fields, mqlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mqlog.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MqLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mqlog.FieldMessageID:
		return m.MessageID()
	case mqlog.FieldPriority:
		return m.Priority()
	case mqlog.FieldIsProcessing:
		return m.IsProcessing()
	case mqlog.FieldCreatedAt:
		return m.CreatedAt()
	case mqlog.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MqLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mqlog.FieldMessageID:
		return m.OldMessageID(ctx)
	case mqlog.FieldPriority:
		return m.OldPriority(ctx)
	case mqlog.FieldIsProcessing:
		return m.OldIsProcessing(ctx)
	case mqlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mqlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MqLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MqLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mqlog.FieldMessageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	case mqlog.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case mqlog.FieldIsProcessing:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsProcessing(v)
		return nil
	case mqlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mqlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MqLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MqLogMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, mqlog.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MqLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mqlog.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MqLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mqlog.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown MqLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MqLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MqLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MqLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MqLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MqLogMutation) ResetField(name string) error {
	switch name {
	case mqlog.FieldMessageID:
		m.ResetMessageID()
		return nil
	case mqlog.FieldPriority:
		m.ResetPriority()
		return nil
	case mqlog.FieldIsProcessing:
		m.ResetIsProcessing()
		return nil
	case mqlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mqlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MqLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MqLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MqLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MqLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MqLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MqLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MqLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MqLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MqLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MqLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MqLog edge %s", name)
}

// NegativePromptMutation represents an operation that mutates the NegativePrompt nodes in the graph.
type NegativePromptMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	text               *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	done               bool
	oldValue           func(context.Context) (*NegativePrompt, error)
	predicates         []predicate.NegativePrompt
}

var _ ent.Mutation = (*NegativePromptMutation)(nil)

// negativepromptOption allows management of the mutation configuration using functional options.
type negativepromptOption func(*NegativePromptMutation)

// newNegativePromptMutation creates new mutation for the NegativePrompt entity.
func newNegativePromptMutation(c config, op Op, opts ...negativepromptOption) *NegativePromptMutation {
	m := &NegativePromptMutation{
		config:        c,
		op:            op,
		typ:           TypeNegativePrompt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNegativePromptID sets the ID field of the mutation.
func withNegativePromptID(id uuid.UUID) negativepromptOption {
	return func(m *NegativePromptMutation) {
		var (
			err   error
			once  sync.Once
			value *NegativePrompt
		)
		m.oldValue = func(ctx context.Context) (*NegativePrompt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NegativePrompt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNegativePrompt sets the old NegativePrompt of the mutation.
func withNegativePrompt(node *NegativePrompt) negativepromptOption {
	return func(m *NegativePromptMutation) {
		m.oldValue = func(context.Context) (*NegativePrompt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NegativePromptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NegativePromptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NegativePrompt entities.
func (m *NegativePromptMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NegativePromptMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NegativePromptMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NegativePrompt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *NegativePromptMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *NegativePromptMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the NegativePrompt entity.
// If the NegativePrompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NegativePromptMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *NegativePromptMutation) ResetText() {
	m.text = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NegativePromptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NegativePromptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NegativePrompt entity.
// If the NegativePrompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NegativePromptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NegativePromptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NegativePromptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NegativePromptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NegativePrompt entity.
// If the NegativePrompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NegativePromptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NegativePromptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *NegativePromptMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *NegativePromptMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *NegativePromptMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *NegativePromptMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *NegativePromptMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *NegativePromptMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *NegativePromptMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// Where appends a list predicates to the NegativePromptMutation builder.
func (m *NegativePromptMutation) Where(ps ...predicate.NegativePrompt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NegativePromptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NegativePromptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NegativePrompt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NegativePromptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NegativePromptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NegativePrompt).
func (m *NegativePromptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NegativePromptMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.text != nil {
		fields = append(fields, negativeprompt.FieldText)
	}
	if m.created_at != nil {
		fields = append(fields, negativeprompt.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, negativeprompt.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NegativePromptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case negativeprompt.FieldText:
		return m.Text()
	case negativeprompt.FieldCreatedAt:
		return m.CreatedAt()
	case negativeprompt.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NegativePromptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case negativeprompt.FieldText:
		return m.OldText(ctx)
	case negativeprompt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case negativeprompt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NegativePrompt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NegativePromptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case negativeprompt.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case negativeprompt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case negativeprompt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NegativePrompt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NegativePromptMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NegativePromptMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NegativePromptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NegativePrompt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NegativePromptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NegativePromptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NegativePromptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NegativePrompt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NegativePromptMutation) ResetField(name string) error {
	switch name {
	case negativeprompt.FieldText:
		m.ResetText()
		return nil
	case negativeprompt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case negativeprompt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NegativePrompt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NegativePromptMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.generations != nil {
		edges = append(edges, negativeprompt.EdgeGenerations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NegativePromptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case negativeprompt.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NegativePromptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgenerations != nil {
		edges = append(edges, negativeprompt.EdgeGenerations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NegativePromptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case negativeprompt.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NegativePromptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenerations {
		edges = append(edges, negativeprompt.EdgeGenerations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NegativePromptMutation) EdgeCleared(name string) bool {
	switch name {
	case negativeprompt.EdgeGenerations:
		return m.clearedgenerations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NegativePromptMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NegativePrompt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NegativePromptMutation) ResetEdge(name string) error {
	switch name {
	case negativeprompt.EdgeGenerations:
		m.ResetGenerations()
		return nil
	}
	return fmt.Errorf("unknown NegativePrompt edge %s", name)
}

// PromptMutation represents an operation that mutates the Prompt nodes in the graph.
type PromptMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	text               *string
	_type              *prompt.Type
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	voiceovers         map[uuid.UUID]struct{}
	removedvoiceovers  map[uuid.UUID]struct{}
	clearedvoiceovers  bool
	done               bool
	oldValue           func(context.Context) (*Prompt, error)
	predicates         []predicate.Prompt
}

var _ ent.Mutation = (*PromptMutation)(nil)

// promptOption allows management of the mutation configuration using functional options.
type promptOption func(*PromptMutation)

// newPromptMutation creates new mutation for the Prompt entity.
func newPromptMutation(c config, op Op, opts ...promptOption) *PromptMutation {
	m := &PromptMutation{
		config:        c,
		op:            op,
		typ:           TypePrompt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromptID sets the ID field of the mutation.
func withPromptID(id uuid.UUID) promptOption {
	return func(m *PromptMutation) {
		var (
			err   error
			once  sync.Once
			value *Prompt
		)
		m.oldValue = func(ctx context.Context) (*Prompt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prompt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrompt sets the old Prompt of the mutation.
func withPrompt(node *Prompt) promptOption {
	return func(m *PromptMutation) {
		m.oldValue = func(context.Context) (*Prompt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Prompt entities.
func (m *PromptMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromptMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromptMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Prompt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *PromptMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *PromptMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *PromptMutation) ResetText() {
	m.text = nil
}

// SetType sets the "type" field.
func (m *PromptMutation) SetType(pr prompt.Type) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *PromptMutation) GetType() (r prompt.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldType(ctx context.Context) (v prompt.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PromptMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PromptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *PromptMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *PromptMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *PromptMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *PromptMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *PromptMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *PromptMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *PromptMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// AddVoiceoverIDs adds the "voiceovers" edge to the Voiceover entity by ids.
func (m *PromptMutation) AddVoiceoverIDs(ids ...uuid.UUID) {
	if m.voiceovers == nil {
		m.voiceovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.voiceovers[ids[i]] = struct{}{}
	}
}

// ClearVoiceovers clears the "voiceovers" edge to the Voiceover entity.
func (m *PromptMutation) ClearVoiceovers() {
	m.clearedvoiceovers = true
}

// VoiceoversCleared reports if the "voiceovers" edge to the Voiceover entity was cleared.
func (m *PromptMutation) VoiceoversCleared() bool {
	return m.clearedvoiceovers
}

// RemoveVoiceoverIDs removes the "voiceovers" edge to the Voiceover entity by IDs.
func (m *PromptMutation) RemoveVoiceoverIDs(ids ...uuid.UUID) {
	if m.removedvoiceovers == nil {
		m.removedvoiceovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.voiceovers, ids[i])
		m.removedvoiceovers[ids[i]] = struct{}{}
	}
}

// RemovedVoiceovers returns the removed IDs of the "voiceovers" edge to the Voiceover entity.
func (m *PromptMutation) RemovedVoiceoversIDs() (ids []uuid.UUID) {
	for id := range m.removedvoiceovers {
		ids = append(ids, id)
	}
	return
}

// VoiceoversIDs returns the "voiceovers" edge IDs in the mutation.
func (m *PromptMutation) VoiceoversIDs() (ids []uuid.UUID) {
	for id := range m.voiceovers {
		ids = append(ids, id)
	}
	return
}

// ResetVoiceovers resets all changes to the "voiceovers" edge.
func (m *PromptMutation) ResetVoiceovers() {
	m.voiceovers = nil
	m.clearedvoiceovers = false
	m.removedvoiceovers = nil
}

// Where appends a list predicates to the PromptMutation builder.
func (m *PromptMutation) Where(ps ...predicate.Prompt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Prompt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Prompt).
func (m *PromptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromptMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.text != nil {
		fields = append(fields, prompt.FieldText)
	}
	if m._type != nil {
		fields = append(fields, prompt.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, prompt.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, prompt.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prompt.FieldText:
		return m.Text()
	case prompt.FieldType:
		return m.GetType()
	case prompt.FieldCreatedAt:
		return m.CreatedAt()
	case prompt.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prompt.FieldText:
		return m.OldText(ctx)
	case prompt.FieldType:
		return m.OldType(ctx)
	case prompt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prompt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Prompt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prompt.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case prompt.FieldType:
		v, ok := value.(prompt.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case prompt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prompt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromptMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromptMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Prompt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prompt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromptMutation) ResetField(name string) error {
	switch name {
	case prompt.FieldText:
		m.ResetText()
		return nil
	case prompt.FieldType:
		m.ResetType()
		return nil
	case prompt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prompt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromptMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.generations != nil {
		edges = append(edges, prompt.EdgeGenerations)
	}
	if m.voiceovers != nil {
		edges = append(edges, prompt.EdgeVoiceovers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	case prompt.EdgeVoiceovers:
		ids := make([]ent.Value, 0, len(m.voiceovers))
		for id := range m.voiceovers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgenerations != nil {
		edges = append(edges, prompt.EdgeGenerations)
	}
	if m.removedvoiceovers != nil {
		edges = append(edges, prompt.EdgeVoiceovers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	case prompt.EdgeVoiceovers:
		ids := make([]ent.Value, 0, len(m.removedvoiceovers))
		for id := range m.removedvoiceovers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgenerations {
		edges = append(edges, prompt.EdgeGenerations)
	}
	if m.clearedvoiceovers {
		edges = append(edges, prompt.EdgeVoiceovers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromptMutation) EdgeCleared(name string) bool {
	switch name {
	case prompt.EdgeGenerations:
		return m.clearedgenerations
	case prompt.EdgeVoiceovers:
		return m.clearedvoiceovers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromptMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prompt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromptMutation) ResetEdge(name string) error {
	switch name {
	case prompt.EdgeGenerations:
		m.ResetGenerations()
		return nil
	case prompt.EdgeVoiceovers:
		m.ResetVoiceovers()
		return nil
	}
	return fmt.Errorf("unknown Prompt edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	users         map[uuid.UUID]struct{}
	removedusers  map[uuid.UUID]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Role, error)
	predicates    []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uuid.UUID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SchedulerMutation represents an operation that mutates the Scheduler nodes in the graph.
type SchedulerMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	name_in_worker           *string
	is_active                *bool
	is_default               *bool
	is_hidden                *bool
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	generations              map[uuid.UUID]struct{}
	removedgenerations       map[uuid.UUID]struct{}
	clearedgenerations       bool
	generation_models        map[uuid.UUID]struct{}
	removedgeneration_models map[uuid.UUID]struct{}
	clearedgeneration_models bool
	done                     bool
	oldValue                 func(context.Context) (*Scheduler, error)
	predicates               []predicate.Scheduler
}

var _ ent.Mutation = (*SchedulerMutation)(nil)

// schedulerOption allows management of the mutation configuration using functional options.
type schedulerOption func(*SchedulerMutation)

// newSchedulerMutation creates new mutation for the Scheduler entity.
func newSchedulerMutation(c config, op Op, opts ...schedulerOption) *SchedulerMutation {
	m := &SchedulerMutation{
		config:        c,
		op:            op,
		typ:           TypeScheduler,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchedulerID sets the ID field of the mutation.
func withSchedulerID(id uuid.UUID) schedulerOption {
	return func(m *SchedulerMutation) {
		var (
			err   error
			once  sync.Once
			value *Scheduler
		)
		m.oldValue = func(ctx context.Context) (*Scheduler, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scheduler.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheduler sets the old Scheduler of the mutation.
func withScheduler(node *Scheduler) schedulerOption {
	return func(m *SchedulerMutation) {
		m.oldValue = func(context.Context) (*Scheduler, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchedulerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchedulerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Scheduler entities.
func (m *SchedulerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchedulerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchedulerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Scheduler.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameInWorker sets the "name_in_worker" field.
func (m *SchedulerMutation) SetNameInWorker(s string) {
	m.name_in_worker = &s
}

// NameInWorker returns the value of the "name_in_worker" field in the mutation.
func (m *SchedulerMutation) NameInWorker() (r string, exists bool) {
	v := m.name_in_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldNameInWorker returns the old "name_in_worker" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldNameInWorker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameInWorker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameInWorker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameInWorker: %w", err)
	}
	return oldValue.NameInWorker, nil
}

// ResetNameInWorker resets all changes to the "name_in_worker" field.
func (m *SchedulerMutation) ResetNameInWorker() {
	m.name_in_worker = nil
}

// SetIsActive sets the "is_active" field.
func (m *SchedulerMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *SchedulerMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *SchedulerMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsDefault sets the "is_default" field.
func (m *SchedulerMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *SchedulerMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *SchedulerMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *SchedulerMutation) SetIsHidden(b bool) {
	m.is_hidden = &b
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *SchedulerMutation) IsHidden() (r bool, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *SchedulerMutation) ResetIsHidden() {
	m.is_hidden = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SchedulerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SchedulerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SchedulerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SchedulerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SchedulerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SchedulerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *SchedulerMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *SchedulerMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *SchedulerMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *SchedulerMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *SchedulerMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *SchedulerMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *SchedulerMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// AddGenerationModelIDs adds the "generation_models" edge to the GenerationModel entity by ids.
func (m *SchedulerMutation) AddGenerationModelIDs(ids ...uuid.UUID) {
	if m.generation_models == nil {
		m.generation_models = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generation_models[ids[i]] = struct{}{}
	}
}

// ClearGenerationModels clears the "generation_models" edge to the GenerationModel entity.
func (m *SchedulerMutation) ClearGenerationModels() {
	m.clearedgeneration_models = true
}

// GenerationModelsCleared reports if the "generation_models" edge to the GenerationModel entity was cleared.
func (m *SchedulerMutation) GenerationModelsCleared() bool {
	return m.clearedgeneration_models
}

// RemoveGenerationModelIDs removes the "generation_models" edge to the GenerationModel entity by IDs.
func (m *SchedulerMutation) RemoveGenerationModelIDs(ids ...uuid.UUID) {
	if m.removedgeneration_models == nil {
		m.removedgeneration_models = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generation_models, ids[i])
		m.removedgeneration_models[ids[i]] = struct{}{}
	}
}

// RemovedGenerationModels returns the removed IDs of the "generation_models" edge to the GenerationModel entity.
func (m *SchedulerMutation) RemovedGenerationModelsIDs() (ids []uuid.UUID) {
	for id := range m.removedgeneration_models {
		ids = append(ids, id)
	}
	return
}

// GenerationModelsIDs returns the "generation_models" edge IDs in the mutation.
func (m *SchedulerMutation) GenerationModelsIDs() (ids []uuid.UUID) {
	for id := range m.generation_models {
		ids = append(ids, id)
	}
	return
}

// ResetGenerationModels resets all changes to the "generation_models" edge.
func (m *SchedulerMutation) ResetGenerationModels() {
	m.generation_models = nil
	m.clearedgeneration_models = false
	m.removedgeneration_models = nil
}

// Where appends a list predicates to the SchedulerMutation builder.
func (m *SchedulerMutation) Where(ps ...predicate.Scheduler) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchedulerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchedulerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Scheduler, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchedulerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchedulerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Scheduler).
func (m *SchedulerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchedulerMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name_in_worker != nil {
		fields = append(fields, scheduler.FieldNameInWorker)
	}
	if m.is_active != nil {
		fields = append(fields, scheduler.FieldIsActive)
	}
	if m.is_default != nil {
		fields = append(fields, scheduler.FieldIsDefault)
	}
	if m.is_hidden != nil {
		fields = append(fields, scheduler.FieldIsHidden)
	}
	if m.created_at != nil {
		fields = append(fields, scheduler.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, scheduler.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchedulerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scheduler.FieldNameInWorker:
		return m.NameInWorker()
	case scheduler.FieldIsActive:
		return m.IsActive()
	case scheduler.FieldIsDefault:
		return m.IsDefault()
	case scheduler.FieldIsHidden:
		return m.IsHidden()
	case scheduler.FieldCreatedAt:
		return m.CreatedAt()
	case scheduler.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchedulerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scheduler.FieldNameInWorker:
		return m.OldNameInWorker(ctx)
	case scheduler.FieldIsActive:
		return m.OldIsActive(ctx)
	case scheduler.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case scheduler.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case scheduler.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case scheduler.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Scheduler field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchedulerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scheduler.FieldNameInWorker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameInWorker(v)
		return nil
	case scheduler.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case scheduler.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case scheduler.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case scheduler.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case scheduler.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Scheduler field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchedulerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchedulerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchedulerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Scheduler numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchedulerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchedulerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchedulerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Scheduler nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchedulerMutation) ResetField(name string) error {
	switch name {
	case scheduler.FieldNameInWorker:
		m.ResetNameInWorker()
		return nil
	case scheduler.FieldIsActive:
		m.ResetIsActive()
		return nil
	case scheduler.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case scheduler.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case scheduler.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case scheduler.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Scheduler field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchedulerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.generations != nil {
		edges = append(edges, scheduler.EdgeGenerations)
	}
	if m.generation_models != nil {
		edges = append(edges, scheduler.EdgeGenerationModels)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchedulerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scheduler.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	case scheduler.EdgeGenerationModels:
		ids := make([]ent.Value, 0, len(m.generation_models))
		for id := range m.generation_models {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchedulerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgenerations != nil {
		edges = append(edges, scheduler.EdgeGenerations)
	}
	if m.removedgeneration_models != nil {
		edges = append(edges, scheduler.EdgeGenerationModels)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchedulerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case scheduler.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	case scheduler.EdgeGenerationModels:
		ids := make([]ent.Value, 0, len(m.removedgeneration_models))
		for id := range m.removedgeneration_models {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchedulerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgenerations {
		edges = append(edges, scheduler.EdgeGenerations)
	}
	if m.clearedgeneration_models {
		edges = append(edges, scheduler.EdgeGenerationModels)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchedulerMutation) EdgeCleared(name string) bool {
	switch name {
	case scheduler.EdgeGenerations:
		return m.clearedgenerations
	case scheduler.EdgeGenerationModels:
		return m.clearedgeneration_models
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchedulerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Scheduler unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchedulerMutation) ResetEdge(name string) error {
	switch name {
	case scheduler.EdgeGenerations:
		m.ResetGenerations()
		return nil
	case scheduler.EdgeGenerationModels:
		m.ResetGenerationModels()
		return nil
	}
	return fmt.Errorf("unknown Scheduler edge %s", name)
}

// TipLogMutation represents an operation that mutates the TipLog nodes in the graph.
type TipLogMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	amount               *int32
	addamount            *int32
	tipped_to_discord_id *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	tips_received        *uuid.UUID
	clearedtips_received bool
	tips_given           *uuid.UUID
	clearedtips_given    bool
	done                 bool
	oldValue             func(context.Context) (*TipLog, error)
	predicates           []predicate.TipLog
}

var _ ent.Mutation = (*TipLogMutation)(nil)

// tiplogOption allows management of the mutation configuration using functional options.
type tiplogOption func(*TipLogMutation)

// newTipLogMutation creates new mutation for the TipLog entity.
func newTipLogMutation(c config, op Op, opts ...tiplogOption) *TipLogMutation {
	m := &TipLogMutation{
		config:        c,
		op:            op,
		typ:           TypeTipLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTipLogID sets the ID field of the mutation.
func withTipLogID(id uuid.UUID) tiplogOption {
	return func(m *TipLogMutation) {
		var (
			err   error
			once  sync.Once
			value *TipLog
		)
		m.oldValue = func(ctx context.Context) (*TipLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TipLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTipLog sets the old TipLog of the mutation.
func withTipLog(node *TipLog) tiplogOption {
	return func(m *TipLogMutation) {
		m.oldValue = func(context.Context) (*TipLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TipLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TipLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TipLog entities.
func (m *TipLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TipLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TipLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TipLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *TipLogMutation) SetAmount(i int32) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TipLogMutation) Amount() (r int32, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TipLog entity.
// If the TipLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TipLogMutation) OldAmount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *TipLogMutation) AddAmount(i int32) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TipLogMutation) AddedAmount() (r int32, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TipLogMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetTippedToDiscordID sets the "tipped_to_discord_id" field.
func (m *TipLogMutation) SetTippedToDiscordID(s string) {
	m.tipped_to_discord_id = &s
}

// TippedToDiscordID returns the value of the "tipped_to_discord_id" field in the mutation.
func (m *TipLogMutation) TippedToDiscordID() (r string, exists bool) {
	v := m.tipped_to_discord_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTippedToDiscordID returns the old "tipped_to_discord_id" field's value of the TipLog entity.
// If the TipLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TipLogMutation) OldTippedToDiscordID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTippedToDiscordID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTippedToDiscordID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTippedToDiscordID: %w", err)
	}
	return oldValue.TippedToDiscordID, nil
}

// ResetTippedToDiscordID resets all changes to the "tipped_to_discord_id" field.
func (m *TipLogMutation) ResetTippedToDiscordID() {
	m.tipped_to_discord_id = nil
}

// SetTippedBy sets the "tipped_by" field.
func (m *TipLogMutation) SetTippedBy(u uuid.UUID) {
	m.tips_given = &u
}

// TippedBy returns the value of the "tipped_by" field in the mutation.
func (m *TipLogMutation) TippedBy() (r uuid.UUID, exists bool) {
	v := m.tips_given
	if v == nil {
		return
	}
	return *v, true
}

// OldTippedBy returns the old "tipped_by" field's value of the TipLog entity.
// If the TipLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TipLogMutation) OldTippedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTippedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTippedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTippedBy: %w", err)
	}
	return oldValue.TippedBy, nil
}

// ResetTippedBy resets all changes to the "tipped_by" field.
func (m *TipLogMutation) ResetTippedBy() {
	m.tips_given = nil
}

// SetTippedTo sets the "tipped_to" field.
func (m *TipLogMutation) SetTippedTo(u uuid.UUID) {
	m.tips_received = &u
}

// TippedTo returns the value of the "tipped_to" field in the mutation.
func (m *TipLogMutation) TippedTo() (r uuid.UUID, exists bool) {
	v := m.tips_received
	if v == nil {
		return
	}
	return *v, true
}

// OldTippedTo returns the old "tipped_to" field's value of the TipLog entity.
// If the TipLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TipLogMutation) OldTippedTo(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTippedTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTippedTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTippedTo: %w", err)
	}
	return oldValue.TippedTo, nil
}

// ClearTippedTo clears the value of the "tipped_to" field.
func (m *TipLogMutation) ClearTippedTo() {
	m.tips_received = nil
	m.clearedFields[tiplog.FieldTippedTo] = struct{}{}
}

// TippedToCleared returns if the "tipped_to" field was cleared in this mutation.
func (m *TipLogMutation) TippedToCleared() bool {
	_, ok := m.clearedFields[tiplog.FieldTippedTo]
	return ok
}

// ResetTippedTo resets all changes to the "tipped_to" field.
func (m *TipLogMutation) ResetTippedTo() {
	m.tips_received = nil
	delete(m.clearedFields, tiplog.FieldTippedTo)
}

// SetCreatedAt sets the "created_at" field.
func (m *TipLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TipLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TipLog entity.
// If the TipLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TipLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TipLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TipLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TipLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TipLog entity.
// If the TipLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TipLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TipLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTipsReceivedID sets the "tips_received" edge to the User entity by id.
func (m *TipLogMutation) SetTipsReceivedID(id uuid.UUID) {
	m.tips_received = &id
}

// ClearTipsReceived clears the "tips_received" edge to the User entity.
func (m *TipLogMutation) ClearTipsReceived() {
	m.clearedtips_received = true
}

// TipsReceivedCleared reports if the "tips_received" edge to the User entity was cleared.
func (m *TipLogMutation) TipsReceivedCleared() bool {
	return m.TippedToCleared() || m.clearedtips_received
}

// TipsReceivedID returns the "tips_received" edge ID in the mutation.
func (m *TipLogMutation) TipsReceivedID() (id uuid.UUID, exists bool) {
	if m.tips_received != nil {
		return *m.tips_received, true
	}
	return
}

// TipsReceivedIDs returns the "tips_received" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TipsReceivedID instead. It exists only for internal usage by the builders.
func (m *TipLogMutation) TipsReceivedIDs() (ids []uuid.UUID) {
	if id := m.tips_received; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTipsReceived resets all changes to the "tips_received" edge.
func (m *TipLogMutation) ResetTipsReceived() {
	m.tips_received = nil
	m.clearedtips_received = false
}

// SetTipsGivenID sets the "tips_given" edge to the User entity by id.
func (m *TipLogMutation) SetTipsGivenID(id uuid.UUID) {
	m.tips_given = &id
}

// ClearTipsGiven clears the "tips_given" edge to the User entity.
func (m *TipLogMutation) ClearTipsGiven() {
	m.clearedtips_given = true
}

// TipsGivenCleared reports if the "tips_given" edge to the User entity was cleared.
func (m *TipLogMutation) TipsGivenCleared() bool {
	return m.clearedtips_given
}

// TipsGivenID returns the "tips_given" edge ID in the mutation.
func (m *TipLogMutation) TipsGivenID() (id uuid.UUID, exists bool) {
	if m.tips_given != nil {
		return *m.tips_given, true
	}
	return
}

// TipsGivenIDs returns the "tips_given" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TipsGivenID instead. It exists only for internal usage by the builders.
func (m *TipLogMutation) TipsGivenIDs() (ids []uuid.UUID) {
	if id := m.tips_given; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTipsGiven resets all changes to the "tips_given" edge.
func (m *TipLogMutation) ResetTipsGiven() {
	m.tips_given = nil
	m.clearedtips_given = false
}

// Where appends a list predicates to the TipLogMutation builder.
func (m *TipLogMutation) Where(ps ...predicate.TipLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TipLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TipLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TipLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TipLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TipLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TipLog).
func (m *TipLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TipLogMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.amount != nil {
		fields = append(fields, tiplog.FieldAmount)
	}
	if m.tipped_to_discord_id != nil {
		fields = append(fields, tiplog.FieldTippedToDiscordID)
	}
	if m.tips_given != nil {
		fields = append(fields, tiplog.FieldTippedBy)
	}
	if m.tips_received != nil {
		fields = append(fields, tiplog.FieldTippedTo)
	}
	if m.created_at != nil {
		fields = append(fields, tiplog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tiplog.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TipLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tiplog.FieldAmount:
		return m.Amount()
	case tiplog.FieldTippedToDiscordID:
		return m.TippedToDiscordID()
	case tiplog.FieldTippedBy:
		return m.TippedBy()
	case tiplog.FieldTippedTo:
		return m.TippedTo()
	case tiplog.FieldCreatedAt:
		return m.CreatedAt()
	case tiplog.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TipLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tiplog.FieldAmount:
		return m.OldAmount(ctx)
	case tiplog.FieldTippedToDiscordID:
		return m.OldTippedToDiscordID(ctx)
	case tiplog.FieldTippedBy:
		return m.OldTippedBy(ctx)
	case tiplog.FieldTippedTo:
		return m.OldTippedTo(ctx)
	case tiplog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tiplog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TipLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TipLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tiplog.FieldAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case tiplog.FieldTippedToDiscordID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTippedToDiscordID(v)
		return nil
	case tiplog.FieldTippedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTippedBy(v)
		return nil
	case tiplog.FieldTippedTo:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTippedTo(v)
		return nil
	case tiplog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tiplog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TipLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TipLogMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, tiplog.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TipLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tiplog.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TipLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tiplog.FieldAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown TipLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TipLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tiplog.FieldTippedTo) {
		fields = append(fields, tiplog.FieldTippedTo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TipLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TipLogMutation) ClearField(name string) error {
	switch name {
	case tiplog.FieldTippedTo:
		m.ClearTippedTo()
		return nil
	}
	return fmt.Errorf("unknown TipLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TipLogMutation) ResetField(name string) error {
	switch name {
	case tiplog.FieldAmount:
		m.ResetAmount()
		return nil
	case tiplog.FieldTippedToDiscordID:
		m.ResetTippedToDiscordID()
		return nil
	case tiplog.FieldTippedBy:
		m.ResetTippedBy()
		return nil
	case tiplog.FieldTippedTo:
		m.ResetTippedTo()
		return nil
	case tiplog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tiplog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TipLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TipLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tips_received != nil {
		edges = append(edges, tiplog.EdgeTipsReceived)
	}
	if m.tips_given != nil {
		edges = append(edges, tiplog.EdgeTipsGiven)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TipLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tiplog.EdgeTipsReceived:
		if id := m.tips_received; id != nil {
			return []ent.Value{*id}
		}
	case tiplog.EdgeTipsGiven:
		if id := m.tips_given; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TipLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TipLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TipLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtips_received {
		edges = append(edges, tiplog.EdgeTipsReceived)
	}
	if m.clearedtips_given {
		edges = append(edges, tiplog.EdgeTipsGiven)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TipLogMutation) EdgeCleared(name string) bool {
	switch name {
	case tiplog.EdgeTipsReceived:
		return m.clearedtips_received
	case tiplog.EdgeTipsGiven:
		return m.clearedtips_given
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TipLogMutation) ClearEdge(name string) error {
	switch name {
	case tiplog.EdgeTipsReceived:
		m.ClearTipsReceived()
		return nil
	case tiplog.EdgeTipsGiven:
		m.ClearTipsGiven()
		return nil
	}
	return fmt.Errorf("unknown TipLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TipLogMutation) ResetEdge(name string) error {
	switch name {
	case tiplog.EdgeTipsReceived:
		m.ResetTipsReceived()
		return nil
	case tiplog.EdgeTipsGiven:
		m.ResetTipsGiven()
		return nil
	}
	return fmt.Errorf("unknown TipLog edge %s", name)
}

// UpscaleMutation represents an operation that mutates the Upscale nodes in the graph.
type UpscaleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	width                  *int32
	addwidth               *int32
	height                 *int32
	addheight              *int32
	scale                  *int32
	addscale               *int32
	country_code           *string
	status                 *upscale.Status
	failure_reason         *string
	stripe_product_id      *string
	system_generated       *bool
	source_type            *enttypes.SourceType
	started_at             *time.Time
	completed_at           *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	user                   *uuid.UUID
	cleareduser            bool
	device_info            *uuid.UUID
	cleareddevice_info     bool
	upscale_models         *uuid.UUID
	clearedupscale_models  bool
	api_tokens             *uuid.UUID
	clearedapi_tokens      bool
	upscale_outputs        map[uuid.UUID]struct{}
	removedupscale_outputs map[uuid.UUID]struct{}
	clearedupscale_outputs bool
	done                   bool
	oldValue               func(context.Context) (*Upscale, error)
	predicates             []predicate.Upscale
}

var _ ent.Mutation = (*UpscaleMutation)(nil)

// upscaleOption allows management of the mutation configuration using functional options.
type upscaleOption func(*UpscaleMutation)

// newUpscaleMutation creates new mutation for the Upscale entity.
func newUpscaleMutation(c config, op Op, opts ...upscaleOption) *UpscaleMutation {
	m := &UpscaleMutation{
		config:        c,
		op:            op,
		typ:           TypeUpscale,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpscaleID sets the ID field of the mutation.
func withUpscaleID(id uuid.UUID) upscaleOption {
	return func(m *UpscaleMutation) {
		var (
			err   error
			once  sync.Once
			value *Upscale
		)
		m.oldValue = func(ctx context.Context) (*Upscale, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Upscale.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpscale sets the old Upscale of the mutation.
func withUpscale(node *Upscale) upscaleOption {
	return func(m *UpscaleMutation) {
		m.oldValue = func(context.Context) (*Upscale, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpscaleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpscaleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Upscale entities.
func (m *UpscaleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpscaleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpscaleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Upscale.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWidth sets the "width" field.
func (m *UpscaleMutation) SetWidth(i int32) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *UpscaleMutation) Width() (r int32, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldWidth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *UpscaleMutation) AddWidth(i int32) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *UpscaleMutation) AddedWidth() (r int32, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *UpscaleMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *UpscaleMutation) SetHeight(i int32) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *UpscaleMutation) Height() (r int32, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldHeight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *UpscaleMutation) AddHeight(i int32) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *UpscaleMutation) AddedHeight() (r int32, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *UpscaleMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetScale sets the "scale" field.
func (m *UpscaleMutation) SetScale(i int32) {
	m.scale = &i
	m.addscale = nil
}

// Scale returns the value of the "scale" field in the mutation.
func (m *UpscaleMutation) Scale() (r int32, exists bool) {
	v := m.scale
	if v == nil {
		return
	}
	return *v, true
}

// OldScale returns the old "scale" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldScale(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScale: %w", err)
	}
	return oldValue.Scale, nil
}

// AddScale adds i to the "scale" field.
func (m *UpscaleMutation) AddScale(i int32) {
	if m.addscale != nil {
		*m.addscale += i
	} else {
		m.addscale = &i
	}
}

// AddedScale returns the value that was added to the "scale" field in this mutation.
func (m *UpscaleMutation) AddedScale() (r int32, exists bool) {
	v := m.addscale
	if v == nil {
		return
	}
	return *v, true
}

// ResetScale resets all changes to the "scale" field.
func (m *UpscaleMutation) ResetScale() {
	m.scale = nil
	m.addscale = nil
}

// SetCountryCode sets the "country_code" field.
func (m *UpscaleMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *UpscaleMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldCountryCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ClearCountryCode clears the value of the "country_code" field.
func (m *UpscaleMutation) ClearCountryCode() {
	m.country_code = nil
	m.clearedFields[upscale.FieldCountryCode] = struct{}{}
}

// CountryCodeCleared returns if the "country_code" field was cleared in this mutation.
func (m *UpscaleMutation) CountryCodeCleared() bool {
	_, ok := m.clearedFields[upscale.FieldCountryCode]
	return ok
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *UpscaleMutation) ResetCountryCode() {
	m.country_code = nil
	delete(m.clearedFields, upscale.FieldCountryCode)
}

// SetStatus sets the "status" field.
func (m *UpscaleMutation) SetStatus(u upscale.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UpscaleMutation) Status() (r upscale.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldStatus(ctx context.Context) (v upscale.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UpscaleMutation) ResetStatus() {
	m.status = nil
}

// SetFailureReason sets the "failure_reason" field.
func (m *UpscaleMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *UpscaleMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldFailureReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *UpscaleMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[upscale.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *UpscaleMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[upscale.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *UpscaleMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, upscale.FieldFailureReason)
}

// SetStripeProductID sets the "stripe_product_id" field.
func (m *UpscaleMutation) SetStripeProductID(s string) {
	m.stripe_product_id = &s
}

// StripeProductID returns the value of the "stripe_product_id" field in the mutation.
func (m *UpscaleMutation) StripeProductID() (r string, exists bool) {
	v := m.stripe_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeProductID returns the old "stripe_product_id" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldStripeProductID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeProductID: %w", err)
	}
	return oldValue.StripeProductID, nil
}

// ClearStripeProductID clears the value of the "stripe_product_id" field.
func (m *UpscaleMutation) ClearStripeProductID() {
	m.stripe_product_id = nil
	m.clearedFields[upscale.FieldStripeProductID] = struct{}{}
}

// StripeProductIDCleared returns if the "stripe_product_id" field was cleared in this mutation.
func (m *UpscaleMutation) StripeProductIDCleared() bool {
	_, ok := m.clearedFields[upscale.FieldStripeProductID]
	return ok
}

// ResetStripeProductID resets all changes to the "stripe_product_id" field.
func (m *UpscaleMutation) ResetStripeProductID() {
	m.stripe_product_id = nil
	delete(m.clearedFields, upscale.FieldStripeProductID)
}

// SetSystemGenerated sets the "system_generated" field.
func (m *UpscaleMutation) SetSystemGenerated(b bool) {
	m.system_generated = &b
}

// SystemGenerated returns the value of the "system_generated" field in the mutation.
func (m *UpscaleMutation) SystemGenerated() (r bool, exists bool) {
	v := m.system_generated
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemGenerated returns the old "system_generated" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldSystemGenerated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemGenerated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemGenerated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemGenerated: %w", err)
	}
	return oldValue.SystemGenerated, nil
}

// ResetSystemGenerated resets all changes to the "system_generated" field.
func (m *UpscaleMutation) ResetSystemGenerated() {
	m.system_generated = nil
}

// SetSourceType sets the "source_type" field.
func (m *UpscaleMutation) SetSourceType(et enttypes.SourceType) {
	m.source_type = &et
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *UpscaleMutation) SourceType() (r enttypes.SourceType, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldSourceType(ctx context.Context) (v enttypes.SourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *UpscaleMutation) ResetSourceType() {
	m.source_type = nil
}

// SetUserID sets the "user_id" field.
func (m *UpscaleMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UpscaleMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UpscaleMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceInfoID sets the "device_info_id" field.
func (m *UpscaleMutation) SetDeviceInfoID(u uuid.UUID) {
	m.device_info = &u
}

// DeviceInfoID returns the value of the "device_info_id" field in the mutation.
func (m *UpscaleMutation) DeviceInfoID() (r uuid.UUID, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfoID returns the old "device_info_id" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldDeviceInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfoID: %w", err)
	}
	return oldValue.DeviceInfoID, nil
}

// ResetDeviceInfoID resets all changes to the "device_info_id" field.
func (m *UpscaleMutation) ResetDeviceInfoID() {
	m.device_info = nil
}

// SetModelID sets the "model_id" field.
func (m *UpscaleMutation) SetModelID(u uuid.UUID) {
	m.upscale_models = &u
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *UpscaleMutation) ModelID() (r uuid.UUID, exists bool) {
	v := m.upscale_models
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldModelID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *UpscaleMutation) ResetModelID() {
	m.upscale_models = nil
}

// SetAPITokenID sets the "api_token_id" field.
func (m *UpscaleMutation) SetAPITokenID(u uuid.UUID) {
	m.api_tokens = &u
}

// APITokenID returns the value of the "api_token_id" field in the mutation.
func (m *UpscaleMutation) APITokenID() (r uuid.UUID, exists bool) {
	v := m.api_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldAPITokenID returns the old "api_token_id" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldAPITokenID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPITokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPITokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPITokenID: %w", err)
	}
	return oldValue.APITokenID, nil
}

// ClearAPITokenID clears the value of the "api_token_id" field.
func (m *UpscaleMutation) ClearAPITokenID() {
	m.api_tokens = nil
	m.clearedFields[upscale.FieldAPITokenID] = struct{}{}
}

// APITokenIDCleared returns if the "api_token_id" field was cleared in this mutation.
func (m *UpscaleMutation) APITokenIDCleared() bool {
	_, ok := m.clearedFields[upscale.FieldAPITokenID]
	return ok
}

// ResetAPITokenID resets all changes to the "api_token_id" field.
func (m *UpscaleMutation) ResetAPITokenID() {
	m.api_tokens = nil
	delete(m.clearedFields, upscale.FieldAPITokenID)
}

// SetStartedAt sets the "started_at" field.
func (m *UpscaleMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *UpscaleMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *UpscaleMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[upscale.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *UpscaleMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[upscale.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *UpscaleMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, upscale.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *UpscaleMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *UpscaleMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *UpscaleMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[upscale.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *UpscaleMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[upscale.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *UpscaleMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, upscale.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UpscaleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UpscaleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UpscaleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UpscaleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UpscaleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UpscaleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UpscaleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UpscaleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UpscaleMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UpscaleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearDeviceInfo clears the "device_info" edge to the DeviceInfo entity.
func (m *UpscaleMutation) ClearDeviceInfo() {
	m.cleareddevice_info = true
}

// DeviceInfoCleared reports if the "device_info" edge to the DeviceInfo entity was cleared.
func (m *UpscaleMutation) DeviceInfoCleared() bool {
	return m.cleareddevice_info
}

// DeviceInfoIDs returns the "device_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceInfoID instead. It exists only for internal usage by the builders.
func (m *UpscaleMutation) DeviceInfoIDs() (ids []uuid.UUID) {
	if id := m.device_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeviceInfo resets all changes to the "device_info" edge.
func (m *UpscaleMutation) ResetDeviceInfo() {
	m.device_info = nil
	m.cleareddevice_info = false
}

// SetUpscaleModelsID sets the "upscale_models" edge to the UpscaleModel entity by id.
func (m *UpscaleMutation) SetUpscaleModelsID(id uuid.UUID) {
	m.upscale_models = &id
}

// ClearUpscaleModels clears the "upscale_models" edge to the UpscaleModel entity.
func (m *UpscaleMutation) ClearUpscaleModels() {
	m.clearedupscale_models = true
}

// UpscaleModelsCleared reports if the "upscale_models" edge to the UpscaleModel entity was cleared.
func (m *UpscaleMutation) UpscaleModelsCleared() bool {
	return m.clearedupscale_models
}

// UpscaleModelsID returns the "upscale_models" edge ID in the mutation.
func (m *UpscaleMutation) UpscaleModelsID() (id uuid.UUID, exists bool) {
	if m.upscale_models != nil {
		return *m.upscale_models, true
	}
	return
}

// UpscaleModelsIDs returns the "upscale_models" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpscaleModelsID instead. It exists only for internal usage by the builders.
func (m *UpscaleMutation) UpscaleModelsIDs() (ids []uuid.UUID) {
	if id := m.upscale_models; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpscaleModels resets all changes to the "upscale_models" edge.
func (m *UpscaleMutation) ResetUpscaleModels() {
	m.upscale_models = nil
	m.clearedupscale_models = false
}

// SetAPITokensID sets the "api_tokens" edge to the ApiToken entity by id.
func (m *UpscaleMutation) SetAPITokensID(id uuid.UUID) {
	m.api_tokens = &id
}

// ClearAPITokens clears the "api_tokens" edge to the ApiToken entity.
func (m *UpscaleMutation) ClearAPITokens() {
	m.clearedapi_tokens = true
}

// APITokensCleared reports if the "api_tokens" edge to the ApiToken entity was cleared.
func (m *UpscaleMutation) APITokensCleared() bool {
	return m.APITokenIDCleared() || m.clearedapi_tokens
}

// APITokensID returns the "api_tokens" edge ID in the mutation.
func (m *UpscaleMutation) APITokensID() (id uuid.UUID, exists bool) {
	if m.api_tokens != nil {
		return *m.api_tokens, true
	}
	return
}

// APITokensIDs returns the "api_tokens" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// APITokensID instead. It exists only for internal usage by the builders.
func (m *UpscaleMutation) APITokensIDs() (ids []uuid.UUID) {
	if id := m.api_tokens; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAPITokens resets all changes to the "api_tokens" edge.
func (m *UpscaleMutation) ResetAPITokens() {
	m.api_tokens = nil
	m.clearedapi_tokens = false
}

// AddUpscaleOutputIDs adds the "upscale_outputs" edge to the UpscaleOutput entity by ids.
func (m *UpscaleMutation) AddUpscaleOutputIDs(ids ...uuid.UUID) {
	if m.upscale_outputs == nil {
		m.upscale_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscale_outputs[ids[i]] = struct{}{}
	}
}

// ClearUpscaleOutputs clears the "upscale_outputs" edge to the UpscaleOutput entity.
func (m *UpscaleMutation) ClearUpscaleOutputs() {
	m.clearedupscale_outputs = true
}

// UpscaleOutputsCleared reports if the "upscale_outputs" edge to the UpscaleOutput entity was cleared.
func (m *UpscaleMutation) UpscaleOutputsCleared() bool {
	return m.clearedupscale_outputs
}

// RemoveUpscaleOutputIDs removes the "upscale_outputs" edge to the UpscaleOutput entity by IDs.
func (m *UpscaleMutation) RemoveUpscaleOutputIDs(ids ...uuid.UUID) {
	if m.removedupscale_outputs == nil {
		m.removedupscale_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscale_outputs, ids[i])
		m.removedupscale_outputs[ids[i]] = struct{}{}
	}
}

// RemovedUpscaleOutputs returns the removed IDs of the "upscale_outputs" edge to the UpscaleOutput entity.
func (m *UpscaleMutation) RemovedUpscaleOutputsIDs() (ids []uuid.UUID) {
	for id := range m.removedupscale_outputs {
		ids = append(ids, id)
	}
	return
}

// UpscaleOutputsIDs returns the "upscale_outputs" edge IDs in the mutation.
func (m *UpscaleMutation) UpscaleOutputsIDs() (ids []uuid.UUID) {
	for id := range m.upscale_outputs {
		ids = append(ids, id)
	}
	return
}

// ResetUpscaleOutputs resets all changes to the "upscale_outputs" edge.
func (m *UpscaleMutation) ResetUpscaleOutputs() {
	m.upscale_outputs = nil
	m.clearedupscale_outputs = false
	m.removedupscale_outputs = nil
}

// Where appends a list predicates to the UpscaleMutation builder.
func (m *UpscaleMutation) Where(ps ...predicate.Upscale) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpscaleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpscaleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Upscale, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpscaleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpscaleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Upscale).
func (m *UpscaleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpscaleMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.width != nil {
		fields = append(fields, upscale.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, upscale.FieldHeight)
	}
	if m.scale != nil {
		fields = append(fields, upscale.FieldScale)
	}
	if m.country_code != nil {
		fields = append(fields, upscale.FieldCountryCode)
	}
	if m.status != nil {
		fields = append(fields, upscale.FieldStatus)
	}
	if m.failure_reason != nil {
		fields = append(fields, upscale.FieldFailureReason)
	}
	if m.stripe_product_id != nil {
		fields = append(fields, upscale.FieldStripeProductID)
	}
	if m.system_generated != nil {
		fields = append(fields, upscale.FieldSystemGenerated)
	}
	if m.source_type != nil {
		fields = append(fields, upscale.FieldSourceType)
	}
	if m.user != nil {
		fields = append(fields, upscale.FieldUserID)
	}
	if m.device_info != nil {
		fields = append(fields, upscale.FieldDeviceInfoID)
	}
	if m.upscale_models != nil {
		fields = append(fields, upscale.FieldModelID)
	}
	if m.api_tokens != nil {
		fields = append(fields, upscale.FieldAPITokenID)
	}
	if m.started_at != nil {
		fields = append(fields, upscale.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, upscale.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, upscale.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, upscale.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpscaleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upscale.FieldWidth:
		return m.Width()
	case upscale.FieldHeight:
		return m.Height()
	case upscale.FieldScale:
		return m.Scale()
	case upscale.FieldCountryCode:
		return m.CountryCode()
	case upscale.FieldStatus:
		return m.Status()
	case upscale.FieldFailureReason:
		return m.FailureReason()
	case upscale.FieldStripeProductID:
		return m.StripeProductID()
	case upscale.FieldSystemGenerated:
		return m.SystemGenerated()
	case upscale.FieldSourceType:
		return m.SourceType()
	case upscale.FieldUserID:
		return m.UserID()
	case upscale.FieldDeviceInfoID:
		return m.DeviceInfoID()
	case upscale.FieldModelID:
		return m.ModelID()
	case upscale.FieldAPITokenID:
		return m.APITokenID()
	case upscale.FieldStartedAt:
		return m.StartedAt()
	case upscale.FieldCompletedAt:
		return m.CompletedAt()
	case upscale.FieldCreatedAt:
		return m.CreatedAt()
	case upscale.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpscaleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upscale.FieldWidth:
		return m.OldWidth(ctx)
	case upscale.FieldHeight:
		return m.OldHeight(ctx)
	case upscale.FieldScale:
		return m.OldScale(ctx)
	case upscale.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case upscale.FieldStatus:
		return m.OldStatus(ctx)
	case upscale.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case upscale.FieldStripeProductID:
		return m.OldStripeProductID(ctx)
	case upscale.FieldSystemGenerated:
		return m.OldSystemGenerated(ctx)
	case upscale.FieldSourceType:
		return m.OldSourceType(ctx)
	case upscale.FieldUserID:
		return m.OldUserID(ctx)
	case upscale.FieldDeviceInfoID:
		return m.OldDeviceInfoID(ctx)
	case upscale.FieldModelID:
		return m.OldModelID(ctx)
	case upscale.FieldAPITokenID:
		return m.OldAPITokenID(ctx)
	case upscale.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case upscale.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case upscale.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case upscale.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Upscale field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upscale.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case upscale.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case upscale.FieldScale:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScale(v)
		return nil
	case upscale.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case upscale.FieldStatus:
		v, ok := value.(upscale.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case upscale.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case upscale.FieldStripeProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeProductID(v)
		return nil
	case upscale.FieldSystemGenerated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemGenerated(v)
		return nil
	case upscale.FieldSourceType:
		v, ok := value.(enttypes.SourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case upscale.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case upscale.FieldDeviceInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfoID(v)
		return nil
	case upscale.FieldModelID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case upscale.FieldAPITokenID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPITokenID(v)
		return nil
	case upscale.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case upscale.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case upscale.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case upscale.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Upscale field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpscaleMutation) AddedFields() []string {
	var fields []string
	if m.addwidth != nil {
		fields = append(fields, upscale.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, upscale.FieldHeight)
	}
	if m.addscale != nil {
		fields = append(fields, upscale.FieldScale)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpscaleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upscale.FieldWidth:
		return m.AddedWidth()
	case upscale.FieldHeight:
		return m.AddedHeight()
	case upscale.FieldScale:
		return m.AddedScale()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upscale.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case upscale.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case upscale.FieldScale:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScale(v)
		return nil
	}
	return fmt.Errorf("unknown Upscale numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpscaleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upscale.FieldCountryCode) {
		fields = append(fields, upscale.FieldCountryCode)
	}
	if m.FieldCleared(upscale.FieldFailureReason) {
		fields = append(fields, upscale.FieldFailureReason)
	}
	if m.FieldCleared(upscale.FieldStripeProductID) {
		fields = append(fields, upscale.FieldStripeProductID)
	}
	if m.FieldCleared(upscale.FieldAPITokenID) {
		fields = append(fields, upscale.FieldAPITokenID)
	}
	if m.FieldCleared(upscale.FieldStartedAt) {
		fields = append(fields, upscale.FieldStartedAt)
	}
	if m.FieldCleared(upscale.FieldCompletedAt) {
		fields = append(fields, upscale.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpscaleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpscaleMutation) ClearField(name string) error {
	switch name {
	case upscale.FieldCountryCode:
		m.ClearCountryCode()
		return nil
	case upscale.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	case upscale.FieldStripeProductID:
		m.ClearStripeProductID()
		return nil
	case upscale.FieldAPITokenID:
		m.ClearAPITokenID()
		return nil
	case upscale.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case upscale.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Upscale nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpscaleMutation) ResetField(name string) error {
	switch name {
	case upscale.FieldWidth:
		m.ResetWidth()
		return nil
	case upscale.FieldHeight:
		m.ResetHeight()
		return nil
	case upscale.FieldScale:
		m.ResetScale()
		return nil
	case upscale.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case upscale.FieldStatus:
		m.ResetStatus()
		return nil
	case upscale.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case upscale.FieldStripeProductID:
		m.ResetStripeProductID()
		return nil
	case upscale.FieldSystemGenerated:
		m.ResetSystemGenerated()
		return nil
	case upscale.FieldSourceType:
		m.ResetSourceType()
		return nil
	case upscale.FieldUserID:
		m.ResetUserID()
		return nil
	case upscale.FieldDeviceInfoID:
		m.ResetDeviceInfoID()
		return nil
	case upscale.FieldModelID:
		m.ResetModelID()
		return nil
	case upscale.FieldAPITokenID:
		m.ResetAPITokenID()
		return nil
	case upscale.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case upscale.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case upscale.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case upscale.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Upscale field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpscaleMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, upscale.EdgeUser)
	}
	if m.device_info != nil {
		edges = append(edges, upscale.EdgeDeviceInfo)
	}
	if m.upscale_models != nil {
		edges = append(edges, upscale.EdgeUpscaleModels)
	}
	if m.api_tokens != nil {
		edges = append(edges, upscale.EdgeAPITokens)
	}
	if m.upscale_outputs != nil {
		edges = append(edges, upscale.EdgeUpscaleOutputs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpscaleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case upscale.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case upscale.EdgeDeviceInfo:
		if id := m.device_info; id != nil {
			return []ent.Value{*id}
		}
	case upscale.EdgeUpscaleModels:
		if id := m.upscale_models; id != nil {
			return []ent.Value{*id}
		}
	case upscale.EdgeAPITokens:
		if id := m.api_tokens; id != nil {
			return []ent.Value{*id}
		}
	case upscale.EdgeUpscaleOutputs:
		ids := make([]ent.Value, 0, len(m.upscale_outputs))
		for id := range m.upscale_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpscaleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedupscale_outputs != nil {
		edges = append(edges, upscale.EdgeUpscaleOutputs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpscaleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case upscale.EdgeUpscaleOutputs:
		ids := make([]ent.Value, 0, len(m.removedupscale_outputs))
		for id := range m.removedupscale_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpscaleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, upscale.EdgeUser)
	}
	if m.cleareddevice_info {
		edges = append(edges, upscale.EdgeDeviceInfo)
	}
	if m.clearedupscale_models {
		edges = append(edges, upscale.EdgeUpscaleModels)
	}
	if m.clearedapi_tokens {
		edges = append(edges, upscale.EdgeAPITokens)
	}
	if m.clearedupscale_outputs {
		edges = append(edges, upscale.EdgeUpscaleOutputs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpscaleMutation) EdgeCleared(name string) bool {
	switch name {
	case upscale.EdgeUser:
		return m.cleareduser
	case upscale.EdgeDeviceInfo:
		return m.cleareddevice_info
	case upscale.EdgeUpscaleModels:
		return m.clearedupscale_models
	case upscale.EdgeAPITokens:
		return m.clearedapi_tokens
	case upscale.EdgeUpscaleOutputs:
		return m.clearedupscale_outputs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpscaleMutation) ClearEdge(name string) error {
	switch name {
	case upscale.EdgeUser:
		m.ClearUser()
		return nil
	case upscale.EdgeDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case upscale.EdgeUpscaleModels:
		m.ClearUpscaleModels()
		return nil
	case upscale.EdgeAPITokens:
		m.ClearAPITokens()
		return nil
	}
	return fmt.Errorf("unknown Upscale unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpscaleMutation) ResetEdge(name string) error {
	switch name {
	case upscale.EdgeUser:
		m.ResetUser()
		return nil
	case upscale.EdgeDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case upscale.EdgeUpscaleModels:
		m.ResetUpscaleModels()
		return nil
	case upscale.EdgeAPITokens:
		m.ResetAPITokens()
		return nil
	case upscale.EdgeUpscaleOutputs:
		m.ResetUpscaleOutputs()
		return nil
	}
	return fmt.Errorf("unknown Upscale edge %s", name)
}

// UpscaleModelMutation represents an operation that mutates the UpscaleModel nodes in the graph.
type UpscaleModelMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name_in_worker  *string
	is_active       *bool
	is_default      *bool
	is_hidden       *bool
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	upscales        map[uuid.UUID]struct{}
	removedupscales map[uuid.UUID]struct{}
	clearedupscales bool
	done            bool
	oldValue        func(context.Context) (*UpscaleModel, error)
	predicates      []predicate.UpscaleModel
}

var _ ent.Mutation = (*UpscaleModelMutation)(nil)

// upscalemodelOption allows management of the mutation configuration using functional options.
type upscalemodelOption func(*UpscaleModelMutation)

// newUpscaleModelMutation creates new mutation for the UpscaleModel entity.
func newUpscaleModelMutation(c config, op Op, opts ...upscalemodelOption) *UpscaleModelMutation {
	m := &UpscaleModelMutation{
		config:        c,
		op:            op,
		typ:           TypeUpscaleModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpscaleModelID sets the ID field of the mutation.
func withUpscaleModelID(id uuid.UUID) upscalemodelOption {
	return func(m *UpscaleModelMutation) {
		var (
			err   error
			once  sync.Once
			value *UpscaleModel
		)
		m.oldValue = func(ctx context.Context) (*UpscaleModel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpscaleModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpscaleModel sets the old UpscaleModel of the mutation.
func withUpscaleModel(node *UpscaleModel) upscalemodelOption {
	return func(m *UpscaleModelMutation) {
		m.oldValue = func(context.Context) (*UpscaleModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpscaleModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpscaleModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpscaleModel entities.
func (m *UpscaleModelMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpscaleModelMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpscaleModelMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpscaleModel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameInWorker sets the "name_in_worker" field.
func (m *UpscaleModelMutation) SetNameInWorker(s string) {
	m.name_in_worker = &s
}

// NameInWorker returns the value of the "name_in_worker" field in the mutation.
func (m *UpscaleModelMutation) NameInWorker() (r string, exists bool) {
	v := m.name_in_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldNameInWorker returns the old "name_in_worker" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldNameInWorker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameInWorker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameInWorker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameInWorker: %w", err)
	}
	return oldValue.NameInWorker, nil
}

// ResetNameInWorker resets all changes to the "name_in_worker" field.
func (m *UpscaleModelMutation) ResetNameInWorker() {
	m.name_in_worker = nil
}

// SetIsActive sets the "is_active" field.
func (m *UpscaleModelMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UpscaleModelMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UpscaleModelMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsDefault sets the "is_default" field.
func (m *UpscaleModelMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *UpscaleModelMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *UpscaleModelMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *UpscaleModelMutation) SetIsHidden(b bool) {
	m.is_hidden = &b
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *UpscaleModelMutation) IsHidden() (r bool, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *UpscaleModelMutation) ResetIsHidden() {
	m.is_hidden = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UpscaleModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UpscaleModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UpscaleModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UpscaleModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UpscaleModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UpscaleModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUpscaleIDs adds the "upscales" edge to the Upscale entity by ids.
func (m *UpscaleModelMutation) AddUpscaleIDs(ids ...uuid.UUID) {
	if m.upscales == nil {
		m.upscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscales[ids[i]] = struct{}{}
	}
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *UpscaleModelMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *UpscaleModelMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// RemoveUpscaleIDs removes the "upscales" edge to the Upscale entity by IDs.
func (m *UpscaleModelMutation) RemoveUpscaleIDs(ids ...uuid.UUID) {
	if m.removedupscales == nil {
		m.removedupscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscales, ids[i])
		m.removedupscales[ids[i]] = struct{}{}
	}
}

// RemovedUpscales returns the removed IDs of the "upscales" edge to the Upscale entity.
func (m *UpscaleModelMutation) RemovedUpscalesIDs() (ids []uuid.UUID) {
	for id := range m.removedupscales {
		ids = append(ids, id)
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
func (m *UpscaleModelMutation) UpscalesIDs() (ids []uuid.UUID) {
	for id := range m.upscales {
		ids = append(ids, id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *UpscaleModelMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
	m.removedupscales = nil
}

// Where appends a list predicates to the UpscaleModelMutation builder.
func (m *UpscaleModelMutation) Where(ps ...predicate.UpscaleModel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpscaleModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpscaleModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpscaleModel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpscaleModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpscaleModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpscaleModel).
func (m *UpscaleModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpscaleModelMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name_in_worker != nil {
		fields = append(fields, upscalemodel.FieldNameInWorker)
	}
	if m.is_active != nil {
		fields = append(fields, upscalemodel.FieldIsActive)
	}
	if m.is_default != nil {
		fields = append(fields, upscalemodel.FieldIsDefault)
	}
	if m.is_hidden != nil {
		fields = append(fields, upscalemodel.FieldIsHidden)
	}
	if m.created_at != nil {
		fields = append(fields, upscalemodel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, upscalemodel.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpscaleModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upscalemodel.FieldNameInWorker:
		return m.NameInWorker()
	case upscalemodel.FieldIsActive:
		return m.IsActive()
	case upscalemodel.FieldIsDefault:
		return m.IsDefault()
	case upscalemodel.FieldIsHidden:
		return m.IsHidden()
	case upscalemodel.FieldCreatedAt:
		return m.CreatedAt()
	case upscalemodel.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpscaleModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upscalemodel.FieldNameInWorker:
		return m.OldNameInWorker(ctx)
	case upscalemodel.FieldIsActive:
		return m.OldIsActive(ctx)
	case upscalemodel.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case upscalemodel.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case upscalemodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case upscalemodel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpscaleModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upscalemodel.FieldNameInWorker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameInWorker(v)
		return nil
	case upscalemodel.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case upscalemodel.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case upscalemodel.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case upscalemodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case upscalemodel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpscaleModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpscaleModelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpscaleModelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UpscaleModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpscaleModelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpscaleModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpscaleModelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UpscaleModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpscaleModelMutation) ResetField(name string) error {
	switch name {
	case upscalemodel.FieldNameInWorker:
		m.ResetNameInWorker()
		return nil
	case upscalemodel.FieldIsActive:
		m.ResetIsActive()
		return nil
	case upscalemodel.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case upscalemodel.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case upscalemodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case upscalemodel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UpscaleModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpscaleModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.upscales != nil {
		edges = append(edges, upscalemodel.EdgeUpscales)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpscaleModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case upscalemodel.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.upscales))
		for id := range m.upscales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpscaleModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedupscales != nil {
		edges = append(edges, upscalemodel.EdgeUpscales)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpscaleModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case upscalemodel.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.removedupscales))
		for id := range m.removedupscales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpscaleModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedupscales {
		edges = append(edges, upscalemodel.EdgeUpscales)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpscaleModelMutation) EdgeCleared(name string) bool {
	switch name {
	case upscalemodel.EdgeUpscales:
		return m.clearedupscales
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpscaleModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UpscaleModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpscaleModelMutation) ResetEdge(name string) error {
	switch name {
	case upscalemodel.EdgeUpscales:
		m.ResetUpscales()
		return nil
	}
	return fmt.Errorf("unknown UpscaleModel edge %s", name)
}

// UpscaleOutputMutation represents an operation that mutates the UpscaleOutput nodes in the graph.
type UpscaleOutputMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	image_path               *string
	input_image_url          *string
	deleted_at               *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	upscales                 *uuid.UUID
	clearedupscales          bool
	generation_output        *uuid.UUID
	clearedgeneration_output bool
	done                     bool
	oldValue                 func(context.Context) (*UpscaleOutput, error)
	predicates               []predicate.UpscaleOutput
}

var _ ent.Mutation = (*UpscaleOutputMutation)(nil)

// upscaleoutputOption allows management of the mutation configuration using functional options.
type upscaleoutputOption func(*UpscaleOutputMutation)

// newUpscaleOutputMutation creates new mutation for the UpscaleOutput entity.
func newUpscaleOutputMutation(c config, op Op, opts ...upscaleoutputOption) *UpscaleOutputMutation {
	m := &UpscaleOutputMutation{
		config:        c,
		op:            op,
		typ:           TypeUpscaleOutput,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpscaleOutputID sets the ID field of the mutation.
func withUpscaleOutputID(id uuid.UUID) upscaleoutputOption {
	return func(m *UpscaleOutputMutation) {
		var (
			err   error
			once  sync.Once
			value *UpscaleOutput
		)
		m.oldValue = func(ctx context.Context) (*UpscaleOutput, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpscaleOutput.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpscaleOutput sets the old UpscaleOutput of the mutation.
func withUpscaleOutput(node *UpscaleOutput) upscaleoutputOption {
	return func(m *UpscaleOutputMutation) {
		m.oldValue = func(context.Context) (*UpscaleOutput, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpscaleOutputMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpscaleOutputMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpscaleOutput entities.
func (m *UpscaleOutputMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpscaleOutputMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpscaleOutputMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpscaleOutput.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImagePath sets the "image_path" field.
func (m *UpscaleOutputMutation) SetImagePath(s string) {
	m.image_path = &s
}

// ImagePath returns the value of the "image_path" field in the mutation.
func (m *UpscaleOutputMutation) ImagePath() (r string, exists bool) {
	v := m.image_path
	if v == nil {
		return
	}
	return *v, true
}

// OldImagePath returns the old "image_path" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldImagePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImagePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImagePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImagePath: %w", err)
	}
	return oldValue.ImagePath, nil
}

// ResetImagePath resets all changes to the "image_path" field.
func (m *UpscaleOutputMutation) ResetImagePath() {
	m.image_path = nil
}

// SetInputImageURL sets the "input_image_url" field.
func (m *UpscaleOutputMutation) SetInputImageURL(s string) {
	m.input_image_url = &s
}

// InputImageURL returns the value of the "input_image_url" field in the mutation.
func (m *UpscaleOutputMutation) InputImageURL() (r string, exists bool) {
	v := m.input_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInputImageURL returns the old "input_image_url" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldInputImageURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputImageURL: %w", err)
	}
	return oldValue.InputImageURL, nil
}

// ClearInputImageURL clears the value of the "input_image_url" field.
func (m *UpscaleOutputMutation) ClearInputImageURL() {
	m.input_image_url = nil
	m.clearedFields[upscaleoutput.FieldInputImageURL] = struct{}{}
}

// InputImageURLCleared returns if the "input_image_url" field was cleared in this mutation.
func (m *UpscaleOutputMutation) InputImageURLCleared() bool {
	_, ok := m.clearedFields[upscaleoutput.FieldInputImageURL]
	return ok
}

// ResetInputImageURL resets all changes to the "input_image_url" field.
func (m *UpscaleOutputMutation) ResetInputImageURL() {
	m.input_image_url = nil
	delete(m.clearedFields, upscaleoutput.FieldInputImageURL)
}

// SetUpscaleID sets the "upscale_id" field.
func (m *UpscaleOutputMutation) SetUpscaleID(u uuid.UUID) {
	m.upscales = &u
}

// UpscaleID returns the value of the "upscale_id" field in the mutation.
func (m *UpscaleOutputMutation) UpscaleID() (r uuid.UUID, exists bool) {
	v := m.upscales
	if v == nil {
		return
	}
	return *v, true
}

// OldUpscaleID returns the old "upscale_id" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldUpscaleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpscaleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpscaleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpscaleID: %w", err)
	}
	return oldValue.UpscaleID, nil
}

// ResetUpscaleID resets all changes to the "upscale_id" field.
func (m *UpscaleOutputMutation) ResetUpscaleID() {
	m.upscales = nil
}

// SetGenerationOutputID sets the "generation_output_id" field.
func (m *UpscaleOutputMutation) SetGenerationOutputID(u uuid.UUID) {
	m.generation_output = &u
}

// GenerationOutputID returns the value of the "generation_output_id" field in the mutation.
func (m *UpscaleOutputMutation) GenerationOutputID() (r uuid.UUID, exists bool) {
	v := m.generation_output
	if v == nil {
		return
	}
	return *v, true
}

// OldGenerationOutputID returns the old "generation_output_id" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldGenerationOutputID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenerationOutputID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenerationOutputID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenerationOutputID: %w", err)
	}
	return oldValue.GenerationOutputID, nil
}

// ClearGenerationOutputID clears the value of the "generation_output_id" field.
func (m *UpscaleOutputMutation) ClearGenerationOutputID() {
	m.generation_output = nil
	m.clearedFields[upscaleoutput.FieldGenerationOutputID] = struct{}{}
}

// GenerationOutputIDCleared returns if the "generation_output_id" field was cleared in this mutation.
func (m *UpscaleOutputMutation) GenerationOutputIDCleared() bool {
	_, ok := m.clearedFields[upscaleoutput.FieldGenerationOutputID]
	return ok
}

// ResetGenerationOutputID resets all changes to the "generation_output_id" field.
func (m *UpscaleOutputMutation) ResetGenerationOutputID() {
	m.generation_output = nil
	delete(m.clearedFields, upscaleoutput.FieldGenerationOutputID)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UpscaleOutputMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UpscaleOutputMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UpscaleOutputMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[upscaleoutput.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UpscaleOutputMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[upscaleoutput.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UpscaleOutputMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, upscaleoutput.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UpscaleOutputMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UpscaleOutputMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UpscaleOutputMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UpscaleOutputMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UpscaleOutputMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UpscaleOutputMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpscalesID sets the "upscales" edge to the Upscale entity by id.
func (m *UpscaleOutputMutation) SetUpscalesID(id uuid.UUID) {
	m.upscales = &id
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *UpscaleOutputMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *UpscaleOutputMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// UpscalesID returns the "upscales" edge ID in the mutation.
func (m *UpscaleOutputMutation) UpscalesID() (id uuid.UUID, exists bool) {
	if m.upscales != nil {
		return *m.upscales, true
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpscalesID instead. It exists only for internal usage by the builders.
func (m *UpscaleOutputMutation) UpscalesIDs() (ids []uuid.UUID) {
	if id := m.upscales; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *UpscaleOutputMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
}

// ClearGenerationOutput clears the "generation_output" edge to the GenerationOutput entity.
func (m *UpscaleOutputMutation) ClearGenerationOutput() {
	m.clearedgeneration_output = true
}

// GenerationOutputCleared reports if the "generation_output" edge to the GenerationOutput entity was cleared.
func (m *UpscaleOutputMutation) GenerationOutputCleared() bool {
	return m.GenerationOutputIDCleared() || m.clearedgeneration_output
}

// GenerationOutputIDs returns the "generation_output" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenerationOutputID instead. It exists only for internal usage by the builders.
func (m *UpscaleOutputMutation) GenerationOutputIDs() (ids []uuid.UUID) {
	if id := m.generation_output; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenerationOutput resets all changes to the "generation_output" edge.
func (m *UpscaleOutputMutation) ResetGenerationOutput() {
	m.generation_output = nil
	m.clearedgeneration_output = false
}

// Where appends a list predicates to the UpscaleOutputMutation builder.
func (m *UpscaleOutputMutation) Where(ps ...predicate.UpscaleOutput) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpscaleOutputMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpscaleOutputMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpscaleOutput, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpscaleOutputMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpscaleOutputMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpscaleOutput).
func (m *UpscaleOutputMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpscaleOutputMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.image_path != nil {
		fields = append(fields, upscaleoutput.FieldImagePath)
	}
	if m.input_image_url != nil {
		fields = append(fields, upscaleoutput.FieldInputImageURL)
	}
	if m.upscales != nil {
		fields = append(fields, upscaleoutput.FieldUpscaleID)
	}
	if m.generation_output != nil {
		fields = append(fields, upscaleoutput.FieldGenerationOutputID)
	}
	if m.deleted_at != nil {
		fields = append(fields, upscaleoutput.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, upscaleoutput.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, upscaleoutput.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpscaleOutputMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upscaleoutput.FieldImagePath:
		return m.ImagePath()
	case upscaleoutput.FieldInputImageURL:
		return m.InputImageURL()
	case upscaleoutput.FieldUpscaleID:
		return m.UpscaleID()
	case upscaleoutput.FieldGenerationOutputID:
		return m.GenerationOutputID()
	case upscaleoutput.FieldDeletedAt:
		return m.DeletedAt()
	case upscaleoutput.FieldCreatedAt:
		return m.CreatedAt()
	case upscaleoutput.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpscaleOutputMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upscaleoutput.FieldImagePath:
		return m.OldImagePath(ctx)
	case upscaleoutput.FieldInputImageURL:
		return m.OldInputImageURL(ctx)
	case upscaleoutput.FieldUpscaleID:
		return m.OldUpscaleID(ctx)
	case upscaleoutput.FieldGenerationOutputID:
		return m.OldGenerationOutputID(ctx)
	case upscaleoutput.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case upscaleoutput.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case upscaleoutput.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpscaleOutput field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleOutputMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upscaleoutput.FieldImagePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImagePath(v)
		return nil
	case upscaleoutput.FieldInputImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputImageURL(v)
		return nil
	case upscaleoutput.FieldUpscaleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpscaleID(v)
		return nil
	case upscaleoutput.FieldGenerationOutputID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenerationOutputID(v)
		return nil
	case upscaleoutput.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case upscaleoutput.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case upscaleoutput.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpscaleOutputMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpscaleOutputMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleOutputMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UpscaleOutput numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpscaleOutputMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upscaleoutput.FieldInputImageURL) {
		fields = append(fields, upscaleoutput.FieldInputImageURL)
	}
	if m.FieldCleared(upscaleoutput.FieldGenerationOutputID) {
		fields = append(fields, upscaleoutput.FieldGenerationOutputID)
	}
	if m.FieldCleared(upscaleoutput.FieldDeletedAt) {
		fields = append(fields, upscaleoutput.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpscaleOutputMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpscaleOutputMutation) ClearField(name string) error {
	switch name {
	case upscaleoutput.FieldInputImageURL:
		m.ClearInputImageURL()
		return nil
	case upscaleoutput.FieldGenerationOutputID:
		m.ClearGenerationOutputID()
		return nil
	case upscaleoutput.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpscaleOutputMutation) ResetField(name string) error {
	switch name {
	case upscaleoutput.FieldImagePath:
		m.ResetImagePath()
		return nil
	case upscaleoutput.FieldInputImageURL:
		m.ResetInputImageURL()
		return nil
	case upscaleoutput.FieldUpscaleID:
		m.ResetUpscaleID()
		return nil
	case upscaleoutput.FieldGenerationOutputID:
		m.ResetGenerationOutputID()
		return nil
	case upscaleoutput.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case upscaleoutput.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case upscaleoutput.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpscaleOutputMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.upscales != nil {
		edges = append(edges, upscaleoutput.EdgeUpscales)
	}
	if m.generation_output != nil {
		edges = append(edges, upscaleoutput.EdgeGenerationOutput)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpscaleOutputMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case upscaleoutput.EdgeUpscales:
		if id := m.upscales; id != nil {
			return []ent.Value{*id}
		}
	case upscaleoutput.EdgeGenerationOutput:
		if id := m.generation_output; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpscaleOutputMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpscaleOutputMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpscaleOutputMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedupscales {
		edges = append(edges, upscaleoutput.EdgeUpscales)
	}
	if m.clearedgeneration_output {
		edges = append(edges, upscaleoutput.EdgeGenerationOutput)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpscaleOutputMutation) EdgeCleared(name string) bool {
	switch name {
	case upscaleoutput.EdgeUpscales:
		return m.clearedupscales
	case upscaleoutput.EdgeGenerationOutput:
		return m.clearedgeneration_output
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpscaleOutputMutation) ClearEdge(name string) error {
	switch name {
	case upscaleoutput.EdgeUpscales:
		m.ClearUpscales()
		return nil
	case upscaleoutput.EdgeGenerationOutput:
		m.ClearGenerationOutput()
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpscaleOutputMutation) ResetEdge(name string) error {
	switch name {
	case upscaleoutput.EdgeUpscales:
		m.ResetUpscales()
		return nil
	case upscaleoutput.EdgeGenerationOutput:
		m.ResetGenerationOutput()
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	email                          *string
	stripe_customer_id             *string
	active_product_id              *string
	last_sign_in_at                *time.Time
	last_seen_at                   *time.Time
	banned_at                      *time.Time
	scheduled_for_deletion_on      *time.Time
	data_deleted_at                *time.Time
	wants_email                    *bool
	discord_id                     *string
	username                       *string
	username_changed_at            *time.Time
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	generations                    map[uuid.UUID]struct{}
	removedgenerations             map[uuid.UUID]struct{}
	clearedgenerations             bool
	upscales                       map[uuid.UUID]struct{}
	removedupscales                map[uuid.UUID]struct{}
	clearedupscales                bool
	voiceovers                     map[uuid.UUID]struct{}
	removedvoiceovers              map[uuid.UUID]struct{}
	clearedvoiceovers              bool
	credits                        map[uuid.UUID]struct{}
	removedcredits                 map[uuid.UUID]struct{}
	clearedcredits                 bool
	api_tokens                     map[uuid.UUID]struct{}
	removedapi_tokens              map[uuid.UUID]struct{}
	clearedapi_tokens              bool
	tips_given                     map[uuid.UUID]struct{}
	removedtips_given              map[uuid.UUID]struct{}
	clearedtips_given              bool
	tips_received                  map[uuid.UUID]struct{}
	removedtips_received           map[uuid.UUID]struct{}
	clearedtips_received           bool
	roles                          map[uuid.UUID]struct{}
	removedroles                   map[uuid.UUID]struct{}
	clearedroles                   bool
	generation_output_likes        map[uuid.UUID]struct{}
	removedgeneration_output_likes map[uuid.UUID]struct{}
	clearedgeneration_output_likes bool
	done                           bool
	oldValue                       func(context.Context) (*User, error)
	predicates                     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *UserMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *UserMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStripeCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *UserMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
}

// SetActiveProductID sets the "active_product_id" field.
func (m *UserMutation) SetActiveProductID(s string) {
	m.active_product_id = &s
}

// ActiveProductID returns the value of the "active_product_id" field in the mutation.
func (m *UserMutation) ActiveProductID() (r string, exists bool) {
	v := m.active_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveProductID returns the old "active_product_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActiveProductID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveProductID: %w", err)
	}
	return oldValue.ActiveProductID, nil
}

// ClearActiveProductID clears the value of the "active_product_id" field.
func (m *UserMutation) ClearActiveProductID() {
	m.active_product_id = nil
	m.clearedFields[user.FieldActiveProductID] = struct{}{}
}

// ActiveProductIDCleared returns if the "active_product_id" field was cleared in this mutation.
func (m *UserMutation) ActiveProductIDCleared() bool {
	_, ok := m.clearedFields[user.FieldActiveProductID]
	return ok
}

// ResetActiveProductID resets all changes to the "active_product_id" field.
func (m *UserMutation) ResetActiveProductID() {
	m.active_product_id = nil
	delete(m.clearedFields, user.FieldActiveProductID)
}

// SetLastSignInAt sets the "last_sign_in_at" field.
func (m *UserMutation) SetLastSignInAt(t time.Time) {
	m.last_sign_in_at = &t
}

// LastSignInAt returns the value of the "last_sign_in_at" field in the mutation.
func (m *UserMutation) LastSignInAt() (r time.Time, exists bool) {
	v := m.last_sign_in_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSignInAt returns the old "last_sign_in_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastSignInAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSignInAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSignInAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSignInAt: %w", err)
	}
	return oldValue.LastSignInAt, nil
}

// ClearLastSignInAt clears the value of the "last_sign_in_at" field.
func (m *UserMutation) ClearLastSignInAt() {
	m.last_sign_in_at = nil
	m.clearedFields[user.FieldLastSignInAt] = struct{}{}
}

// LastSignInAtCleared returns if the "last_sign_in_at" field was cleared in this mutation.
func (m *UserMutation) LastSignInAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastSignInAt]
	return ok
}

// ResetLastSignInAt resets all changes to the "last_sign_in_at" field.
func (m *UserMutation) ResetLastSignInAt() {
	m.last_sign_in_at = nil
	delete(m.clearedFields, user.FieldLastSignInAt)
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *UserMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *UserMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *UserMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
}

// SetBannedAt sets the "banned_at" field.
func (m *UserMutation) SetBannedAt(t time.Time) {
	m.banned_at = &t
}

// BannedAt returns the value of the "banned_at" field in the mutation.
func (m *UserMutation) BannedAt() (r time.Time, exists bool) {
	v := m.banned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldBannedAt returns the old "banned_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBannedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannedAt: %w", err)
	}
	return oldValue.BannedAt, nil
}

// ClearBannedAt clears the value of the "banned_at" field.
func (m *UserMutation) ClearBannedAt() {
	m.banned_at = nil
	m.clearedFields[user.FieldBannedAt] = struct{}{}
}

// BannedAtCleared returns if the "banned_at" field was cleared in this mutation.
func (m *UserMutation) BannedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldBannedAt]
	return ok
}

// ResetBannedAt resets all changes to the "banned_at" field.
func (m *UserMutation) ResetBannedAt() {
	m.banned_at = nil
	delete(m.clearedFields, user.FieldBannedAt)
}

// SetScheduledForDeletionOn sets the "scheduled_for_deletion_on" field.
func (m *UserMutation) SetScheduledForDeletionOn(t time.Time) {
	m.scheduled_for_deletion_on = &t
}

// ScheduledForDeletionOn returns the value of the "scheduled_for_deletion_on" field in the mutation.
func (m *UserMutation) ScheduledForDeletionOn() (r time.Time, exists bool) {
	v := m.scheduled_for_deletion_on
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledForDeletionOn returns the old "scheduled_for_deletion_on" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldScheduledForDeletionOn(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledForDeletionOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledForDeletionOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledForDeletionOn: %w", err)
	}
	return oldValue.ScheduledForDeletionOn, nil
}

// ClearScheduledForDeletionOn clears the value of the "scheduled_for_deletion_on" field.
func (m *UserMutation) ClearScheduledForDeletionOn() {
	m.scheduled_for_deletion_on = nil
	m.clearedFields[user.FieldScheduledForDeletionOn] = struct{}{}
}

// ScheduledForDeletionOnCleared returns if the "scheduled_for_deletion_on" field was cleared in this mutation.
func (m *UserMutation) ScheduledForDeletionOnCleared() bool {
	_, ok := m.clearedFields[user.FieldScheduledForDeletionOn]
	return ok
}

// ResetScheduledForDeletionOn resets all changes to the "scheduled_for_deletion_on" field.
func (m *UserMutation) ResetScheduledForDeletionOn() {
	m.scheduled_for_deletion_on = nil
	delete(m.clearedFields, user.FieldScheduledForDeletionOn)
}

// SetDataDeletedAt sets the "data_deleted_at" field.
func (m *UserMutation) SetDataDeletedAt(t time.Time) {
	m.data_deleted_at = &t
}

// DataDeletedAt returns the value of the "data_deleted_at" field in the mutation.
func (m *UserMutation) DataDeletedAt() (r time.Time, exists bool) {
	v := m.data_deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDataDeletedAt returns the old "data_deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDataDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataDeletedAt: %w", err)
	}
	return oldValue.DataDeletedAt, nil
}

// ClearDataDeletedAt clears the value of the "data_deleted_at" field.
func (m *UserMutation) ClearDataDeletedAt() {
	m.data_deleted_at = nil
	m.clearedFields[user.FieldDataDeletedAt] = struct{}{}
}

// DataDeletedAtCleared returns if the "data_deleted_at" field was cleared in this mutation.
func (m *UserMutation) DataDeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDataDeletedAt]
	return ok
}

// ResetDataDeletedAt resets all changes to the "data_deleted_at" field.
func (m *UserMutation) ResetDataDeletedAt() {
	m.data_deleted_at = nil
	delete(m.clearedFields, user.FieldDataDeletedAt)
}

// SetWantsEmail sets the "wants_email" field.
func (m *UserMutation) SetWantsEmail(b bool) {
	m.wants_email = &b
}

// WantsEmail returns the value of the "wants_email" field in the mutation.
func (m *UserMutation) WantsEmail() (r bool, exists bool) {
	v := m.wants_email
	if v == nil {
		return
	}
	return *v, true
}

// OldWantsEmail returns the old "wants_email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWantsEmail(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWantsEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWantsEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWantsEmail: %w", err)
	}
	return oldValue.WantsEmail, nil
}

// ClearWantsEmail clears the value of the "wants_email" field.
func (m *UserMutation) ClearWantsEmail() {
	m.wants_email = nil
	m.clearedFields[user.FieldWantsEmail] = struct{}{}
}

// WantsEmailCleared returns if the "wants_email" field was cleared in this mutation.
func (m *UserMutation) WantsEmailCleared() bool {
	_, ok := m.clearedFields[user.FieldWantsEmail]
	return ok
}

// ResetWantsEmail resets all changes to the "wants_email" field.
func (m *UserMutation) ResetWantsEmail() {
	m.wants_email = nil
	delete(m.clearedFields, user.FieldWantsEmail)
}

// SetDiscordID sets the "discord_id" field.
func (m *UserMutation) SetDiscordID(s string) {
	m.discord_id = &s
}

// DiscordID returns the value of the "discord_id" field in the mutation.
func (m *UserMutation) DiscordID() (r string, exists bool) {
	v := m.discord_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordID returns the old "discord_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDiscordID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscordID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscordID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordID: %w", err)
	}
	return oldValue.DiscordID, nil
}

// ClearDiscordID clears the value of the "discord_id" field.
func (m *UserMutation) ClearDiscordID() {
	m.discord_id = nil
	m.clearedFields[user.FieldDiscordID] = struct{}{}
}

// DiscordIDCleared returns if the "discord_id" field was cleared in this mutation.
func (m *UserMutation) DiscordIDCleared() bool {
	_, ok := m.clearedFields[user.FieldDiscordID]
	return ok
}

// ResetDiscordID resets all changes to the "discord_id" field.
func (m *UserMutation) ResetDiscordID() {
	m.discord_id = nil
	delete(m.clearedFields, user.FieldDiscordID)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetUsernameChangedAt sets the "username_changed_at" field.
func (m *UserMutation) SetUsernameChangedAt(t time.Time) {
	m.username_changed_at = &t
}

// UsernameChangedAt returns the value of the "username_changed_at" field in the mutation.
func (m *UserMutation) UsernameChangedAt() (r time.Time, exists bool) {
	v := m.username_changed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsernameChangedAt returns the old "username_changed_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsernameChangedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsernameChangedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsernameChangedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsernameChangedAt: %w", err)
	}
	return oldValue.UsernameChangedAt, nil
}

// ClearUsernameChangedAt clears the value of the "username_changed_at" field.
func (m *UserMutation) ClearUsernameChangedAt() {
	m.username_changed_at = nil
	m.clearedFields[user.FieldUsernameChangedAt] = struct{}{}
}

// UsernameChangedAtCleared returns if the "username_changed_at" field was cleared in this mutation.
func (m *UserMutation) UsernameChangedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUsernameChangedAt]
	return ok
}

// ResetUsernameChangedAt resets all changes to the "username_changed_at" field.
func (m *UserMutation) ResetUsernameChangedAt() {
	m.username_changed_at = nil
	delete(m.clearedFields, user.FieldUsernameChangedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *UserMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *UserMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *UserMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *UserMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *UserMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *UserMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *UserMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// AddUpscaleIDs adds the "upscales" edge to the Upscale entity by ids.
func (m *UserMutation) AddUpscaleIDs(ids ...uuid.UUID) {
	if m.upscales == nil {
		m.upscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscales[ids[i]] = struct{}{}
	}
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *UserMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *UserMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// RemoveUpscaleIDs removes the "upscales" edge to the Upscale entity by IDs.
func (m *UserMutation) RemoveUpscaleIDs(ids ...uuid.UUID) {
	if m.removedupscales == nil {
		m.removedupscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscales, ids[i])
		m.removedupscales[ids[i]] = struct{}{}
	}
}

// RemovedUpscales returns the removed IDs of the "upscales" edge to the Upscale entity.
func (m *UserMutation) RemovedUpscalesIDs() (ids []uuid.UUID) {
	for id := range m.removedupscales {
		ids = append(ids, id)
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
func (m *UserMutation) UpscalesIDs() (ids []uuid.UUID) {
	for id := range m.upscales {
		ids = append(ids, id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *UserMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
	m.removedupscales = nil
}

// AddVoiceoverIDs adds the "voiceovers" edge to the Voiceover entity by ids.
func (m *UserMutation) AddVoiceoverIDs(ids ...uuid.UUID) {
	if m.voiceovers == nil {
		m.voiceovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.voiceovers[ids[i]] = struct{}{}
	}
}

// ClearVoiceovers clears the "voiceovers" edge to the Voiceover entity.
func (m *UserMutation) ClearVoiceovers() {
	m.clearedvoiceovers = true
}

// VoiceoversCleared reports if the "voiceovers" edge to the Voiceover entity was cleared.
func (m *UserMutation) VoiceoversCleared() bool {
	return m.clearedvoiceovers
}

// RemoveVoiceoverIDs removes the "voiceovers" edge to the Voiceover entity by IDs.
func (m *UserMutation) RemoveVoiceoverIDs(ids ...uuid.UUID) {
	if m.removedvoiceovers == nil {
		m.removedvoiceovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.voiceovers, ids[i])
		m.removedvoiceovers[ids[i]] = struct{}{}
	}
}

// RemovedVoiceovers returns the removed IDs of the "voiceovers" edge to the Voiceover entity.
func (m *UserMutation) RemovedVoiceoversIDs() (ids []uuid.UUID) {
	for id := range m.removedvoiceovers {
		ids = append(ids, id)
	}
	return
}

// VoiceoversIDs returns the "voiceovers" edge IDs in the mutation.
func (m *UserMutation) VoiceoversIDs() (ids []uuid.UUID) {
	for id := range m.voiceovers {
		ids = append(ids, id)
	}
	return
}

// ResetVoiceovers resets all changes to the "voiceovers" edge.
func (m *UserMutation) ResetVoiceovers() {
	m.voiceovers = nil
	m.clearedvoiceovers = false
	m.removedvoiceovers = nil
}

// AddCreditIDs adds the "credits" edge to the Credit entity by ids.
func (m *UserMutation) AddCreditIDs(ids ...uuid.UUID) {
	if m.credits == nil {
		m.credits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.credits[ids[i]] = struct{}{}
	}
}

// ClearCredits clears the "credits" edge to the Credit entity.
func (m *UserMutation) ClearCredits() {
	m.clearedcredits = true
}

// CreditsCleared reports if the "credits" edge to the Credit entity was cleared.
func (m *UserMutation) CreditsCleared() bool {
	return m.clearedcredits
}

// RemoveCreditIDs removes the "credits" edge to the Credit entity by IDs.
func (m *UserMutation) RemoveCreditIDs(ids ...uuid.UUID) {
	if m.removedcredits == nil {
		m.removedcredits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.credits, ids[i])
		m.removedcredits[ids[i]] = struct{}{}
	}
}

// RemovedCredits returns the removed IDs of the "credits" edge to the Credit entity.
func (m *UserMutation) RemovedCreditsIDs() (ids []uuid.UUID) {
	for id := range m.removedcredits {
		ids = append(ids, id)
	}
	return
}

// CreditsIDs returns the "credits" edge IDs in the mutation.
func (m *UserMutation) CreditsIDs() (ids []uuid.UUID) {
	for id := range m.credits {
		ids = append(ids, id)
	}
	return
}

// ResetCredits resets all changes to the "credits" edge.
func (m *UserMutation) ResetCredits() {
	m.credits = nil
	m.clearedcredits = false
	m.removedcredits = nil
}

// AddAPITokenIDs adds the "api_tokens" edge to the ApiToken entity by ids.
func (m *UserMutation) AddAPITokenIDs(ids ...uuid.UUID) {
	if m.api_tokens == nil {
		m.api_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.api_tokens[ids[i]] = struct{}{}
	}
}

// ClearAPITokens clears the "api_tokens" edge to the ApiToken entity.
func (m *UserMutation) ClearAPITokens() {
	m.clearedapi_tokens = true
}

// APITokensCleared reports if the "api_tokens" edge to the ApiToken entity was cleared.
func (m *UserMutation) APITokensCleared() bool {
	return m.clearedapi_tokens
}

// RemoveAPITokenIDs removes the "api_tokens" edge to the ApiToken entity by IDs.
func (m *UserMutation) RemoveAPITokenIDs(ids ...uuid.UUID) {
	if m.removedapi_tokens == nil {
		m.removedapi_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.api_tokens, ids[i])
		m.removedapi_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAPITokens returns the removed IDs of the "api_tokens" edge to the ApiToken entity.
func (m *UserMutation) RemovedAPITokensIDs() (ids []uuid.UUID) {
	for id := range m.removedapi_tokens {
		ids = append(ids, id)
	}
	return
}

// APITokensIDs returns the "api_tokens" edge IDs in the mutation.
func (m *UserMutation) APITokensIDs() (ids []uuid.UUID) {
	for id := range m.api_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAPITokens resets all changes to the "api_tokens" edge.
func (m *UserMutation) ResetAPITokens() {
	m.api_tokens = nil
	m.clearedapi_tokens = false
	m.removedapi_tokens = nil
}

// AddTipsGivenIDs adds the "tips_given" edge to the TipLog entity by ids.
func (m *UserMutation) AddTipsGivenIDs(ids ...uuid.UUID) {
	if m.tips_given == nil {
		m.tips_given = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tips_given[ids[i]] = struct{}{}
	}
}

// ClearTipsGiven clears the "tips_given" edge to the TipLog entity.
func (m *UserMutation) ClearTipsGiven() {
	m.clearedtips_given = true
}

// TipsGivenCleared reports if the "tips_given" edge to the TipLog entity was cleared.
func (m *UserMutation) TipsGivenCleared() bool {
	return m.clearedtips_given
}

// RemoveTipsGivenIDs removes the "tips_given" edge to the TipLog entity by IDs.
func (m *UserMutation) RemoveTipsGivenIDs(ids ...uuid.UUID) {
	if m.removedtips_given == nil {
		m.removedtips_given = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tips_given, ids[i])
		m.removedtips_given[ids[i]] = struct{}{}
	}
}

// RemovedTipsGiven returns the removed IDs of the "tips_given" edge to the TipLog entity.
func (m *UserMutation) RemovedTipsGivenIDs() (ids []uuid.UUID) {
	for id := range m.removedtips_given {
		ids = append(ids, id)
	}
	return
}

// TipsGivenIDs returns the "tips_given" edge IDs in the mutation.
func (m *UserMutation) TipsGivenIDs() (ids []uuid.UUID) {
	for id := range m.tips_given {
		ids = append(ids, id)
	}
	return
}

// ResetTipsGiven resets all changes to the "tips_given" edge.
func (m *UserMutation) ResetTipsGiven() {
	m.tips_given = nil
	m.clearedtips_given = false
	m.removedtips_given = nil
}

// AddTipsReceivedIDs adds the "tips_received" edge to the TipLog entity by ids.
func (m *UserMutation) AddTipsReceivedIDs(ids ...uuid.UUID) {
	if m.tips_received == nil {
		m.tips_received = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tips_received[ids[i]] = struct{}{}
	}
}

// ClearTipsReceived clears the "tips_received" edge to the TipLog entity.
func (m *UserMutation) ClearTipsReceived() {
	m.clearedtips_received = true
}

// TipsReceivedCleared reports if the "tips_received" edge to the TipLog entity was cleared.
func (m *UserMutation) TipsReceivedCleared() bool {
	return m.clearedtips_received
}

// RemoveTipsReceivedIDs removes the "tips_received" edge to the TipLog entity by IDs.
func (m *UserMutation) RemoveTipsReceivedIDs(ids ...uuid.UUID) {
	if m.removedtips_received == nil {
		m.removedtips_received = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tips_received, ids[i])
		m.removedtips_received[ids[i]] = struct{}{}
	}
}

// RemovedTipsReceived returns the removed IDs of the "tips_received" edge to the TipLog entity.
func (m *UserMutation) RemovedTipsReceivedIDs() (ids []uuid.UUID) {
	for id := range m.removedtips_received {
		ids = append(ids, id)
	}
	return
}

// TipsReceivedIDs returns the "tips_received" edge IDs in the mutation.
func (m *UserMutation) TipsReceivedIDs() (ids []uuid.UUID) {
	for id := range m.tips_received {
		ids = append(ids, id)
	}
	return
}

// ResetTipsReceived resets all changes to the "tips_received" edge.
func (m *UserMutation) ResetTipsReceived() {
	m.tips_received = nil
	m.clearedtips_received = false
	m.removedtips_received = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...uuid.UUID) {
	if m.roles == nil {
		m.roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...uuid.UUID) {
	if m.removedroles == nil {
		m.removedroles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []uuid.UUID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddGenerationOutputLikeIDs adds the "generation_output_likes" edge to the GenerationOutputLike entity by ids.
func (m *UserMutation) AddGenerationOutputLikeIDs(ids ...uuid.UUID) {
	if m.generation_output_likes == nil {
		m.generation_output_likes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generation_output_likes[ids[i]] = struct{}{}
	}
}

// ClearGenerationOutputLikes clears the "generation_output_likes" edge to the GenerationOutputLike entity.
func (m *UserMutation) ClearGenerationOutputLikes() {
	m.clearedgeneration_output_likes = true
}

// GenerationOutputLikesCleared reports if the "generation_output_likes" edge to the GenerationOutputLike entity was cleared.
func (m *UserMutation) GenerationOutputLikesCleared() bool {
	return m.clearedgeneration_output_likes
}

// RemoveGenerationOutputLikeIDs removes the "generation_output_likes" edge to the GenerationOutputLike entity by IDs.
func (m *UserMutation) RemoveGenerationOutputLikeIDs(ids ...uuid.UUID) {
	if m.removedgeneration_output_likes == nil {
		m.removedgeneration_output_likes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generation_output_likes, ids[i])
		m.removedgeneration_output_likes[ids[i]] = struct{}{}
	}
}

// RemovedGenerationOutputLikes returns the removed IDs of the "generation_output_likes" edge to the GenerationOutputLike entity.
func (m *UserMutation) RemovedGenerationOutputLikesIDs() (ids []uuid.UUID) {
	for id := range m.removedgeneration_output_likes {
		ids = append(ids, id)
	}
	return
}

// GenerationOutputLikesIDs returns the "generation_output_likes" edge IDs in the mutation.
func (m *UserMutation) GenerationOutputLikesIDs() (ids []uuid.UUID) {
	for id := range m.generation_output_likes {
		ids = append(ids, id)
	}
	return
}

// ResetGenerationOutputLikes resets all changes to the "generation_output_likes" edge.
func (m *UserMutation) ResetGenerationOutputLikes() {
	m.generation_output_likes = nil
	m.clearedgeneration_output_likes = false
	m.removedgeneration_output_likes = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, user.FieldStripeCustomerID)
	}
	if m.active_product_id != nil {
		fields = append(fields, user.FieldActiveProductID)
	}
	if m.last_sign_in_at != nil {
		fields = append(fields, user.FieldLastSignInAt)
	}
	if m.last_seen_at != nil {
		fields = append(fields, user.FieldLastSeenAt)
	}
	if m.banned_at != nil {
		fields = append(fields, user.FieldBannedAt)
	}
	if m.scheduled_for_deletion_on != nil {
		fields = append(fields, user.FieldScheduledForDeletionOn)
	}
	if m.data_deleted_at != nil {
		fields = append(fields, user.FieldDataDeletedAt)
	}
	if m.wants_email != nil {
		fields = append(fields, user.FieldWantsEmail)
	}
	if m.discord_id != nil {
		fields = append(fields, user.FieldDiscordID)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.username_changed_at != nil {
		fields = append(fields, user.FieldUsernameChangedAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case user.FieldActiveProductID:
		return m.ActiveProductID()
	case user.FieldLastSignInAt:
		return m.LastSignInAt()
	case user.FieldLastSeenAt:
		return m.LastSeenAt()
	case user.FieldBannedAt:
		return m.BannedAt()
	case user.FieldScheduledForDeletionOn:
		return m.ScheduledForDeletionOn()
	case user.FieldDataDeletedAt:
		return m.DataDeletedAt()
	case user.FieldWantsEmail:
		return m.WantsEmail()
	case user.FieldDiscordID:
		return m.DiscordID()
	case user.FieldUsername:
		return m.Username()
	case user.FieldUsernameChangedAt:
		return m.UsernameChangedAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case user.FieldActiveProductID:
		return m.OldActiveProductID(ctx)
	case user.FieldLastSignInAt:
		return m.OldLastSignInAt(ctx)
	case user.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	case user.FieldBannedAt:
		return m.OldBannedAt(ctx)
	case user.FieldScheduledForDeletionOn:
		return m.OldScheduledForDeletionOn(ctx)
	case user.FieldDataDeletedAt:
		return m.OldDataDeletedAt(ctx)
	case user.FieldWantsEmail:
		return m.OldWantsEmail(ctx)
	case user.FieldDiscordID:
		return m.OldDiscordID(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldUsernameChangedAt:
		return m.OldUsernameChangedAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case user.FieldActiveProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveProductID(v)
		return nil
	case user.FieldLastSignInAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSignInAt(v)
		return nil
	case user.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	case user.FieldBannedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannedAt(v)
		return nil
	case user.FieldScheduledForDeletionOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledForDeletionOn(v)
		return nil
	case user.FieldDataDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataDeletedAt(v)
		return nil
	case user.FieldWantsEmail:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWantsEmail(v)
		return nil
	case user.FieldDiscordID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordID(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldUsernameChangedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsernameChangedAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldActiveProductID) {
		fields = append(fields, user.FieldActiveProductID)
	}
	if m.FieldCleared(user.FieldLastSignInAt) {
		fields = append(fields, user.FieldLastSignInAt)
	}
	if m.FieldCleared(user.FieldBannedAt) {
		fields = append(fields, user.FieldBannedAt)
	}
	if m.FieldCleared(user.FieldScheduledForDeletionOn) {
		fields = append(fields, user.FieldScheduledForDeletionOn)
	}
	if m.FieldCleared(user.FieldDataDeletedAt) {
		fields = append(fields, user.FieldDataDeletedAt)
	}
	if m.FieldCleared(user.FieldWantsEmail) {
		fields = append(fields, user.FieldWantsEmail)
	}
	if m.FieldCleared(user.FieldDiscordID) {
		fields = append(fields, user.FieldDiscordID)
	}
	if m.FieldCleared(user.FieldUsernameChangedAt) {
		fields = append(fields, user.FieldUsernameChangedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldActiveProductID:
		m.ClearActiveProductID()
		return nil
	case user.FieldLastSignInAt:
		m.ClearLastSignInAt()
		return nil
	case user.FieldBannedAt:
		m.ClearBannedAt()
		return nil
	case user.FieldScheduledForDeletionOn:
		m.ClearScheduledForDeletionOn()
		return nil
	case user.FieldDataDeletedAt:
		m.ClearDataDeletedAt()
		return nil
	case user.FieldWantsEmail:
		m.ClearWantsEmail()
		return nil
	case user.FieldDiscordID:
		m.ClearDiscordID()
		return nil
	case user.FieldUsernameChangedAt:
		m.ClearUsernameChangedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case user.FieldActiveProductID:
		m.ResetActiveProductID()
		return nil
	case user.FieldLastSignInAt:
		m.ResetLastSignInAt()
		return nil
	case user.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	case user.FieldBannedAt:
		m.ResetBannedAt()
		return nil
	case user.FieldScheduledForDeletionOn:
		m.ResetScheduledForDeletionOn()
		return nil
	case user.FieldDataDeletedAt:
		m.ResetDataDeletedAt()
		return nil
	case user.FieldWantsEmail:
		m.ResetWantsEmail()
		return nil
	case user.FieldDiscordID:
		m.ResetDiscordID()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldUsernameChangedAt:
		m.ResetUsernameChangedAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.generations != nil {
		edges = append(edges, user.EdgeGenerations)
	}
	if m.upscales != nil {
		edges = append(edges, user.EdgeUpscales)
	}
	if m.voiceovers != nil {
		edges = append(edges, user.EdgeVoiceovers)
	}
	if m.credits != nil {
		edges = append(edges, user.EdgeCredits)
	}
	if m.api_tokens != nil {
		edges = append(edges, user.EdgeAPITokens)
	}
	if m.tips_given != nil {
		edges = append(edges, user.EdgeTipsGiven)
	}
	if m.tips_received != nil {
		edges = append(edges, user.EdgeTipsReceived)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.generation_output_likes != nil {
		edges = append(edges, user.EdgeGenerationOutputLikes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.upscales))
		for id := range m.upscales {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVoiceovers:
		ids := make([]ent.Value, 0, len(m.voiceovers))
		for id := range m.voiceovers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredits:
		ids := make([]ent.Value, 0, len(m.credits))
		for id := range m.credits {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.api_tokens))
		for id := range m.api_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTipsGiven:
		ids := make([]ent.Value, 0, len(m.tips_given))
		for id := range m.tips_given {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTipsReceived:
		ids := make([]ent.Value, 0, len(m.tips_received))
		for id := range m.tips_received {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGenerationOutputLikes:
		ids := make([]ent.Value, 0, len(m.generation_output_likes))
		for id := range m.generation_output_likes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedgenerations != nil {
		edges = append(edges, user.EdgeGenerations)
	}
	if m.removedupscales != nil {
		edges = append(edges, user.EdgeUpscales)
	}
	if m.removedvoiceovers != nil {
		edges = append(edges, user.EdgeVoiceovers)
	}
	if m.removedcredits != nil {
		edges = append(edges, user.EdgeCredits)
	}
	if m.removedapi_tokens != nil {
		edges = append(edges, user.EdgeAPITokens)
	}
	if m.removedtips_given != nil {
		edges = append(edges, user.EdgeTipsGiven)
	}
	if m.removedtips_received != nil {
		edges = append(edges, user.EdgeTipsReceived)
	}
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedgeneration_output_likes != nil {
		edges = append(edges, user.EdgeGenerationOutputLikes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.removedupscales))
		for id := range m.removedupscales {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVoiceovers:
		ids := make([]ent.Value, 0, len(m.removedvoiceovers))
		for id := range m.removedvoiceovers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredits:
		ids := make([]ent.Value, 0, len(m.removedcredits))
		for id := range m.removedcredits {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.removedapi_tokens))
		for id := range m.removedapi_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTipsGiven:
		ids := make([]ent.Value, 0, len(m.removedtips_given))
		for id := range m.removedtips_given {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTipsReceived:
		ids := make([]ent.Value, 0, len(m.removedtips_received))
		for id := range m.removedtips_received {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGenerationOutputLikes:
		ids := make([]ent.Value, 0, len(m.removedgeneration_output_likes))
		for id := range m.removedgeneration_output_likes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedgenerations {
		edges = append(edges, user.EdgeGenerations)
	}
	if m.clearedupscales {
		edges = append(edges, user.EdgeUpscales)
	}
	if m.clearedvoiceovers {
		edges = append(edges, user.EdgeVoiceovers)
	}
	if m.clearedcredits {
		edges = append(edges, user.EdgeCredits)
	}
	if m.clearedapi_tokens {
		edges = append(edges, user.EdgeAPITokens)
	}
	if m.clearedtips_given {
		edges = append(edges, user.EdgeTipsGiven)
	}
	if m.clearedtips_received {
		edges = append(edges, user.EdgeTipsReceived)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedgeneration_output_likes {
		edges = append(edges, user.EdgeGenerationOutputLikes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeGenerations:
		return m.clearedgenerations
	case user.EdgeUpscales:
		return m.clearedupscales
	case user.EdgeVoiceovers:
		return m.clearedvoiceovers
	case user.EdgeCredits:
		return m.clearedcredits
	case user.EdgeAPITokens:
		return m.clearedapi_tokens
	case user.EdgeTipsGiven:
		return m.clearedtips_given
	case user.EdgeTipsReceived:
		return m.clearedtips_received
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeGenerationOutputLikes:
		return m.clearedgeneration_output_likes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeGenerations:
		m.ResetGenerations()
		return nil
	case user.EdgeUpscales:
		m.ResetUpscales()
		return nil
	case user.EdgeVoiceovers:
		m.ResetVoiceovers()
		return nil
	case user.EdgeCredits:
		m.ResetCredits()
		return nil
	case user.EdgeAPITokens:
		m.ResetAPITokens()
		return nil
	case user.EdgeTipsGiven:
		m.ResetTipsGiven()
		return nil
	case user.EdgeTipsReceived:
		m.ResetTipsReceived()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeGenerationOutputLikes:
		m.ResetGenerationOutputLikes()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VoiceoverMutation represents an operation that mutates the Voiceover nodes in the graph.
type VoiceoverMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	country_code              *string
	status                    *voiceover.Status
	failure_reason            *string
	stripe_product_id         *string
	temperature               *float32
	addtemperature            *float32
	seed                      *int
	addseed                   *int
	was_auto_submitted        *bool
	denoise_audio             *bool
	remove_silence            *bool
	cost                      *int32
	addcost                   *int32
	source_type               *enttypes.SourceType
	started_at                *time.Time
	completed_at              *time.Time
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	user                      *uuid.UUID
	cleareduser               bool
	prompt                    *uuid.UUID
	clearedprompt             bool
	device_info               *uuid.UUID
	cleareddevice_info        bool
	voiceover_models          *uuid.UUID
	clearedvoiceover_models   bool
	voiceover_speakers        *uuid.UUID
	clearedvoiceover_speakers bool
	api_tokens                *uuid.UUID
	clearedapi_tokens         bool
	voiceover_outputs         map[uuid.UUID]struct{}
	removedvoiceover_outputs  map[uuid.UUID]struct{}
	clearedvoiceover_outputs  bool
	done                      bool
	oldValue                  func(context.Context) (*Voiceover, error)
	predicates                []predicate.Voiceover
}

var _ ent.Mutation = (*VoiceoverMutation)(nil)

// voiceoverOption allows management of the mutation configuration using functional options.
type voiceoverOption func(*VoiceoverMutation)

// newVoiceoverMutation creates new mutation for the Voiceover entity.
func newVoiceoverMutation(c config, op Op, opts ...voiceoverOption) *VoiceoverMutation {
	m := &VoiceoverMutation{
		config:        c,
		op:            op,
		typ:           TypeVoiceover,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoiceoverID sets the ID field of the mutation.
func withVoiceoverID(id uuid.UUID) voiceoverOption {
	return func(m *VoiceoverMutation) {
		var (
			err   error
			once  sync.Once
			value *Voiceover
		)
		m.oldValue = func(ctx context.Context) (*Voiceover, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Voiceover.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVoiceover sets the old Voiceover of the mutation.
func withVoiceover(node *Voiceover) voiceoverOption {
	return func(m *VoiceoverMutation) {
		m.oldValue = func(context.Context) (*Voiceover, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoiceoverMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoiceoverMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Voiceover entities.
func (m *VoiceoverMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoiceoverMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoiceoverMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Voiceover.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCountryCode sets the "country_code" field.
func (m *VoiceoverMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *VoiceoverMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldCountryCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ClearCountryCode clears the value of the "country_code" field.
func (m *VoiceoverMutation) ClearCountryCode() {
	m.country_code = nil
	m.clearedFields[voiceover.FieldCountryCode] = struct{}{}
}

// CountryCodeCleared returns if the "country_code" field was cleared in this mutation.
func (m *VoiceoverMutation) CountryCodeCleared() bool {
	_, ok := m.clearedFields[voiceover.FieldCountryCode]
	return ok
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *VoiceoverMutation) ResetCountryCode() {
	m.country_code = nil
	delete(m.clearedFields, voiceover.FieldCountryCode)
}

// SetStatus sets the "status" field.
func (m *VoiceoverMutation) SetStatus(v voiceover.Status) {
	m.status = &v
}

// Status returns the value of the "status" field in the mutation.
func (m *VoiceoverMutation) Status() (r voiceover.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldStatus(ctx context.Context) (v voiceover.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *VoiceoverMutation) ResetStatus() {
	m.status = nil
}

// SetFailureReason sets the "failure_reason" field.
func (m *VoiceoverMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *VoiceoverMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldFailureReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *VoiceoverMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[voiceover.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *VoiceoverMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[voiceover.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *VoiceoverMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, voiceover.FieldFailureReason)
}

// SetStripeProductID sets the "stripe_product_id" field.
func (m *VoiceoverMutation) SetStripeProductID(s string) {
	m.stripe_product_id = &s
}

// StripeProductID returns the value of the "stripe_product_id" field in the mutation.
func (m *VoiceoverMutation) StripeProductID() (r string, exists bool) {
	v := m.stripe_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeProductID returns the old "stripe_product_id" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldStripeProductID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeProductID: %w", err)
	}
	return oldValue.StripeProductID, nil
}

// ClearStripeProductID clears the value of the "stripe_product_id" field.
func (m *VoiceoverMutation) ClearStripeProductID() {
	m.stripe_product_id = nil
	m.clearedFields[voiceover.FieldStripeProductID] = struct{}{}
}

// StripeProductIDCleared returns if the "stripe_product_id" field was cleared in this mutation.
func (m *VoiceoverMutation) StripeProductIDCleared() bool {
	_, ok := m.clearedFields[voiceover.FieldStripeProductID]
	return ok
}

// ResetStripeProductID resets all changes to the "stripe_product_id" field.
func (m *VoiceoverMutation) ResetStripeProductID() {
	m.stripe_product_id = nil
	delete(m.clearedFields, voiceover.FieldStripeProductID)
}

// SetTemperature sets the "temperature" field.
func (m *VoiceoverMutation) SetTemperature(f float32) {
	m.temperature = &f
	m.addtemperature = nil
}

// Temperature returns the value of the "temperature" field in the mutation.
func (m *VoiceoverMutation) Temperature() (r float32, exists bool) {
	v := m.temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldTemperature returns the old "temperature" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldTemperature(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemperature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemperature: %w", err)
	}
	return oldValue.Temperature, nil
}

// AddTemperature adds f to the "temperature" field.
func (m *VoiceoverMutation) AddTemperature(f float32) {
	if m.addtemperature != nil {
		*m.addtemperature += f
	} else {
		m.addtemperature = &f
	}
}

// AddedTemperature returns the value that was added to the "temperature" field in this mutation.
func (m *VoiceoverMutation) AddedTemperature() (r float32, exists bool) {
	v := m.addtemperature
	if v == nil {
		return
	}
	return *v, true
}

// ResetTemperature resets all changes to the "temperature" field.
func (m *VoiceoverMutation) ResetTemperature() {
	m.temperature = nil
	m.addtemperature = nil
}

// SetSeed sets the "seed" field.
func (m *VoiceoverMutation) SetSeed(i int) {
	m.seed = &i
	m.addseed = nil
}

// Seed returns the value of the "seed" field in the mutation.
func (m *VoiceoverMutation) Seed() (r int, exists bool) {
	v := m.seed
	if v == nil {
		return
	}
	return *v, true
}

// OldSeed returns the old "seed" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldSeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeed: %w", err)
	}
	return oldValue.Seed, nil
}

// AddSeed adds i to the "seed" field.
func (m *VoiceoverMutation) AddSeed(i int) {
	if m.addseed != nil {
		*m.addseed += i
	} else {
		m.addseed = &i
	}
}

// AddedSeed returns the value that was added to the "seed" field in this mutation.
func (m *VoiceoverMutation) AddedSeed() (r int, exists bool) {
	v := m.addseed
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeed resets all changes to the "seed" field.
func (m *VoiceoverMutation) ResetSeed() {
	m.seed = nil
	m.addseed = nil
}

// SetWasAutoSubmitted sets the "was_auto_submitted" field.
func (m *VoiceoverMutation) SetWasAutoSubmitted(b bool) {
	m.was_auto_submitted = &b
}

// WasAutoSubmitted returns the value of the "was_auto_submitted" field in the mutation.
func (m *VoiceoverMutation) WasAutoSubmitted() (r bool, exists bool) {
	v := m.was_auto_submitted
	if v == nil {
		return
	}
	return *v, true
}

// OldWasAutoSubmitted returns the old "was_auto_submitted" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldWasAutoSubmitted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWasAutoSubmitted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWasAutoSubmitted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWasAutoSubmitted: %w", err)
	}
	return oldValue.WasAutoSubmitted, nil
}

// ResetWasAutoSubmitted resets all changes to the "was_auto_submitted" field.
func (m *VoiceoverMutation) ResetWasAutoSubmitted() {
	m.was_auto_submitted = nil
}

// SetDenoiseAudio sets the "denoise_audio" field.
func (m *VoiceoverMutation) SetDenoiseAudio(b bool) {
	m.denoise_audio = &b
}

// DenoiseAudio returns the value of the "denoise_audio" field in the mutation.
func (m *VoiceoverMutation) DenoiseAudio() (r bool, exists bool) {
	v := m.denoise_audio
	if v == nil {
		return
	}
	return *v, true
}

// OldDenoiseAudio returns the old "denoise_audio" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldDenoiseAudio(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDenoiseAudio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDenoiseAudio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDenoiseAudio: %w", err)
	}
	return oldValue.DenoiseAudio, nil
}

// ResetDenoiseAudio resets all changes to the "denoise_audio" field.
func (m *VoiceoverMutation) ResetDenoiseAudio() {
	m.denoise_audio = nil
}

// SetRemoveSilence sets the "remove_silence" field.
func (m *VoiceoverMutation) SetRemoveSilence(b bool) {
	m.remove_silence = &b
}

// RemoveSilence returns the value of the "remove_silence" field in the mutation.
func (m *VoiceoverMutation) RemoveSilence() (r bool, exists bool) {
	v := m.remove_silence
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoveSilence returns the old "remove_silence" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldRemoveSilence(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoveSilence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoveSilence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoveSilence: %w", err)
	}
	return oldValue.RemoveSilence, nil
}

// ResetRemoveSilence resets all changes to the "remove_silence" field.
func (m *VoiceoverMutation) ResetRemoveSilence() {
	m.remove_silence = nil
}

// SetCost sets the "cost" field.
func (m *VoiceoverMutation) SetCost(i int32) {
	m.cost = &i
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *VoiceoverMutation) Cost() (r int32, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldCost(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds i to the "cost" field.
func (m *VoiceoverMutation) AddCost(i int32) {
	if m.addcost != nil {
		*m.addcost += i
	} else {
		m.addcost = &i
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *VoiceoverMutation) AddedCost() (r int32, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost resets all changes to the "cost" field.
func (m *VoiceoverMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// SetSourceType sets the "source_type" field.
func (m *VoiceoverMutation) SetSourceType(et enttypes.SourceType) {
	m.source_type = &et
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *VoiceoverMutation) SourceType() (r enttypes.SourceType, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldSourceType(ctx context.Context) (v enttypes.SourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *VoiceoverMutation) ResetSourceType() {
	m.source_type = nil
}

// SetPromptID sets the "prompt_id" field.
func (m *VoiceoverMutation) SetPromptID(u uuid.UUID) {
	m.prompt = &u
}

// PromptID returns the value of the "prompt_id" field in the mutation.
func (m *VoiceoverMutation) PromptID() (r uuid.UUID, exists bool) {
	v := m.prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptID returns the old "prompt_id" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldPromptID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptID: %w", err)
	}
	return oldValue.PromptID, nil
}

// ClearPromptID clears the value of the "prompt_id" field.
func (m *VoiceoverMutation) ClearPromptID() {
	m.prompt = nil
	m.clearedFields[voiceover.FieldPromptID] = struct{}{}
}

// PromptIDCleared returns if the "prompt_id" field was cleared in this mutation.
func (m *VoiceoverMutation) PromptIDCleared() bool {
	_, ok := m.clearedFields[voiceover.FieldPromptID]
	return ok
}

// ResetPromptID resets all changes to the "prompt_id" field.
func (m *VoiceoverMutation) ResetPromptID() {
	m.prompt = nil
	delete(m.clearedFields, voiceover.FieldPromptID)
}

// SetUserID sets the "user_id" field.
func (m *VoiceoverMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VoiceoverMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VoiceoverMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceInfoID sets the "device_info_id" field.
func (m *VoiceoverMutation) SetDeviceInfoID(u uuid.UUID) {
	m.device_info = &u
}

// DeviceInfoID returns the value of the "device_info_id" field in the mutation.
func (m *VoiceoverMutation) DeviceInfoID() (r uuid.UUID, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfoID returns the old "device_info_id" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldDeviceInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfoID: %w", err)
	}
	return oldValue.DeviceInfoID, nil
}

// ResetDeviceInfoID resets all changes to the "device_info_id" field.
func (m *VoiceoverMutation) ResetDeviceInfoID() {
	m.device_info = nil
}

// SetModelID sets the "model_id" field.
func (m *VoiceoverMutation) SetModelID(u uuid.UUID) {
	m.voiceover_models = &u
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *VoiceoverMutation) ModelID() (r uuid.UUID, exists bool) {
	v := m.voiceover_models
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldModelID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *VoiceoverMutation) ResetModelID() {
	m.voiceover_models = nil
}

// SetSpeakerID sets the "speaker_id" field.
func (m *VoiceoverMutation) SetSpeakerID(u uuid.UUID) {
	m.voiceover_speakers = &u
}

// SpeakerID returns the value of the "speaker_id" field in the mutation.
func (m *VoiceoverMutation) SpeakerID() (r uuid.UUID, exists bool) {
	v := m.voiceover_speakers
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeakerID returns the old "speaker_id" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldSpeakerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeakerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeakerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeakerID: %w", err)
	}
	return oldValue.SpeakerID, nil
}

// ResetSpeakerID resets all changes to the "speaker_id" field.
func (m *VoiceoverMutation) ResetSpeakerID() {
	m.voiceover_speakers = nil
}

// SetAPITokenID sets the "api_token_id" field.
func (m *VoiceoverMutation) SetAPITokenID(u uuid.UUID) {
	m.api_tokens = &u
}

// APITokenID returns the value of the "api_token_id" field in the mutation.
func (m *VoiceoverMutation) APITokenID() (r uuid.UUID, exists bool) {
	v := m.api_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldAPITokenID returns the old "api_token_id" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldAPITokenID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPITokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPITokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPITokenID: %w", err)
	}
	return oldValue.APITokenID, nil
}

// ClearAPITokenID clears the value of the "api_token_id" field.
func (m *VoiceoverMutation) ClearAPITokenID() {
	m.api_tokens = nil
	m.clearedFields[voiceover.FieldAPITokenID] = struct{}{}
}

// APITokenIDCleared returns if the "api_token_id" field was cleared in this mutation.
func (m *VoiceoverMutation) APITokenIDCleared() bool {
	_, ok := m.clearedFields[voiceover.FieldAPITokenID]
	return ok
}

// ResetAPITokenID resets all changes to the "api_token_id" field.
func (m *VoiceoverMutation) ResetAPITokenID() {
	m.api_tokens = nil
	delete(m.clearedFields, voiceover.FieldAPITokenID)
}

// SetStartedAt sets the "started_at" field.
func (m *VoiceoverMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *VoiceoverMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *VoiceoverMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[voiceover.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *VoiceoverMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[voiceover.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *VoiceoverMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, voiceover.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *VoiceoverMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *VoiceoverMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *VoiceoverMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[voiceover.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *VoiceoverMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[voiceover.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *VoiceoverMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, voiceover.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *VoiceoverMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VoiceoverMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VoiceoverMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VoiceoverMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VoiceoverMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Voiceover entity.
// If the Voiceover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VoiceoverMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *VoiceoverMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VoiceoverMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VoiceoverMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VoiceoverMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearPrompt clears the "prompt" edge to the Prompt entity.
func (m *VoiceoverMutation) ClearPrompt() {
	m.clearedprompt = true
}

// PromptCleared reports if the "prompt" edge to the Prompt entity was cleared.
func (m *VoiceoverMutation) PromptCleared() bool {
	return m.PromptIDCleared() || m.clearedprompt
}

// PromptIDs returns the "prompt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PromptID instead. It exists only for internal usage by the builders.
func (m *VoiceoverMutation) PromptIDs() (ids []uuid.UUID) {
	if id := m.prompt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrompt resets all changes to the "prompt" edge.
func (m *VoiceoverMutation) ResetPrompt() {
	m.prompt = nil
	m.clearedprompt = false
}

// ClearDeviceInfo clears the "device_info" edge to the DeviceInfo entity.
func (m *VoiceoverMutation) ClearDeviceInfo() {
	m.cleareddevice_info = true
}

// DeviceInfoCleared reports if the "device_info" edge to the DeviceInfo entity was cleared.
func (m *VoiceoverMutation) DeviceInfoCleared() bool {
	return m.cleareddevice_info
}

// DeviceInfoIDs returns the "device_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceInfoID instead. It exists only for internal usage by the builders.
func (m *VoiceoverMutation) DeviceInfoIDs() (ids []uuid.UUID) {
	if id := m.device_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeviceInfo resets all changes to the "device_info" edge.
func (m *VoiceoverMutation) ResetDeviceInfo() {
	m.device_info = nil
	m.cleareddevice_info = false
}

// SetVoiceoverModelsID sets the "voiceover_models" edge to the VoiceoverModel entity by id.
func (m *VoiceoverMutation) SetVoiceoverModelsID(id uuid.UUID) {
	m.voiceover_models = &id
}

// ClearVoiceoverModels clears the "voiceover_models" edge to the VoiceoverModel entity.
func (m *VoiceoverMutation) ClearVoiceoverModels() {
	m.clearedvoiceover_models = true
}

// VoiceoverModelsCleared reports if the "voiceover_models" edge to the VoiceoverModel entity was cleared.
func (m *VoiceoverMutation) VoiceoverModelsCleared() bool {
	return m.clearedvoiceover_models
}

// VoiceoverModelsID returns the "voiceover_models" edge ID in the mutation.
func (m *VoiceoverMutation) VoiceoverModelsID() (id uuid.UUID, exists bool) {
	if m.voiceover_models != nil {
		return *m.voiceover_models, true
	}
	return
}

// VoiceoverModelsIDs returns the "voiceover_models" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VoiceoverModelsID instead. It exists only for internal usage by the builders.
func (m *VoiceoverMutation) VoiceoverModelsIDs() (ids []uuid.UUID) {
	if id := m.voiceover_models; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVoiceoverModels resets all changes to the "voiceover_models" edge.
func (m *VoiceoverMutation) ResetVoiceoverModels() {
	m.voiceover_models = nil
	m.clearedvoiceover_models = false
}

// SetVoiceoverSpeakersID sets the "voiceover_speakers" edge to the VoiceoverSpeaker entity by id.
func (m *VoiceoverMutation) SetVoiceoverSpeakersID(id uuid.UUID) {
	m.voiceover_speakers = &id
}

// ClearVoiceoverSpeakers clears the "voiceover_speakers" edge to the VoiceoverSpeaker entity.
func (m *VoiceoverMutation) ClearVoiceoverSpeakers() {
	m.clearedvoiceover_speakers = true
}

// VoiceoverSpeakersCleared reports if the "voiceover_speakers" edge to the VoiceoverSpeaker entity was cleared.
func (m *VoiceoverMutation) VoiceoverSpeakersCleared() bool {
	return m.clearedvoiceover_speakers
}

// VoiceoverSpeakersID returns the "voiceover_speakers" edge ID in the mutation.
func (m *VoiceoverMutation) VoiceoverSpeakersID() (id uuid.UUID, exists bool) {
	if m.voiceover_speakers != nil {
		return *m.voiceover_speakers, true
	}
	return
}

// VoiceoverSpeakersIDs returns the "voiceover_speakers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VoiceoverSpeakersID instead. It exists only for internal usage by the builders.
func (m *VoiceoverMutation) VoiceoverSpeakersIDs() (ids []uuid.UUID) {
	if id := m.voiceover_speakers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVoiceoverSpeakers resets all changes to the "voiceover_speakers" edge.
func (m *VoiceoverMutation) ResetVoiceoverSpeakers() {
	m.voiceover_speakers = nil
	m.clearedvoiceover_speakers = false
}

// SetAPITokensID sets the "api_tokens" edge to the ApiToken entity by id.
func (m *VoiceoverMutation) SetAPITokensID(id uuid.UUID) {
	m.api_tokens = &id
}

// ClearAPITokens clears the "api_tokens" edge to the ApiToken entity.
func (m *VoiceoverMutation) ClearAPITokens() {
	m.clearedapi_tokens = true
}

// APITokensCleared reports if the "api_tokens" edge to the ApiToken entity was cleared.
func (m *VoiceoverMutation) APITokensCleared() bool {
	return m.APITokenIDCleared() || m.clearedapi_tokens
}

// APITokensID returns the "api_tokens" edge ID in the mutation.
func (m *VoiceoverMutation) APITokensID() (id uuid.UUID, exists bool) {
	if m.api_tokens != nil {
		return *m.api_tokens, true
	}
	return
}

// APITokensIDs returns the "api_tokens" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// APITokensID instead. It exists only for internal usage by the builders.
func (m *VoiceoverMutation) APITokensIDs() (ids []uuid.UUID) {
	if id := m.api_tokens; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAPITokens resets all changes to the "api_tokens" edge.
func (m *VoiceoverMutation) ResetAPITokens() {
	m.api_tokens = nil
	m.clearedapi_tokens = false
}

// AddVoiceoverOutputIDs adds the "voiceover_outputs" edge to the VoiceoverOutput entity by ids.
func (m *VoiceoverMutation) AddVoiceoverOutputIDs(ids ...uuid.UUID) {
	if m.voiceover_outputs == nil {
		m.voiceover_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.voiceover_outputs[ids[i]] = struct{}{}
	}
}

// ClearVoiceoverOutputs clears the "voiceover_outputs" edge to the VoiceoverOutput entity.
func (m *VoiceoverMutation) ClearVoiceoverOutputs() {
	m.clearedvoiceover_outputs = true
}

// VoiceoverOutputsCleared reports if the "voiceover_outputs" edge to the VoiceoverOutput entity was cleared.
func (m *VoiceoverMutation) VoiceoverOutputsCleared() bool {
	return m.clearedvoiceover_outputs
}

// RemoveVoiceoverOutputIDs removes the "voiceover_outputs" edge to the VoiceoverOutput entity by IDs.
func (m *VoiceoverMutation) RemoveVoiceoverOutputIDs(ids ...uuid.UUID) {
	if m.removedvoiceover_outputs == nil {
		m.removedvoiceover_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.voiceover_outputs, ids[i])
		m.removedvoiceover_outputs[ids[i]] = struct{}{}
	}
}

// RemovedVoiceoverOutputs returns the removed IDs of the "voiceover_outputs" edge to the VoiceoverOutput entity.
func (m *VoiceoverMutation) RemovedVoiceoverOutputsIDs() (ids []uuid.UUID) {
	for id := range m.removedvoiceover_outputs {
		ids = append(ids, id)
	}
	return
}

// VoiceoverOutputsIDs returns the "voiceover_outputs" edge IDs in the mutation.
func (m *VoiceoverMutation) VoiceoverOutputsIDs() (ids []uuid.UUID) {
	for id := range m.voiceover_outputs {
		ids = append(ids, id)
	}
	return
}

// ResetVoiceoverOutputs resets all changes to the "voiceover_outputs" edge.
func (m *VoiceoverMutation) ResetVoiceoverOutputs() {
	m.voiceover_outputs = nil
	m.clearedvoiceover_outputs = false
	m.removedvoiceover_outputs = nil
}

// Where appends a list predicates to the VoiceoverMutation builder.
func (m *VoiceoverMutation) Where(ps ...predicate.Voiceover) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoiceoverMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoiceoverMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Voiceover, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoiceoverMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoiceoverMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Voiceover).
func (m *VoiceoverMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoiceoverMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.country_code != nil {
		fields = append(fields, voiceover.FieldCountryCode)
	}
	if m.status != nil {
		fields = append(fields, voiceover.FieldStatus)
	}
	if m.failure_reason != nil {
		fields = append(fields, voiceover.FieldFailureReason)
	}
	if m.stripe_product_id != nil {
		fields = append(fields, voiceover.FieldStripeProductID)
	}
	if m.temperature != nil {
		fields = append(fields, voiceover.FieldTemperature)
	}
	if m.seed != nil {
		fields = append(fields, voiceover.FieldSeed)
	}
	if m.was_auto_submitted != nil {
		fields = append(fields, voiceover.FieldWasAutoSubmitted)
	}
	if m.denoise_audio != nil {
		fields = append(fields, voiceover.FieldDenoiseAudio)
	}
	if m.remove_silence != nil {
		fields = append(fields, voiceover.FieldRemoveSilence)
	}
	if m.cost != nil {
		fields = append(fields, voiceover.FieldCost)
	}
	if m.source_type != nil {
		fields = append(fields, voiceover.FieldSourceType)
	}
	if m.prompt != nil {
		fields = append(fields, voiceover.FieldPromptID)
	}
	if m.user != nil {
		fields = append(fields, voiceover.FieldUserID)
	}
	if m.device_info != nil {
		fields = append(fields, voiceover.FieldDeviceInfoID)
	}
	if m.voiceover_models != nil {
		fields = append(fields, voiceover.FieldModelID)
	}
	if m.voiceover_speakers != nil {
		fields = append(fields, voiceover.FieldSpeakerID)
	}
	if m.api_tokens != nil {
		fields = append(fields, voiceover.FieldAPITokenID)
	}
	if m.started_at != nil {
		fields = append(fields, voiceover.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, voiceover.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, voiceover.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, voiceover.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoiceoverMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case voiceover.FieldCountryCode:
		return m.CountryCode()
	case voiceover.FieldStatus:
		return m.Status()
	case voiceover.FieldFailureReason:
		return m.FailureReason()
	case voiceover.FieldStripeProductID:
		return m.StripeProductID()
	case voiceover.FieldTemperature:
		return m.Temperature()
	case voiceover.FieldSeed:
		return m.Seed()
	case voiceover.FieldWasAutoSubmitted:
		return m.WasAutoSubmitted()
	case voiceover.FieldDenoiseAudio:
		return m.DenoiseAudio()
	case voiceover.FieldRemoveSilence:
		return m.RemoveSilence()
	case voiceover.FieldCost:
		return m.Cost()
	case voiceover.FieldSourceType:
		return m.SourceType()
	case voiceover.FieldPromptID:
		return m.PromptID()
	case voiceover.FieldUserID:
		return m.UserID()
	case voiceover.FieldDeviceInfoID:
		return m.DeviceInfoID()
	case voiceover.FieldModelID:
		return m.ModelID()
	case voiceover.FieldSpeakerID:
		return m.SpeakerID()
	case voiceover.FieldAPITokenID:
		return m.APITokenID()
	case voiceover.FieldStartedAt:
		return m.StartedAt()
	case voiceover.FieldCompletedAt:
		return m.CompletedAt()
	case voiceover.FieldCreatedAt:
		return m.CreatedAt()
	case voiceover.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoiceoverMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case voiceover.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case voiceover.FieldStatus:
		return m.OldStatus(ctx)
	case voiceover.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case voiceover.FieldStripeProductID:
		return m.OldStripeProductID(ctx)
	case voiceover.FieldTemperature:
		return m.OldTemperature(ctx)
	case voiceover.FieldSeed:
		return m.OldSeed(ctx)
	case voiceover.FieldWasAutoSubmitted:
		return m.OldWasAutoSubmitted(ctx)
	case voiceover.FieldDenoiseAudio:
		return m.OldDenoiseAudio(ctx)
	case voiceover.FieldRemoveSilence:
		return m.OldRemoveSilence(ctx)
	case voiceover.FieldCost:
		return m.OldCost(ctx)
	case voiceover.FieldSourceType:
		return m.OldSourceType(ctx)
	case voiceover.FieldPromptID:
		return m.OldPromptID(ctx)
	case voiceover.FieldUserID:
		return m.OldUserID(ctx)
	case voiceover.FieldDeviceInfoID:
		return m.OldDeviceInfoID(ctx)
	case voiceover.FieldModelID:
		return m.OldModelID(ctx)
	case voiceover.FieldSpeakerID:
		return m.OldSpeakerID(ctx)
	case voiceover.FieldAPITokenID:
		return m.OldAPITokenID(ctx)
	case voiceover.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case voiceover.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case voiceover.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case voiceover.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Voiceover field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoiceoverMutation) SetField(name string, value ent.Value) error {
	switch name {
	case voiceover.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case voiceover.FieldStatus:
		v, ok := value.(voiceover.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case voiceover.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case voiceover.FieldStripeProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeProductID(v)
		return nil
	case voiceover.FieldTemperature:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemperature(v)
		return nil
	case voiceover.FieldSeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeed(v)
		return nil
	case voiceover.FieldWasAutoSubmitted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWasAutoSubmitted(v)
		return nil
	case voiceover.FieldDenoiseAudio:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDenoiseAudio(v)
		return nil
	case voiceover.FieldRemoveSilence:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoveSilence(v)
		return nil
	case voiceover.FieldCost:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case voiceover.FieldSourceType:
		v, ok := value.(enttypes.SourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case voiceover.FieldPromptID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptID(v)
		return nil
	case voiceover.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case voiceover.FieldDeviceInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfoID(v)
		return nil
	case voiceover.FieldModelID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case voiceover.FieldSpeakerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeakerID(v)
		return nil
	case voiceover.FieldAPITokenID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPITokenID(v)
		return nil
	case voiceover.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case voiceover.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case voiceover.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case voiceover.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Voiceover field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoiceoverMutation) AddedFields() []string {
	var fields []string
	if m.addtemperature != nil {
		fields = append(fields, voiceover.FieldTemperature)
	}
	if m.addseed != nil {
		fields = append(fields, voiceover.FieldSeed)
	}
	if m.addcost != nil {
		fields = append(fields, voiceover.FieldCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoiceoverMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case voiceover.FieldTemperature:
		return m.AddedTemperature()
	case voiceover.FieldSeed:
		return m.AddedSeed()
	case voiceover.FieldCost:
		return m.AddedCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoiceoverMutation) AddField(name string, value ent.Value) error {
	switch name {
	case voiceover.FieldTemperature:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemperature(v)
		return nil
	case voiceover.FieldSeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeed(v)
		return nil
	case voiceover.FieldCost:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	}
	return fmt.Errorf("unknown Voiceover numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoiceoverMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(voiceover.FieldCountryCode) {
		fields = append(fields, voiceover.FieldCountryCode)
	}
	if m.FieldCleared(voiceover.FieldFailureReason) {
		fields = append(fields, voiceover.FieldFailureReason)
	}
	if m.FieldCleared(voiceover.FieldStripeProductID) {
		fields = append(fields, voiceover.FieldStripeProductID)
	}
	if m.FieldCleared(voiceover.FieldPromptID) {
		fields = append(fields, voiceover.FieldPromptID)
	}
	if m.FieldCleared(voiceover.FieldAPITokenID) {
		fields = append(fields, voiceover.FieldAPITokenID)
	}
	if m.FieldCleared(voiceover.FieldStartedAt) {
		fields = append(fields, voiceover.FieldStartedAt)
	}
	if m.FieldCleared(voiceover.FieldCompletedAt) {
		fields = append(fields, voiceover.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoiceoverMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoiceoverMutation) ClearField(name string) error {
	switch name {
	case voiceover.FieldCountryCode:
		m.ClearCountryCode()
		return nil
	case voiceover.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	case voiceover.FieldStripeProductID:
		m.ClearStripeProductID()
		return nil
	case voiceover.FieldPromptID:
		m.ClearPromptID()
		return nil
	case voiceover.FieldAPITokenID:
		m.ClearAPITokenID()
		return nil
	case voiceover.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case voiceover.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Voiceover nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoiceoverMutation) ResetField(name string) error {
	switch name {
	case voiceover.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case voiceover.FieldStatus:
		m.ResetStatus()
		return nil
	case voiceover.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case voiceover.FieldStripeProductID:
		m.ResetStripeProductID()
		return nil
	case voiceover.FieldTemperature:
		m.ResetTemperature()
		return nil
	case voiceover.FieldSeed:
		m.ResetSeed()
		return nil
	case voiceover.FieldWasAutoSubmitted:
		m.ResetWasAutoSubmitted()
		return nil
	case voiceover.FieldDenoiseAudio:
		m.ResetDenoiseAudio()
		return nil
	case voiceover.FieldRemoveSilence:
		m.ResetRemoveSilence()
		return nil
	case voiceover.FieldCost:
		m.ResetCost()
		return nil
	case voiceover.FieldSourceType:
		m.ResetSourceType()
		return nil
	case voiceover.FieldPromptID:
		m.ResetPromptID()
		return nil
	case voiceover.FieldUserID:
		m.ResetUserID()
		return nil
	case voiceover.FieldDeviceInfoID:
		m.ResetDeviceInfoID()
		return nil
	case voiceover.FieldModelID:
		m.ResetModelID()
		return nil
	case voiceover.FieldSpeakerID:
		m.ResetSpeakerID()
		return nil
	case voiceover.FieldAPITokenID:
		m.ResetAPITokenID()
		return nil
	case voiceover.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case voiceover.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case voiceover.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case voiceover.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Voiceover field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoiceoverMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.user != nil {
		edges = append(edges, voiceover.EdgeUser)
	}
	if m.prompt != nil {
		edges = append(edges, voiceover.EdgePrompt)
	}
	if m.device_info != nil {
		edges = append(edges, voiceover.EdgeDeviceInfo)
	}
	if m.voiceover_models != nil {
		edges = append(edges, voiceover.EdgeVoiceoverModels)
	}
	if m.voiceover_speakers != nil {
		edges = append(edges, voiceover.EdgeVoiceoverSpeakers)
	}
	if m.api_tokens != nil {
		edges = append(edges, voiceover.EdgeAPITokens)
	}
	if m.voiceover_outputs != nil {
		edges = append(edges, voiceover.EdgeVoiceoverOutputs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoiceoverMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case voiceover.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case voiceover.EdgePrompt:
		if id := m.prompt; id != nil {
			return []ent.Value{*id}
		}
	case voiceover.EdgeDeviceInfo:
		if id := m.device_info; id != nil {
			return []ent.Value{*id}
		}
	case voiceover.EdgeVoiceoverModels:
		if id := m.voiceover_models; id != nil {
			return []ent.Value{*id}
		}
	case voiceover.EdgeVoiceoverSpeakers:
		if id := m.voiceover_speakers; id != nil {
			return []ent.Value{*id}
		}
	case voiceover.EdgeAPITokens:
		if id := m.api_tokens; id != nil {
			return []ent.Value{*id}
		}
	case voiceover.EdgeVoiceoverOutputs:
		ids := make([]ent.Value, 0, len(m.voiceover_outputs))
		for id := range m.voiceover_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoiceoverMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedvoiceover_outputs != nil {
		edges = append(edges, voiceover.EdgeVoiceoverOutputs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoiceoverMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case voiceover.EdgeVoiceoverOutputs:
		ids := make([]ent.Value, 0, len(m.removedvoiceover_outputs))
		for id := range m.removedvoiceover_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoiceoverMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleareduser {
		edges = append(edges, voiceover.EdgeUser)
	}
	if m.clearedprompt {
		edges = append(edges, voiceover.EdgePrompt)
	}
	if m.cleareddevice_info {
		edges = append(edges, voiceover.EdgeDeviceInfo)
	}
	if m.clearedvoiceover_models {
		edges = append(edges, voiceover.EdgeVoiceoverModels)
	}
	if m.clearedvoiceover_speakers {
		edges = append(edges, voiceover.EdgeVoiceoverSpeakers)
	}
	if m.clearedapi_tokens {
		edges = append(edges, voiceover.EdgeAPITokens)
	}
	if m.clearedvoiceover_outputs {
		edges = append(edges, voiceover.EdgeVoiceoverOutputs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoiceoverMutation) EdgeCleared(name string) bool {
	switch name {
	case voiceover.EdgeUser:
		return m.cleareduser
	case voiceover.EdgePrompt:
		return m.clearedprompt
	case voiceover.EdgeDeviceInfo:
		return m.cleareddevice_info
	case voiceover.EdgeVoiceoverModels:
		return m.clearedvoiceover_models
	case voiceover.EdgeVoiceoverSpeakers:
		return m.clearedvoiceover_speakers
	case voiceover.EdgeAPITokens:
		return m.clearedapi_tokens
	case voiceover.EdgeVoiceoverOutputs:
		return m.clearedvoiceover_outputs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoiceoverMutation) ClearEdge(name string) error {
	switch name {
	case voiceover.EdgeUser:
		m.ClearUser()
		return nil
	case voiceover.EdgePrompt:
		m.ClearPrompt()
		return nil
	case voiceover.EdgeDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case voiceover.EdgeVoiceoverModels:
		m.ClearVoiceoverModels()
		return nil
	case voiceover.EdgeVoiceoverSpeakers:
		m.ClearVoiceoverSpeakers()
		return nil
	case voiceover.EdgeAPITokens:
		m.ClearAPITokens()
		return nil
	}
	return fmt.Errorf("unknown Voiceover unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoiceoverMutation) ResetEdge(name string) error {
	switch name {
	case voiceover.EdgeUser:
		m.ResetUser()
		return nil
	case voiceover.EdgePrompt:
		m.ResetPrompt()
		return nil
	case voiceover.EdgeDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case voiceover.EdgeVoiceoverModels:
		m.ResetVoiceoverModels()
		return nil
	case voiceover.EdgeVoiceoverSpeakers:
		m.ResetVoiceoverSpeakers()
		return nil
	case voiceover.EdgeAPITokens:
		m.ResetAPITokens()
		return nil
	case voiceover.EdgeVoiceoverOutputs:
		m.ResetVoiceoverOutputs()
		return nil
	}
	return fmt.Errorf("unknown Voiceover edge %s", name)
}

// VoiceoverModelMutation represents an operation that mutates the VoiceoverModel nodes in the graph.
type VoiceoverModelMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	name_in_worker            *string
	is_active                 *bool
	is_default                *bool
	is_hidden                 *bool
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	voiceovers                map[uuid.UUID]struct{}
	removedvoiceovers         map[uuid.UUID]struct{}
	clearedvoiceovers         bool
	voiceover_speakers        map[uuid.UUID]struct{}
	removedvoiceover_speakers map[uuid.UUID]struct{}
	clearedvoiceover_speakers bool
	done                      bool
	oldValue                  func(context.Context) (*VoiceoverModel, error)
	predicates                []predicate.VoiceoverModel
}

var _ ent.Mutation = (*VoiceoverModelMutation)(nil)

// voiceovermodelOption allows management of the mutation configuration using functional options.
type voiceovermodelOption func(*VoiceoverModelMutation)

// newVoiceoverModelMutation creates new mutation for the VoiceoverModel entity.
func newVoiceoverModelMutation(c config, op Op, opts ...voiceovermodelOption) *VoiceoverModelMutation {
	m := &VoiceoverModelMutation{
		config:        c,
		op:            op,
		typ:           TypeVoiceoverModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoiceoverModelID sets the ID field of the mutation.
func withVoiceoverModelID(id uuid.UUID) voiceovermodelOption {
	return func(m *VoiceoverModelMutation) {
		var (
			err   error
			once  sync.Once
			value *VoiceoverModel
		)
		m.oldValue = func(ctx context.Context) (*VoiceoverModel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VoiceoverModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVoiceoverModel sets the old VoiceoverModel of the mutation.
func withVoiceoverModel(node *VoiceoverModel) voiceovermodelOption {
	return func(m *VoiceoverModelMutation) {
		m.oldValue = func(context.Context) (*VoiceoverModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoiceoverModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoiceoverModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VoiceoverModel entities.
func (m *VoiceoverModelMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoiceoverModelMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoiceoverModelMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VoiceoverModel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameInWorker sets the "name_in_worker" field.
func (m *VoiceoverModelMutation) SetNameInWorker(s string) {
	m.name_in_worker = &s
}

// NameInWorker returns the value of the "name_in_worker" field in the mutation.
func (m *VoiceoverModelMutation) NameInWorker() (r string, exists bool) {
	v := m.name_in_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldNameInWorker returns the old "name_in_worker" field's value of the VoiceoverModel entity.
// If the VoiceoverModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverModelMutation) OldNameInWorker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameInWorker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameInWorker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameInWorker: %w", err)
	}
	return oldValue.NameInWorker, nil
}

// ResetNameInWorker resets all changes to the "name_in_worker" field.
func (m *VoiceoverModelMutation) ResetNameInWorker() {
	m.name_in_worker = nil
}

// SetIsActive sets the "is_active" field.
func (m *VoiceoverModelMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *VoiceoverModelMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the VoiceoverModel entity.
// If the VoiceoverModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverModelMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *VoiceoverModelMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsDefault sets the "is_default" field.
func (m *VoiceoverModelMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *VoiceoverModelMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the VoiceoverModel entity.
// If the VoiceoverModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverModelMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *VoiceoverModelMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *VoiceoverModelMutation) SetIsHidden(b bool) {
	m.is_hidden = &b
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *VoiceoverModelMutation) IsHidden() (r bool, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the VoiceoverModel entity.
// If the VoiceoverModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverModelMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *VoiceoverModelMutation) ResetIsHidden() {
	m.is_hidden = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VoiceoverModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VoiceoverModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VoiceoverModel entity.
// If the VoiceoverModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VoiceoverModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VoiceoverModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VoiceoverModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VoiceoverModel entity.
// If the VoiceoverModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VoiceoverModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddVoiceoverIDs adds the "voiceovers" edge to the Voiceover entity by ids.
func (m *VoiceoverModelMutation) AddVoiceoverIDs(ids ...uuid.UUID) {
	if m.voiceovers == nil {
		m.voiceovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.voiceovers[ids[i]] = struct{}{}
	}
}

// ClearVoiceovers clears the "voiceovers" edge to the Voiceover entity.
func (m *VoiceoverModelMutation) ClearVoiceovers() {
	m.clearedvoiceovers = true
}

// VoiceoversCleared reports if the "voiceovers" edge to the Voiceover entity was cleared.
func (m *VoiceoverModelMutation) VoiceoversCleared() bool {
	return m.clearedvoiceovers
}

// RemoveVoiceoverIDs removes the "voiceovers" edge to the Voiceover entity by IDs.
func (m *VoiceoverModelMutation) RemoveVoiceoverIDs(ids ...uuid.UUID) {
	if m.removedvoiceovers == nil {
		m.removedvoiceovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.voiceovers, ids[i])
		m.removedvoiceovers[ids[i]] = struct{}{}
	}
}

// RemovedVoiceovers returns the removed IDs of the "voiceovers" edge to the Voiceover entity.
func (m *VoiceoverModelMutation) RemovedVoiceoversIDs() (ids []uuid.UUID) {
	for id := range m.removedvoiceovers {
		ids = append(ids, id)
	}
	return
}

// VoiceoversIDs returns the "voiceovers" edge IDs in the mutation.
func (m *VoiceoverModelMutation) VoiceoversIDs() (ids []uuid.UUID) {
	for id := range m.voiceovers {
		ids = append(ids, id)
	}
	return
}

// ResetVoiceovers resets all changes to the "voiceovers" edge.
func (m *VoiceoverModelMutation) ResetVoiceovers() {
	m.voiceovers = nil
	m.clearedvoiceovers = false
	m.removedvoiceovers = nil
}

// AddVoiceoverSpeakerIDs adds the "voiceover_speakers" edge to the VoiceoverSpeaker entity by ids.
func (m *VoiceoverModelMutation) AddVoiceoverSpeakerIDs(ids ...uuid.UUID) {
	if m.voiceover_speakers == nil {
		m.voiceover_speakers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.voiceover_speakers[ids[i]] = struct{}{}
	}
}

// ClearVoiceoverSpeakers clears the "voiceover_speakers" edge to the VoiceoverSpeaker entity.
func (m *VoiceoverModelMutation) ClearVoiceoverSpeakers() {
	m.clearedvoiceover_speakers = true
}

// VoiceoverSpeakersCleared reports if the "voiceover_speakers" edge to the VoiceoverSpeaker entity was cleared.
func (m *VoiceoverModelMutation) VoiceoverSpeakersCleared() bool {
	return m.clearedvoiceover_speakers
}

// RemoveVoiceoverSpeakerIDs removes the "voiceover_speakers" edge to the VoiceoverSpeaker entity by IDs.
func (m *VoiceoverModelMutation) RemoveVoiceoverSpeakerIDs(ids ...uuid.UUID) {
	if m.removedvoiceover_speakers == nil {
		m.removedvoiceover_speakers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.voiceover_speakers, ids[i])
		m.removedvoiceover_speakers[ids[i]] = struct{}{}
	}
}

// RemovedVoiceoverSpeakers returns the removed IDs of the "voiceover_speakers" edge to the VoiceoverSpeaker entity.
func (m *VoiceoverModelMutation) RemovedVoiceoverSpeakersIDs() (ids []uuid.UUID) {
	for id := range m.removedvoiceover_speakers {
		ids = append(ids, id)
	}
	return
}

// VoiceoverSpeakersIDs returns the "voiceover_speakers" edge IDs in the mutation.
func (m *VoiceoverModelMutation) VoiceoverSpeakersIDs() (ids []uuid.UUID) {
	for id := range m.voiceover_speakers {
		ids = append(ids, id)
	}
	return
}

// ResetVoiceoverSpeakers resets all changes to the "voiceover_speakers" edge.
func (m *VoiceoverModelMutation) ResetVoiceoverSpeakers() {
	m.voiceover_speakers = nil
	m.clearedvoiceover_speakers = false
	m.removedvoiceover_speakers = nil
}

// Where appends a list predicates to the VoiceoverModelMutation builder.
func (m *VoiceoverModelMutation) Where(ps ...predicate.VoiceoverModel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoiceoverModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoiceoverModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VoiceoverModel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoiceoverModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoiceoverModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VoiceoverModel).
func (m *VoiceoverModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoiceoverModelMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name_in_worker != nil {
		fields = append(fields, voiceovermodel.FieldNameInWorker)
	}
	if m.is_active != nil {
		fields = append(fields, voiceovermodel.FieldIsActive)
	}
	if m.is_default != nil {
		fields = append(fields, voiceovermodel.FieldIsDefault)
	}
	if m.is_hidden != nil {
		fields = append(fields, voiceovermodel.FieldIsHidden)
	}
	if m.created_at != nil {
		fields = append(fields, voiceovermodel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, voiceovermodel.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoiceoverModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case voiceovermodel.FieldNameInWorker:
		return m.NameInWorker()
	case voiceovermodel.FieldIsActive:
		return m.IsActive()
	case voiceovermodel.FieldIsDefault:
		return m.IsDefault()
	case voiceovermodel.FieldIsHidden:
		return m.IsHidden()
	case voiceovermodel.FieldCreatedAt:
		return m.CreatedAt()
	case voiceovermodel.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoiceoverModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case voiceovermodel.FieldNameInWorker:
		return m.OldNameInWorker(ctx)
	case voiceovermodel.FieldIsActive:
		return m.OldIsActive(ctx)
	case voiceovermodel.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case voiceovermodel.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case voiceovermodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case voiceovermodel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VoiceoverModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoiceoverModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case voiceovermodel.FieldNameInWorker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameInWorker(v)
		return nil
	case voiceovermodel.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case voiceovermodel.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case voiceovermodel.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case voiceovermodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case voiceovermodel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VoiceoverModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoiceoverModelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoiceoverModelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoiceoverModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VoiceoverModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoiceoverModelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoiceoverModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoiceoverModelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VoiceoverModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoiceoverModelMutation) ResetField(name string) error {
	switch name {
	case voiceovermodel.FieldNameInWorker:
		m.ResetNameInWorker()
		return nil
	case voiceovermodel.FieldIsActive:
		m.ResetIsActive()
		return nil
	case voiceovermodel.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case voiceovermodel.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case voiceovermodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case voiceovermodel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown VoiceoverModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoiceoverModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.voiceovers != nil {
		edges = append(edges, voiceovermodel.EdgeVoiceovers)
	}
	if m.voiceover_speakers != nil {
		edges = append(edges, voiceovermodel.EdgeVoiceoverSpeakers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoiceoverModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case voiceovermodel.EdgeVoiceovers:
		ids := make([]ent.Value, 0, len(m.voiceovers))
		for id := range m.voiceovers {
			ids = append(ids, id)
		}
		return ids
	case voiceovermodel.EdgeVoiceoverSpeakers:
		ids := make([]ent.Value, 0, len(m.voiceover_speakers))
		for id := range m.voiceover_speakers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoiceoverModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvoiceovers != nil {
		edges = append(edges, voiceovermodel.EdgeVoiceovers)
	}
	if m.removedvoiceover_speakers != nil {
		edges = append(edges, voiceovermodel.EdgeVoiceoverSpeakers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoiceoverModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case voiceovermodel.EdgeVoiceovers:
		ids := make([]ent.Value, 0, len(m.removedvoiceovers))
		for id := range m.removedvoiceovers {
			ids = append(ids, id)
		}
		return ids
	case voiceovermodel.EdgeVoiceoverSpeakers:
		ids := make([]ent.Value, 0, len(m.removedvoiceover_speakers))
		for id := range m.removedvoiceover_speakers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoiceoverModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvoiceovers {
		edges = append(edges, voiceovermodel.EdgeVoiceovers)
	}
	if m.clearedvoiceover_speakers {
		edges = append(edges, voiceovermodel.EdgeVoiceoverSpeakers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoiceoverModelMutation) EdgeCleared(name string) bool {
	switch name {
	case voiceovermodel.EdgeVoiceovers:
		return m.clearedvoiceovers
	case voiceovermodel.EdgeVoiceoverSpeakers:
		return m.clearedvoiceover_speakers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoiceoverModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown VoiceoverModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoiceoverModelMutation) ResetEdge(name string) error {
	switch name {
	case voiceovermodel.EdgeVoiceovers:
		m.ResetVoiceovers()
		return nil
	case voiceovermodel.EdgeVoiceoverSpeakers:
		m.ResetVoiceoverSpeakers()
		return nil
	}
	return fmt.Errorf("unknown VoiceoverModel edge %s", name)
}

// VoiceoverOutputMutation represents an operation that mutates the VoiceoverOutput nodes in the graph.
type VoiceoverOutputMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	audio_path        *string
	video_path        *string
	audio_array       *[]float64
	appendaudio_array []float64
	is_favorited      *bool
	audio_duration    *float32
	addaudio_duration *float32
	gallery_status    *voiceoveroutput.GalleryStatus
	deleted_at        *time.Time
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	voiceovers        *uuid.UUID
	clearedvoiceovers bool
	done              bool
	oldValue          func(context.Context) (*VoiceoverOutput, error)
	predicates        []predicate.VoiceoverOutput
}

var _ ent.Mutation = (*VoiceoverOutputMutation)(nil)

// voiceoveroutputOption allows management of the mutation configuration using functional options.
type voiceoveroutputOption func(*VoiceoverOutputMutation)

// newVoiceoverOutputMutation creates new mutation for the VoiceoverOutput entity.
func newVoiceoverOutputMutation(c config, op Op, opts ...voiceoveroutputOption) *VoiceoverOutputMutation {
	m := &VoiceoverOutputMutation{
		config:        c,
		op:            op,
		typ:           TypeVoiceoverOutput,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoiceoverOutputID sets the ID field of the mutation.
func withVoiceoverOutputID(id uuid.UUID) voiceoveroutputOption {
	return func(m *VoiceoverOutputMutation) {
		var (
			err   error
			once  sync.Once
			value *VoiceoverOutput
		)
		m.oldValue = func(ctx context.Context) (*VoiceoverOutput, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VoiceoverOutput.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVoiceoverOutput sets the old VoiceoverOutput of the mutation.
func withVoiceoverOutput(node *VoiceoverOutput) voiceoveroutputOption {
	return func(m *VoiceoverOutputMutation) {
		m.oldValue = func(context.Context) (*VoiceoverOutput, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoiceoverOutputMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoiceoverOutputMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VoiceoverOutput entities.
func (m *VoiceoverOutputMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoiceoverOutputMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoiceoverOutputMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VoiceoverOutput.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAudioPath sets the "audio_path" field.
func (m *VoiceoverOutputMutation) SetAudioPath(s string) {
	m.audio_path = &s
}

// AudioPath returns the value of the "audio_path" field in the mutation.
func (m *VoiceoverOutputMutation) AudioPath() (r string, exists bool) {
	v := m.audio_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAudioPath returns the old "audio_path" field's value of the VoiceoverOutput entity.
// If the VoiceoverOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverOutputMutation) OldAudioPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudioPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudioPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudioPath: %w", err)
	}
	return oldValue.AudioPath, nil
}

// ResetAudioPath resets all changes to the "audio_path" field.
func (m *VoiceoverOutputMutation) ResetAudioPath() {
	m.audio_path = nil
}

// SetVideoPath sets the "video_path" field.
func (m *VoiceoverOutputMutation) SetVideoPath(s string) {
	m.video_path = &s
}

// VideoPath returns the value of the "video_path" field in the mutation.
func (m *VoiceoverOutputMutation) VideoPath() (r string, exists bool) {
	v := m.video_path
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoPath returns the old "video_path" field's value of the VoiceoverOutput entity.
// If the VoiceoverOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverOutputMutation) OldVideoPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoPath: %w", err)
	}
	return oldValue.VideoPath, nil
}

// ClearVideoPath clears the value of the "video_path" field.
func (m *VoiceoverOutputMutation) ClearVideoPath() {
	m.video_path = nil
	m.clearedFields[voiceoveroutput.FieldVideoPath] = struct{}{}
}

// VideoPathCleared returns if the "video_path" field was cleared in this mutation.
func (m *VoiceoverOutputMutation) VideoPathCleared() bool {
	_, ok := m.clearedFields[voiceoveroutput.FieldVideoPath]
	return ok
}

// ResetVideoPath resets all changes to the "video_path" field.
func (m *VoiceoverOutputMutation) ResetVideoPath() {
	m.video_path = nil
	delete(m.clearedFields, voiceoveroutput.FieldVideoPath)
}

// SetAudioArray sets the "audio_array" field.
func (m *VoiceoverOutputMutation) SetAudioArray(f []float64) {
	m.audio_array = &f
	m.appendaudio_array = nil
}

// AudioArray returns the value of the "audio_array" field in the mutation.
func (m *VoiceoverOutputMutation) AudioArray() (r []float64, exists bool) {
	v := m.audio_array
	if v == nil {
		return
	}
	return *v, true
}

// OldAudioArray returns the old "audio_array" field's value of the VoiceoverOutput entity.
// If the VoiceoverOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverOutputMutation) OldAudioArray(ctx context.Context) (v []float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudioArray is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudioArray requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudioArray: %w", err)
	}
	return oldValue.AudioArray, nil
}

// AppendAudioArray adds f to the "audio_array" field.
func (m *VoiceoverOutputMutation) AppendAudioArray(f []float64) {
	m.appendaudio_array = append(m.appendaudio_array, f...)
}

// AppendedAudioArray returns the list of values that were appended to the "audio_array" field in this mutation.
func (m *VoiceoverOutputMutation) AppendedAudioArray() ([]float64, bool) {
	if len(m.appendaudio_array) == 0 {
		return nil, false
	}
	return m.appendaudio_array, true
}

// ClearAudioArray clears the value of the "audio_array" field.
func (m *VoiceoverOutputMutation) ClearAudioArray() {
	m.audio_array = nil
	m.appendaudio_array = nil
	m.clearedFields[voiceoveroutput.FieldAudioArray] = struct{}{}
}

// AudioArrayCleared returns if the "audio_array" field was cleared in this mutation.
func (m *VoiceoverOutputMutation) AudioArrayCleared() bool {
	_, ok := m.clearedFields[voiceoveroutput.FieldAudioArray]
	return ok
}

// ResetAudioArray resets all changes to the "audio_array" field.
func (m *VoiceoverOutputMutation) ResetAudioArray() {
	m.audio_array = nil
	m.appendaudio_array = nil
	delete(m.clearedFields, voiceoveroutput.FieldAudioArray)
}

// SetIsFavorited sets the "is_favorited" field.
func (m *VoiceoverOutputMutation) SetIsFavorited(b bool) {
	m.is_favorited = &b
}

// IsFavorited returns the value of the "is_favorited" field in the mutation.
func (m *VoiceoverOutputMutation) IsFavorited() (r bool, exists bool) {
	v := m.is_favorited
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFavorited returns the old "is_favorited" field's value of the VoiceoverOutput entity.
// If the VoiceoverOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverOutputMutation) OldIsFavorited(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFavorited is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFavorited requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFavorited: %w", err)
	}
	return oldValue.IsFavorited, nil
}

// ResetIsFavorited resets all changes to the "is_favorited" field.
func (m *VoiceoverOutputMutation) ResetIsFavorited() {
	m.is_favorited = nil
}

// SetAudioDuration sets the "audio_duration" field.
func (m *VoiceoverOutputMutation) SetAudioDuration(f float32) {
	m.audio_duration = &f
	m.addaudio_duration = nil
}

// AudioDuration returns the value of the "audio_duration" field in the mutation.
func (m *VoiceoverOutputMutation) AudioDuration() (r float32, exists bool) {
	v := m.audio_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldAudioDuration returns the old "audio_duration" field's value of the VoiceoverOutput entity.
// If the VoiceoverOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverOutputMutation) OldAudioDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudioDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudioDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudioDuration: %w", err)
	}
	return oldValue.AudioDuration, nil
}

// AddAudioDuration adds f to the "audio_duration" field.
func (m *VoiceoverOutputMutation) AddAudioDuration(f float32) {
	if m.addaudio_duration != nil {
		*m.addaudio_duration += f
	} else {
		m.addaudio_duration = &f
	}
}

// AddedAudioDuration returns the value that was added to the "audio_duration" field in this mutation.
func (m *VoiceoverOutputMutation) AddedAudioDuration() (r float32, exists bool) {
	v := m.addaudio_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetAudioDuration resets all changes to the "audio_duration" field.
func (m *VoiceoverOutputMutation) ResetAudioDuration() {
	m.audio_duration = nil
	m.addaudio_duration = nil
}

// SetGalleryStatus sets the "gallery_status" field.
func (m *VoiceoverOutputMutation) SetGalleryStatus(vs voiceoveroutput.GalleryStatus) {
	m.gallery_status = &vs
}

// GalleryStatus returns the value of the "gallery_status" field in the mutation.
func (m *VoiceoverOutputMutation) GalleryStatus() (r voiceoveroutput.GalleryStatus, exists bool) {
	v := m.gallery_status
	if v == nil {
		return
	}
	return *v, true
}

// OldGalleryStatus returns the old "gallery_status" field's value of the VoiceoverOutput entity.
// If the VoiceoverOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverOutputMutation) OldGalleryStatus(ctx context.Context) (v voiceoveroutput.GalleryStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGalleryStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGalleryStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGalleryStatus: %w", err)
	}
	return oldValue.GalleryStatus, nil
}

// ResetGalleryStatus resets all changes to the "gallery_status" field.
func (m *VoiceoverOutputMutation) ResetGalleryStatus() {
	m.gallery_status = nil
}

// SetVoiceoverID sets the "voiceover_id" field.
func (m *VoiceoverOutputMutation) SetVoiceoverID(u uuid.UUID) {
	m.voiceovers = &u
}

// VoiceoverID returns the value of the "voiceover_id" field in the mutation.
func (m *VoiceoverOutputMutation) VoiceoverID() (r uuid.UUID, exists bool) {
	v := m.voiceovers
	if v == nil {
		return
	}
	return *v, true
}

// OldVoiceoverID returns the old "voiceover_id" field's value of the VoiceoverOutput entity.
// If the VoiceoverOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverOutputMutation) OldVoiceoverID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoiceoverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoiceoverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoiceoverID: %w", err)
	}
	return oldValue.VoiceoverID, nil
}

// ResetVoiceoverID resets all changes to the "voiceover_id" field.
func (m *VoiceoverOutputMutation) ResetVoiceoverID() {
	m.voiceovers = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VoiceoverOutputMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VoiceoverOutputMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VoiceoverOutput entity.
// If the VoiceoverOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverOutputMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VoiceoverOutputMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[voiceoveroutput.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VoiceoverOutputMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[voiceoveroutput.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VoiceoverOutputMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, voiceoveroutput.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *VoiceoverOutputMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VoiceoverOutputMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VoiceoverOutput entity.
// If the VoiceoverOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverOutputMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VoiceoverOutputMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VoiceoverOutputMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VoiceoverOutputMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VoiceoverOutput entity.
// If the VoiceoverOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverOutputMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VoiceoverOutputMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVoiceoversID sets the "voiceovers" edge to the Voiceover entity by id.
func (m *VoiceoverOutputMutation) SetVoiceoversID(id uuid.UUID) {
	m.voiceovers = &id
}

// ClearVoiceovers clears the "voiceovers" edge to the Voiceover entity.
func (m *VoiceoverOutputMutation) ClearVoiceovers() {
	m.clearedvoiceovers = true
}

// VoiceoversCleared reports if the "voiceovers" edge to the Voiceover entity was cleared.
func (m *VoiceoverOutputMutation) VoiceoversCleared() bool {
	return m.clearedvoiceovers
}

// VoiceoversID returns the "voiceovers" edge ID in the mutation.
func (m *VoiceoverOutputMutation) VoiceoversID() (id uuid.UUID, exists bool) {
	if m.voiceovers != nil {
		return *m.voiceovers, true
	}
	return
}

// VoiceoversIDs returns the "voiceovers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VoiceoversID instead. It exists only for internal usage by the builders.
func (m *VoiceoverOutputMutation) VoiceoversIDs() (ids []uuid.UUID) {
	if id := m.voiceovers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVoiceovers resets all changes to the "voiceovers" edge.
func (m *VoiceoverOutputMutation) ResetVoiceovers() {
	m.voiceovers = nil
	m.clearedvoiceovers = false
}

// Where appends a list predicates to the VoiceoverOutputMutation builder.
func (m *VoiceoverOutputMutation) Where(ps ...predicate.VoiceoverOutput) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoiceoverOutputMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoiceoverOutputMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VoiceoverOutput, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoiceoverOutputMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoiceoverOutputMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VoiceoverOutput).
func (m *VoiceoverOutputMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoiceoverOutputMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.audio_path != nil {
		fields = append(fields, voiceoveroutput.FieldAudioPath)
	}
	if m.video_path != nil {
		fields = append(fields, voiceoveroutput.FieldVideoPath)
	}
	if m.audio_array != nil {
		fields = append(fields, voiceoveroutput.FieldAudioArray)
	}
	if m.is_favorited != nil {
		fields = append(fields, voiceoveroutput.FieldIsFavorited)
	}
	if m.audio_duration != nil {
		fields = append(fields, voiceoveroutput.FieldAudioDuration)
	}
	if m.gallery_status != nil {
		fields = append(fields, voiceoveroutput.FieldGalleryStatus)
	}
	if m.voiceovers != nil {
		fields = append(fields, voiceoveroutput.FieldVoiceoverID)
	}
	if m.deleted_at != nil {
		fields = append(fields, voiceoveroutput.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, voiceoveroutput.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, voiceoveroutput.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoiceoverOutputMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case voiceoveroutput.FieldAudioPath:
		return m.AudioPath()
	case voiceoveroutput.FieldVideoPath:
		return m.VideoPath()
	case voiceoveroutput.FieldAudioArray:
		return m.AudioArray()
	case voiceoveroutput.FieldIsFavorited:
		return m.IsFavorited()
	case voiceoveroutput.FieldAudioDuration:
		return m.AudioDuration()
	case voiceoveroutput.FieldGalleryStatus:
		return m.GalleryStatus()
	case voiceoveroutput.FieldVoiceoverID:
		return m.VoiceoverID()
	case voiceoveroutput.FieldDeletedAt:
		return m.DeletedAt()
	case voiceoveroutput.FieldCreatedAt:
		return m.CreatedAt()
	case voiceoveroutput.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoiceoverOutputMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case voiceoveroutput.FieldAudioPath:
		return m.OldAudioPath(ctx)
	case voiceoveroutput.FieldVideoPath:
		return m.OldVideoPath(ctx)
	case voiceoveroutput.FieldAudioArray:
		return m.OldAudioArray(ctx)
	case voiceoveroutput.FieldIsFavorited:
		return m.OldIsFavorited(ctx)
	case voiceoveroutput.FieldAudioDuration:
		return m.OldAudioDuration(ctx)
	case voiceoveroutput.FieldGalleryStatus:
		return m.OldGalleryStatus(ctx)
	case voiceoveroutput.FieldVoiceoverID:
		return m.OldVoiceoverID(ctx)
	case voiceoveroutput.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case voiceoveroutput.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case voiceoveroutput.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VoiceoverOutput field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoiceoverOutputMutation) SetField(name string, value ent.Value) error {
	switch name {
	case voiceoveroutput.FieldAudioPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudioPath(v)
		return nil
	case voiceoveroutput.FieldVideoPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoPath(v)
		return nil
	case voiceoveroutput.FieldAudioArray:
		v, ok := value.([]float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudioArray(v)
		return nil
	case voiceoveroutput.FieldIsFavorited:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFavorited(v)
		return nil
	case voiceoveroutput.FieldAudioDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudioDuration(v)
		return nil
	case voiceoveroutput.FieldGalleryStatus:
		v, ok := value.(voiceoveroutput.GalleryStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGalleryStatus(v)
		return nil
	case voiceoveroutput.FieldVoiceoverID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoiceoverID(v)
		return nil
	case voiceoveroutput.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case voiceoveroutput.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case voiceoveroutput.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VoiceoverOutput field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoiceoverOutputMutation) AddedFields() []string {
	var fields []string
	if m.addaudio_duration != nil {
		fields = append(fields, voiceoveroutput.FieldAudioDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoiceoverOutputMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case voiceoveroutput.FieldAudioDuration:
		return m.AddedAudioDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoiceoverOutputMutation) AddField(name string, value ent.Value) error {
	switch name {
	case voiceoveroutput.FieldAudioDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAudioDuration(v)
		return nil
	}
	return fmt.Errorf("unknown VoiceoverOutput numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoiceoverOutputMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(voiceoveroutput.FieldVideoPath) {
		fields = append(fields, voiceoveroutput.FieldVideoPath)
	}
	if m.FieldCleared(voiceoveroutput.FieldAudioArray) {
		fields = append(fields, voiceoveroutput.FieldAudioArray)
	}
	if m.FieldCleared(voiceoveroutput.FieldDeletedAt) {
		fields = append(fields, voiceoveroutput.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoiceoverOutputMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoiceoverOutputMutation) ClearField(name string) error {
	switch name {
	case voiceoveroutput.FieldVideoPath:
		m.ClearVideoPath()
		return nil
	case voiceoveroutput.FieldAudioArray:
		m.ClearAudioArray()
		return nil
	case voiceoveroutput.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown VoiceoverOutput nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoiceoverOutputMutation) ResetField(name string) error {
	switch name {
	case voiceoveroutput.FieldAudioPath:
		m.ResetAudioPath()
		return nil
	case voiceoveroutput.FieldVideoPath:
		m.ResetVideoPath()
		return nil
	case voiceoveroutput.FieldAudioArray:
		m.ResetAudioArray()
		return nil
	case voiceoveroutput.FieldIsFavorited:
		m.ResetIsFavorited()
		return nil
	case voiceoveroutput.FieldAudioDuration:
		m.ResetAudioDuration()
		return nil
	case voiceoveroutput.FieldGalleryStatus:
		m.ResetGalleryStatus()
		return nil
	case voiceoveroutput.FieldVoiceoverID:
		m.ResetVoiceoverID()
		return nil
	case voiceoveroutput.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case voiceoveroutput.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case voiceoveroutput.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown VoiceoverOutput field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoiceoverOutputMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.voiceovers != nil {
		edges = append(edges, voiceoveroutput.EdgeVoiceovers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoiceoverOutputMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case voiceoveroutput.EdgeVoiceovers:
		if id := m.voiceovers; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoiceoverOutputMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoiceoverOutputMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoiceoverOutputMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvoiceovers {
		edges = append(edges, voiceoveroutput.EdgeVoiceovers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoiceoverOutputMutation) EdgeCleared(name string) bool {
	switch name {
	case voiceoveroutput.EdgeVoiceovers:
		return m.clearedvoiceovers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoiceoverOutputMutation) ClearEdge(name string) error {
	switch name {
	case voiceoveroutput.EdgeVoiceovers:
		m.ClearVoiceovers()
		return nil
	}
	return fmt.Errorf("unknown VoiceoverOutput unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoiceoverOutputMutation) ResetEdge(name string) error {
	switch name {
	case voiceoveroutput.EdgeVoiceovers:
		m.ResetVoiceovers()
		return nil
	}
	return fmt.Errorf("unknown VoiceoverOutput edge %s", name)
}

// VoiceoverSpeakerMutation represents an operation that mutates the VoiceoverSpeaker nodes in the graph.
type VoiceoverSpeakerMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	name_in_worker          *string
	name                    *string
	is_active               *bool
	is_default              *bool
	is_hidden               *bool
	locale                  *string
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	voiceovers              map[uuid.UUID]struct{}
	removedvoiceovers       map[uuid.UUID]struct{}
	clearedvoiceovers       bool
	voiceover_models        *uuid.UUID
	clearedvoiceover_models bool
	done                    bool
	oldValue                func(context.Context) (*VoiceoverSpeaker, error)
	predicates              []predicate.VoiceoverSpeaker
}

var _ ent.Mutation = (*VoiceoverSpeakerMutation)(nil)

// voiceoverspeakerOption allows management of the mutation configuration using functional options.
type voiceoverspeakerOption func(*VoiceoverSpeakerMutation)

// newVoiceoverSpeakerMutation creates new mutation for the VoiceoverSpeaker entity.
func newVoiceoverSpeakerMutation(c config, op Op, opts ...voiceoverspeakerOption) *VoiceoverSpeakerMutation {
	m := &VoiceoverSpeakerMutation{
		config:        c,
		op:            op,
		typ:           TypeVoiceoverSpeaker,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoiceoverSpeakerID sets the ID field of the mutation.
func withVoiceoverSpeakerID(id uuid.UUID) voiceoverspeakerOption {
	return func(m *VoiceoverSpeakerMutation) {
		var (
			err   error
			once  sync.Once
			value *VoiceoverSpeaker
		)
		m.oldValue = func(ctx context.Context) (*VoiceoverSpeaker, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VoiceoverSpeaker.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVoiceoverSpeaker sets the old VoiceoverSpeaker of the mutation.
func withVoiceoverSpeaker(node *VoiceoverSpeaker) voiceoverspeakerOption {
	return func(m *VoiceoverSpeakerMutation) {
		m.oldValue = func(context.Context) (*VoiceoverSpeaker, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoiceoverSpeakerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoiceoverSpeakerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VoiceoverSpeaker entities.
func (m *VoiceoverSpeakerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoiceoverSpeakerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoiceoverSpeakerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VoiceoverSpeaker.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameInWorker sets the "name_in_worker" field.
func (m *VoiceoverSpeakerMutation) SetNameInWorker(s string) {
	m.name_in_worker = &s
}

// NameInWorker returns the value of the "name_in_worker" field in the mutation.
func (m *VoiceoverSpeakerMutation) NameInWorker() (r string, exists bool) {
	v := m.name_in_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldNameInWorker returns the old "name_in_worker" field's value of the VoiceoverSpeaker entity.
// If the VoiceoverSpeaker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverSpeakerMutation) OldNameInWorker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameInWorker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameInWorker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameInWorker: %w", err)
	}
	return oldValue.NameInWorker, nil
}

// ResetNameInWorker resets all changes to the "name_in_worker" field.
func (m *VoiceoverSpeakerMutation) ResetNameInWorker() {
	m.name_in_worker = nil
}

// SetName sets the "name" field.
func (m *VoiceoverSpeakerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VoiceoverSpeakerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VoiceoverSpeaker entity.
// If the VoiceoverSpeaker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverSpeakerMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VoiceoverSpeakerMutation) ClearName() {
	m.name = nil
	m.clearedFields[voiceoverspeaker.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VoiceoverSpeakerMutation) NameCleared() bool {
	_, ok := m.clearedFields[voiceoverspeaker.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VoiceoverSpeakerMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, voiceoverspeaker.FieldName)
}

// SetIsActive sets the "is_active" field.
func (m *VoiceoverSpeakerMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *VoiceoverSpeakerMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the VoiceoverSpeaker entity.
// If the VoiceoverSpeaker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverSpeakerMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *VoiceoverSpeakerMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsDefault sets the "is_default" field.
func (m *VoiceoverSpeakerMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *VoiceoverSpeakerMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the VoiceoverSpeaker entity.
// If the VoiceoverSpeaker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverSpeakerMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *VoiceoverSpeakerMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *VoiceoverSpeakerMutation) SetIsHidden(b bool) {
	m.is_hidden = &b
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *VoiceoverSpeakerMutation) IsHidden() (r bool, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the VoiceoverSpeaker entity.
// If the VoiceoverSpeaker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverSpeakerMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *VoiceoverSpeakerMutation) ResetIsHidden() {
	m.is_hidden = nil
}

// SetLocale sets the "locale" field.
func (m *VoiceoverSpeakerMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *VoiceoverSpeakerMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the VoiceoverSpeaker entity.
// If the VoiceoverSpeaker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverSpeakerMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *VoiceoverSpeakerMutation) ResetLocale() {
	m.locale = nil
}

// SetModelID sets the "model_id" field.
func (m *VoiceoverSpeakerMutation) SetModelID(u uuid.UUID) {
	m.voiceover_models = &u
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *VoiceoverSpeakerMutation) ModelID() (r uuid.UUID, exists bool) {
	v := m.voiceover_models
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the VoiceoverSpeaker entity.
// If the VoiceoverSpeaker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverSpeakerMutation) OldModelID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *VoiceoverSpeakerMutation) ResetModelID() {
	m.voiceover_models = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VoiceoverSpeakerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VoiceoverSpeakerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VoiceoverSpeaker entity.
// If the VoiceoverSpeaker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverSpeakerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VoiceoverSpeakerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VoiceoverSpeakerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VoiceoverSpeakerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VoiceoverSpeaker entity.
// If the VoiceoverSpeaker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoiceoverSpeakerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VoiceoverSpeakerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddVoiceoverIDs adds the "voiceovers" edge to the Voiceover entity by ids.
func (m *VoiceoverSpeakerMutation) AddVoiceoverIDs(ids ...uuid.UUID) {
	if m.voiceovers == nil {
		m.voiceovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.voiceovers[ids[i]] = struct{}{}
	}
}

// ClearVoiceovers clears the "voiceovers" edge to the Voiceover entity.
func (m *VoiceoverSpeakerMutation) ClearVoiceovers() {
	m.clearedvoiceovers = true
}

// VoiceoversCleared reports if the "voiceovers" edge to the Voiceover entity was cleared.
func (m *VoiceoverSpeakerMutation) VoiceoversCleared() bool {
	return m.clearedvoiceovers
}

// RemoveVoiceoverIDs removes the "voiceovers" edge to the Voiceover entity by IDs.
func (m *VoiceoverSpeakerMutation) RemoveVoiceoverIDs(ids ...uuid.UUID) {
	if m.removedvoiceovers == nil {
		m.removedvoiceovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.voiceovers, ids[i])
		m.removedvoiceovers[ids[i]] = struct{}{}
	}
}

// RemovedVoiceovers returns the removed IDs of the "voiceovers" edge to the Voiceover entity.
func (m *VoiceoverSpeakerMutation) RemovedVoiceoversIDs() (ids []uuid.UUID) {
	for id := range m.removedvoiceovers {
		ids = append(ids, id)
	}
	return
}

// VoiceoversIDs returns the "voiceovers" edge IDs in the mutation.
func (m *VoiceoverSpeakerMutation) VoiceoversIDs() (ids []uuid.UUID) {
	for id := range m.voiceovers {
		ids = append(ids, id)
	}
	return
}

// ResetVoiceovers resets all changes to the "voiceovers" edge.
func (m *VoiceoverSpeakerMutation) ResetVoiceovers() {
	m.voiceovers = nil
	m.clearedvoiceovers = false
	m.removedvoiceovers = nil
}

// SetVoiceoverModelsID sets the "voiceover_models" edge to the VoiceoverModel entity by id.
func (m *VoiceoverSpeakerMutation) SetVoiceoverModelsID(id uuid.UUID) {
	m.voiceover_models = &id
}

// ClearVoiceoverModels clears the "voiceover_models" edge to the VoiceoverModel entity.
func (m *VoiceoverSpeakerMutation) ClearVoiceoverModels() {
	m.clearedvoiceover_models = true
}

// VoiceoverModelsCleared reports if the "voiceover_models" edge to the VoiceoverModel entity was cleared.
func (m *VoiceoverSpeakerMutation) VoiceoverModelsCleared() bool {
	return m.clearedvoiceover_models
}

// VoiceoverModelsID returns the "voiceover_models" edge ID in the mutation.
func (m *VoiceoverSpeakerMutation) VoiceoverModelsID() (id uuid.UUID, exists bool) {
	if m.voiceover_models != nil {
		return *m.voiceover_models, true
	}
	return
}

// VoiceoverModelsIDs returns the "voiceover_models" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VoiceoverModelsID instead. It exists only for internal usage by the builders.
func (m *VoiceoverSpeakerMutation) VoiceoverModelsIDs() (ids []uuid.UUID) {
	if id := m.voiceover_models; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVoiceoverModels resets all changes to the "voiceover_models" edge.
func (m *VoiceoverSpeakerMutation) ResetVoiceoverModels() {
	m.voiceover_models = nil
	m.clearedvoiceover_models = false
}

// Where appends a list predicates to the VoiceoverSpeakerMutation builder.
func (m *VoiceoverSpeakerMutation) Where(ps ...predicate.VoiceoverSpeaker) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoiceoverSpeakerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoiceoverSpeakerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VoiceoverSpeaker, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoiceoverSpeakerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoiceoverSpeakerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VoiceoverSpeaker).
func (m *VoiceoverSpeakerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoiceoverSpeakerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name_in_worker != nil {
		fields = append(fields, voiceoverspeaker.FieldNameInWorker)
	}
	if m.name != nil {
		fields = append(fields, voiceoverspeaker.FieldName)
	}
	if m.is_active != nil {
		fields = append(fields, voiceoverspeaker.FieldIsActive)
	}
	if m.is_default != nil {
		fields = append(fields, voiceoverspeaker.FieldIsDefault)
	}
	if m.is_hidden != nil {
		fields = append(fields, voiceoverspeaker.FieldIsHidden)
	}
	if m.locale != nil {
		fields = append(fields, voiceoverspeaker.FieldLocale)
	}
	if m.voiceover_models != nil {
		fields = append(fields, voiceoverspeaker.FieldModelID)
	}
	if m.created_at != nil {
		fields = append(fields, voiceoverspeaker.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, voiceoverspeaker.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoiceoverSpeakerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case voiceoverspeaker.FieldNameInWorker:
		return m.NameInWorker()
	case voiceoverspeaker.FieldName:
		return m.Name()
	case voiceoverspeaker.FieldIsActive:
		return m.IsActive()
	case voiceoverspeaker.FieldIsDefault:
		return m.IsDefault()
	case voiceoverspeaker.FieldIsHidden:
		return m.IsHidden()
	case voiceoverspeaker.FieldLocale:
		return m.Locale()
	case voiceoverspeaker.FieldModelID:
		return m.ModelID()
	case voiceoverspeaker.FieldCreatedAt:
		return m.CreatedAt()
	case voiceoverspeaker.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoiceoverSpeakerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case voiceoverspeaker.FieldNameInWorker:
		return m.OldNameInWorker(ctx)
	case voiceoverspeaker.FieldName:
		return m.OldName(ctx)
	case voiceoverspeaker.FieldIsActive:
		return m.OldIsActive(ctx)
	case voiceoverspeaker.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case voiceoverspeaker.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case voiceoverspeaker.FieldLocale:
		return m.OldLocale(ctx)
	case voiceoverspeaker.FieldModelID:
		return m.OldModelID(ctx)
	case voiceoverspeaker.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case voiceoverspeaker.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VoiceoverSpeaker field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoiceoverSpeakerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case voiceoverspeaker.FieldNameInWorker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameInWorker(v)
		return nil
	case voiceoverspeaker.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case voiceoverspeaker.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case voiceoverspeaker.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case voiceoverspeaker.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case voiceoverspeaker.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case voiceoverspeaker.FieldModelID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case voiceoverspeaker.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case voiceoverspeaker.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VoiceoverSpeaker field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoiceoverSpeakerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoiceoverSpeakerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoiceoverSpeakerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VoiceoverSpeaker numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoiceoverSpeakerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(voiceoverspeaker.FieldName) {
		fields = append(fields, voiceoverspeaker.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoiceoverSpeakerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoiceoverSpeakerMutation) ClearField(name string) error {
	switch name {
	case voiceoverspeaker.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown VoiceoverSpeaker nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoiceoverSpeakerMutation) ResetField(name string) error {
	switch name {
	case voiceoverspeaker.FieldNameInWorker:
		m.ResetNameInWorker()
		return nil
	case voiceoverspeaker.FieldName:
		m.ResetName()
		return nil
	case voiceoverspeaker.FieldIsActive:
		m.ResetIsActive()
		return nil
	case voiceoverspeaker.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case voiceoverspeaker.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case voiceoverspeaker.FieldLocale:
		m.ResetLocale()
		return nil
	case voiceoverspeaker.FieldModelID:
		m.ResetModelID()
		return nil
	case voiceoverspeaker.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case voiceoverspeaker.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown VoiceoverSpeaker field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoiceoverSpeakerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.voiceovers != nil {
		edges = append(edges, voiceoverspeaker.EdgeVoiceovers)
	}
	if m.voiceover_models != nil {
		edges = append(edges, voiceoverspeaker.EdgeVoiceoverModels)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoiceoverSpeakerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case voiceoverspeaker.EdgeVoiceovers:
		ids := make([]ent.Value, 0, len(m.voiceovers))
		for id := range m.voiceovers {
			ids = append(ids, id)
		}
		return ids
	case voiceoverspeaker.EdgeVoiceoverModels:
		if id := m.voiceover_models; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoiceoverSpeakerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvoiceovers != nil {
		edges = append(edges, voiceoverspeaker.EdgeVoiceovers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoiceoverSpeakerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case voiceoverspeaker.EdgeVoiceovers:
		ids := make([]ent.Value, 0, len(m.removedvoiceovers))
		for id := range m.removedvoiceovers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoiceoverSpeakerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvoiceovers {
		edges = append(edges, voiceoverspeaker.EdgeVoiceovers)
	}
	if m.clearedvoiceover_models {
		edges = append(edges, voiceoverspeaker.EdgeVoiceoverModels)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoiceoverSpeakerMutation) EdgeCleared(name string) bool {
	switch name {
	case voiceoverspeaker.EdgeVoiceovers:
		return m.clearedvoiceovers
	case voiceoverspeaker.EdgeVoiceoverModels:
		return m.clearedvoiceover_models
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoiceoverSpeakerMutation) ClearEdge(name string) error {
	switch name {
	case voiceoverspeaker.EdgeVoiceoverModels:
		m.ClearVoiceoverModels()
		return nil
	}
	return fmt.Errorf("unknown VoiceoverSpeaker unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoiceoverSpeakerMutation) ResetEdge(name string) error {
	switch name {
	case voiceoverspeaker.EdgeVoiceovers:
		m.ResetVoiceovers()
		return nil
	case voiceoverspeaker.EdgeVoiceoverModels:
		m.ResetVoiceoverModels()
		return nil
	}
	return fmt.Errorf("unknown VoiceoverSpeaker edge %s", name)
}
