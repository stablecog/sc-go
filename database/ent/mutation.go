// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/stablecog/sc-go/database/ent/credit"
	"github.com/stablecog/sc-go/database/ent/credittype"
	"github.com/stablecog/sc-go/database/ent/deviceinfo"
	"github.com/stablecog/sc-go/database/ent/generation"
	"github.com/stablecog/sc-go/database/ent/generationmodel"
	"github.com/stablecog/sc-go/database/ent/generationoutput"
	"github.com/stablecog/sc-go/database/ent/negativeprompt"
	"github.com/stablecog/sc-go/database/ent/predicate"
	"github.com/stablecog/sc-go/database/ent/prompt"
	"github.com/stablecog/sc-go/database/ent/scheduler"
	"github.com/stablecog/sc-go/database/ent/upscale"
	"github.com/stablecog/sc-go/database/ent/upscalemodel"
	"github.com/stablecog/sc-go/database/ent/upscaleoutput"
	"github.com/stablecog/sc-go/database/ent/user"
	"github.com/stablecog/sc-go/database/ent/userrole"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCredit           = "Credit"
	TypeCreditType       = "CreditType"
	TypeDeviceInfo       = "DeviceInfo"
	TypeGeneration       = "Generation"
	TypeGenerationModel  = "GenerationModel"
	TypeGenerationOutput = "GenerationOutput"
	TypeNegativePrompt   = "NegativePrompt"
	TypePrompt           = "Prompt"
	TypeScheduler        = "Scheduler"
	TypeUpscale          = "Upscale"
	TypeUpscaleModel     = "UpscaleModel"
	TypeUpscaleOutput    = "UpscaleOutput"
	TypeUser             = "User"
	TypeUserRole         = "UserRole"
)

// CreditMutation represents an operation that mutates the Credit nodes in the graph.
type CreditMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	remaining_amount    *int32
	addremaining_amount *int32
	expires_at          *time.Time
	stripe_line_item_id *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	users               *uuid.UUID
	clearedusers        bool
	credit_type         *uuid.UUID
	clearedcredit_type  bool
	done                bool
	oldValue            func(context.Context) (*Credit, error)
	predicates          []predicate.Credit
}

var _ ent.Mutation = (*CreditMutation)(nil)

// creditOption allows management of the mutation configuration using functional options.
type creditOption func(*CreditMutation)

// newCreditMutation creates new mutation for the Credit entity.
func newCreditMutation(c config, op Op, opts ...creditOption) *CreditMutation {
	m := &CreditMutation{
		config:        c,
		op:            op,
		typ:           TypeCredit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCreditID sets the ID field of the mutation.
func withCreditID(id uuid.UUID) creditOption {
	return func(m *CreditMutation) {
		var (
			err   error
			once  sync.Once
			value *Credit
		)
		m.oldValue = func(ctx context.Context) (*Credit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredit sets the old Credit of the mutation.
func withCredit(node *Credit) creditOption {
	return func(m *CreditMutation) {
		m.oldValue = func(context.Context) (*Credit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CreditMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CreditMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Credit entities.
func (m *CreditMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CreditMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CreditMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRemainingAmount sets the "remaining_amount" field.
func (m *CreditMutation) SetRemainingAmount(i int32) {
	m.remaining_amount = &i
	m.addremaining_amount = nil
}

// RemainingAmount returns the value of the "remaining_amount" field in the mutation.
func (m *CreditMutation) RemainingAmount() (r int32, exists bool) {
	v := m.remaining_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingAmount returns the old "remaining_amount" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldRemainingAmount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainingAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainingAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingAmount: %w", err)
	}
	return oldValue.RemainingAmount, nil
}

// AddRemainingAmount adds i to the "remaining_amount" field.
func (m *CreditMutation) AddRemainingAmount(i int32) {
	if m.addremaining_amount != nil {
		*m.addremaining_amount += i
	} else {
		m.addremaining_amount = &i
	}
}

// AddedRemainingAmount returns the value that was added to the "remaining_amount" field in this mutation.
func (m *CreditMutation) AddedRemainingAmount() (r int32, exists bool) {
	v := m.addremaining_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainingAmount resets all changes to the "remaining_amount" field.
func (m *CreditMutation) ResetRemainingAmount() {
	m.remaining_amount = nil
	m.addremaining_amount = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *CreditMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *CreditMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *CreditMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetStripeLineItemID sets the "stripe_line_item_id" field.
func (m *CreditMutation) SetStripeLineItemID(s string) {
	m.stripe_line_item_id = &s
}

// StripeLineItemID returns the value of the "stripe_line_item_id" field in the mutation.
func (m *CreditMutation) StripeLineItemID() (r string, exists bool) {
	v := m.stripe_line_item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeLineItemID returns the old "stripe_line_item_id" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldStripeLineItemID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeLineItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeLineItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeLineItemID: %w", err)
	}
	return oldValue.StripeLineItemID, nil
}

// ClearStripeLineItemID clears the value of the "stripe_line_item_id" field.
func (m *CreditMutation) ClearStripeLineItemID() {
	m.stripe_line_item_id = nil
	m.clearedFields[credit.FieldStripeLineItemID] = struct{}{}
}

// StripeLineItemIDCleared returns if the "stripe_line_item_id" field was cleared in this mutation.
func (m *CreditMutation) StripeLineItemIDCleared() bool {
	_, ok := m.clearedFields[credit.FieldStripeLineItemID]
	return ok
}

// ResetStripeLineItemID resets all changes to the "stripe_line_item_id" field.
func (m *CreditMutation) ResetStripeLineItemID() {
	m.stripe_line_item_id = nil
	delete(m.clearedFields, credit.FieldStripeLineItemID)
}

// SetUserID sets the "user_id" field.
func (m *CreditMutation) SetUserID(u uuid.UUID) {
	m.users = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CreditMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CreditMutation) ResetUserID() {
	m.users = nil
}

// SetCreditTypeID sets the "credit_type_id" field.
func (m *CreditMutation) SetCreditTypeID(u uuid.UUID) {
	m.credit_type = &u
}

// CreditTypeID returns the value of the "credit_type_id" field in the mutation.
func (m *CreditMutation) CreditTypeID() (r uuid.UUID, exists bool) {
	v := m.credit_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditTypeID returns the old "credit_type_id" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldCreditTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditTypeID: %w", err)
	}
	return oldValue.CreditTypeID, nil
}

// ResetCreditTypeID resets all changes to the "credit_type_id" field.
func (m *CreditMutation) ResetCreditTypeID() {
	m.credit_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CreditMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CreditMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CreditMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CreditMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CreditMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Credit entity.
// If the Credit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CreditMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *CreditMutation) SetUsersID(id uuid.UUID) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *CreditMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *CreditMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *CreditMutation) UsersID() (id uuid.UUID, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *CreditMutation) UsersIDs() (ids []uuid.UUID) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *CreditMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// ClearCreditType clears the "credit_type" edge to the CreditType entity.
func (m *CreditMutation) ClearCreditType() {
	m.clearedcredit_type = true
}

// CreditTypeCleared reports if the "credit_type" edge to the CreditType entity was cleared.
func (m *CreditMutation) CreditTypeCleared() bool {
	return m.clearedcredit_type
}

// CreditTypeIDs returns the "credit_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreditTypeID instead. It exists only for internal usage by the builders.
func (m *CreditMutation) CreditTypeIDs() (ids []uuid.UUID) {
	if id := m.credit_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreditType resets all changes to the "credit_type" edge.
func (m *CreditMutation) ResetCreditType() {
	m.credit_type = nil
	m.clearedcredit_type = false
}

// Where appends a list predicates to the CreditMutation builder.
func (m *CreditMutation) Where(ps ...predicate.Credit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CreditMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CreditMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CreditMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CreditMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credit).
func (m *CreditMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CreditMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.remaining_amount != nil {
		fields = append(fields, credit.FieldRemainingAmount)
	}
	if m.expires_at != nil {
		fields = append(fields, credit.FieldExpiresAt)
	}
	if m.stripe_line_item_id != nil {
		fields = append(fields, credit.FieldStripeLineItemID)
	}
	if m.users != nil {
		fields = append(fields, credit.FieldUserID)
	}
	if m.credit_type != nil {
		fields = append(fields, credit.FieldCreditTypeID)
	}
	if m.created_at != nil {
		fields = append(fields, credit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, credit.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CreditMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credit.FieldRemainingAmount:
		return m.RemainingAmount()
	case credit.FieldExpiresAt:
		return m.ExpiresAt()
	case credit.FieldStripeLineItemID:
		return m.StripeLineItemID()
	case credit.FieldUserID:
		return m.UserID()
	case credit.FieldCreditTypeID:
		return m.CreditTypeID()
	case credit.FieldCreatedAt:
		return m.CreatedAt()
	case credit.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CreditMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credit.FieldRemainingAmount:
		return m.OldRemainingAmount(ctx)
	case credit.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case credit.FieldStripeLineItemID:
		return m.OldStripeLineItemID(ctx)
	case credit.FieldUserID:
		return m.OldUserID(ctx)
	case credit.FieldCreditTypeID:
		return m.OldCreditTypeID(ctx)
	case credit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case credit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Credit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credit.FieldRemainingAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingAmount(v)
		return nil
	case credit.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case credit.FieldStripeLineItemID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeLineItemID(v)
		return nil
	case credit.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case credit.FieldCreditTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditTypeID(v)
		return nil
	case credit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case credit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Credit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CreditMutation) AddedFields() []string {
	var fields []string
	if m.addremaining_amount != nil {
		fields = append(fields, credit.FieldRemainingAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CreditMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case credit.FieldRemainingAmount:
		return m.AddedRemainingAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditMutation) AddField(name string, value ent.Value) error {
	switch name {
	case credit.FieldRemainingAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainingAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Credit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CreditMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credit.FieldStripeLineItemID) {
		fields = append(fields, credit.FieldStripeLineItemID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CreditMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CreditMutation) ClearField(name string) error {
	switch name {
	case credit.FieldStripeLineItemID:
		m.ClearStripeLineItemID()
		return nil
	}
	return fmt.Errorf("unknown Credit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CreditMutation) ResetField(name string) error {
	switch name {
	case credit.FieldRemainingAmount:
		m.ResetRemainingAmount()
		return nil
	case credit.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case credit.FieldStripeLineItemID:
		m.ResetStripeLineItemID()
		return nil
	case credit.FieldUserID:
		m.ResetUserID()
		return nil
	case credit.FieldCreditTypeID:
		m.ResetCreditTypeID()
		return nil
	case credit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case credit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Credit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CreditMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, credit.EdgeUsers)
	}
	if m.credit_type != nil {
		edges = append(edges, credit.EdgeCreditType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CreditMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credit.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case credit.EdgeCreditType:
		if id := m.credit_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CreditMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CreditMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CreditMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, credit.EdgeUsers)
	}
	if m.clearedcredit_type {
		edges = append(edges, credit.EdgeCreditType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CreditMutation) EdgeCleared(name string) bool {
	switch name {
	case credit.EdgeUsers:
		return m.clearedusers
	case credit.EdgeCreditType:
		return m.clearedcredit_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CreditMutation) ClearEdge(name string) error {
	switch name {
	case credit.EdgeUsers:
		m.ClearUsers()
		return nil
	case credit.EdgeCreditType:
		m.ClearCreditType()
		return nil
	}
	return fmt.Errorf("unknown Credit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CreditMutation) ResetEdge(name string) error {
	switch name {
	case credit.EdgeUsers:
		m.ResetUsers()
		return nil
	case credit.EdgeCreditType:
		m.ResetCreditType()
		return nil
	}
	return fmt.Errorf("unknown Credit edge %s", name)
}

// CreditTypeMutation represents an operation that mutates the CreditType nodes in the graph.
type CreditTypeMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	description       *string
	amount            *int32
	addamount         *int32
	stripe_product_id *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	credits           map[uuid.UUID]struct{}
	removedcredits    map[uuid.UUID]struct{}
	clearedcredits    bool
	done              bool
	oldValue          func(context.Context) (*CreditType, error)
	predicates        []predicate.CreditType
}

var _ ent.Mutation = (*CreditTypeMutation)(nil)

// credittypeOption allows management of the mutation configuration using functional options.
type credittypeOption func(*CreditTypeMutation)

// newCreditTypeMutation creates new mutation for the CreditType entity.
func newCreditTypeMutation(c config, op Op, opts ...credittypeOption) *CreditTypeMutation {
	m := &CreditTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCreditType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCreditTypeID sets the ID field of the mutation.
func withCreditTypeID(id uuid.UUID) credittypeOption {
	return func(m *CreditTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CreditType
		)
		m.oldValue = func(ctx context.Context) (*CreditType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CreditType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCreditType sets the old CreditType of the mutation.
func withCreditType(node *CreditType) credittypeOption {
	return func(m *CreditTypeMutation) {
		m.oldValue = func(context.Context) (*CreditType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CreditTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CreditTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CreditType entities.
func (m *CreditTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CreditTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CreditTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CreditType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CreditTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CreditTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CreditTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CreditTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CreditTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CreditTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[credittype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CreditTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[credittype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CreditTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, credittype.FieldDescription)
}

// SetAmount sets the "amount" field.
func (m *CreditTypeMutation) SetAmount(i int32) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *CreditTypeMutation) Amount() (r int32, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldAmount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *CreditTypeMutation) AddAmount(i int32) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *CreditTypeMutation) AddedAmount() (r int32, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *CreditTypeMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStripeProductID sets the "stripe_product_id" field.
func (m *CreditTypeMutation) SetStripeProductID(s string) {
	m.stripe_product_id = &s
}

// StripeProductID returns the value of the "stripe_product_id" field in the mutation.
func (m *CreditTypeMutation) StripeProductID() (r string, exists bool) {
	v := m.stripe_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeProductID returns the old "stripe_product_id" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldStripeProductID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeProductID: %w", err)
	}
	return oldValue.StripeProductID, nil
}

// ClearStripeProductID clears the value of the "stripe_product_id" field.
func (m *CreditTypeMutation) ClearStripeProductID() {
	m.stripe_product_id = nil
	m.clearedFields[credittype.FieldStripeProductID] = struct{}{}
}

// StripeProductIDCleared returns if the "stripe_product_id" field was cleared in this mutation.
func (m *CreditTypeMutation) StripeProductIDCleared() bool {
	_, ok := m.clearedFields[credittype.FieldStripeProductID]
	return ok
}

// ResetStripeProductID resets all changes to the "stripe_product_id" field.
func (m *CreditTypeMutation) ResetStripeProductID() {
	m.stripe_product_id = nil
	delete(m.clearedFields, credittype.FieldStripeProductID)
}

// SetCreatedAt sets the "created_at" field.
func (m *CreditTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CreditTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CreditTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CreditTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CreditTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CreditType entity.
// If the CreditType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CreditTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddCreditIDs adds the "credits" edge to the Credit entity by ids.
func (m *CreditTypeMutation) AddCreditIDs(ids ...uuid.UUID) {
	if m.credits == nil {
		m.credits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.credits[ids[i]] = struct{}{}
	}
}

// ClearCredits clears the "credits" edge to the Credit entity.
func (m *CreditTypeMutation) ClearCredits() {
	m.clearedcredits = true
}

// CreditsCleared reports if the "credits" edge to the Credit entity was cleared.
func (m *CreditTypeMutation) CreditsCleared() bool {
	return m.clearedcredits
}

// RemoveCreditIDs removes the "credits" edge to the Credit entity by IDs.
func (m *CreditTypeMutation) RemoveCreditIDs(ids ...uuid.UUID) {
	if m.removedcredits == nil {
		m.removedcredits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.credits, ids[i])
		m.removedcredits[ids[i]] = struct{}{}
	}
}

// RemovedCredits returns the removed IDs of the "credits" edge to the Credit entity.
func (m *CreditTypeMutation) RemovedCreditsIDs() (ids []uuid.UUID) {
	for id := range m.removedcredits {
		ids = append(ids, id)
	}
	return
}

// CreditsIDs returns the "credits" edge IDs in the mutation.
func (m *CreditTypeMutation) CreditsIDs() (ids []uuid.UUID) {
	for id := range m.credits {
		ids = append(ids, id)
	}
	return
}

// ResetCredits resets all changes to the "credits" edge.
func (m *CreditTypeMutation) ResetCredits() {
	m.credits = nil
	m.clearedcredits = false
	m.removedcredits = nil
}

// Where appends a list predicates to the CreditTypeMutation builder.
func (m *CreditTypeMutation) Where(ps ...predicate.CreditType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CreditTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CreditTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CreditType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CreditTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CreditTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CreditType).
func (m *CreditTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CreditTypeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, credittype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, credittype.FieldDescription)
	}
	if m.amount != nil {
		fields = append(fields, credittype.FieldAmount)
	}
	if m.stripe_product_id != nil {
		fields = append(fields, credittype.FieldStripeProductID)
	}
	if m.created_at != nil {
		fields = append(fields, credittype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, credittype.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CreditTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credittype.FieldName:
		return m.Name()
	case credittype.FieldDescription:
		return m.Description()
	case credittype.FieldAmount:
		return m.Amount()
	case credittype.FieldStripeProductID:
		return m.StripeProductID()
	case credittype.FieldCreatedAt:
		return m.CreatedAt()
	case credittype.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CreditTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credittype.FieldName:
		return m.OldName(ctx)
	case credittype.FieldDescription:
		return m.OldDescription(ctx)
	case credittype.FieldAmount:
		return m.OldAmount(ctx)
	case credittype.FieldStripeProductID:
		return m.OldStripeProductID(ctx)
	case credittype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case credittype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CreditType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credittype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case credittype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case credittype.FieldAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case credittype.FieldStripeProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeProductID(v)
		return nil
	case credittype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case credittype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CreditType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CreditTypeMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, credittype.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CreditTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case credittype.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case credittype.FieldAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown CreditType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CreditTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credittype.FieldDescription) {
		fields = append(fields, credittype.FieldDescription)
	}
	if m.FieldCleared(credittype.FieldStripeProductID) {
		fields = append(fields, credittype.FieldStripeProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CreditTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CreditTypeMutation) ClearField(name string) error {
	switch name {
	case credittype.FieldDescription:
		m.ClearDescription()
		return nil
	case credittype.FieldStripeProductID:
		m.ClearStripeProductID()
		return nil
	}
	return fmt.Errorf("unknown CreditType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CreditTypeMutation) ResetField(name string) error {
	switch name {
	case credittype.FieldName:
		m.ResetName()
		return nil
	case credittype.FieldDescription:
		m.ResetDescription()
		return nil
	case credittype.FieldAmount:
		m.ResetAmount()
		return nil
	case credittype.FieldStripeProductID:
		m.ResetStripeProductID()
		return nil
	case credittype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case credittype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CreditType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CreditTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.credits != nil {
		edges = append(edges, credittype.EdgeCredits)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CreditTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credittype.EdgeCredits:
		ids := make([]ent.Value, 0, len(m.credits))
		for id := range m.credits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CreditTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcredits != nil {
		edges = append(edges, credittype.EdgeCredits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CreditTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case credittype.EdgeCredits:
		ids := make([]ent.Value, 0, len(m.removedcredits))
		for id := range m.removedcredits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CreditTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcredits {
		edges = append(edges, credittype.EdgeCredits)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CreditTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case credittype.EdgeCredits:
		return m.clearedcredits
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CreditTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CreditType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CreditTypeMutation) ResetEdge(name string) error {
	switch name {
	case credittype.EdgeCredits:
		m.ResetCredits()
		return nil
	}
	return fmt.Errorf("unknown CreditType edge %s", name)
}

// DeviceInfoMutation represents an operation that mutates the DeviceInfo nodes in the graph.
type DeviceInfoMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	_type              *string
	os                 *string
	browser            *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	upscales           map[uuid.UUID]struct{}
	removedupscales    map[uuid.UUID]struct{}
	clearedupscales    bool
	done               bool
	oldValue           func(context.Context) (*DeviceInfo, error)
	predicates         []predicate.DeviceInfo
}

var _ ent.Mutation = (*DeviceInfoMutation)(nil)

// deviceinfoOption allows management of the mutation configuration using functional options.
type deviceinfoOption func(*DeviceInfoMutation)

// newDeviceInfoMutation creates new mutation for the DeviceInfo entity.
func newDeviceInfoMutation(c config, op Op, opts ...deviceinfoOption) *DeviceInfoMutation {
	m := &DeviceInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceInfoID sets the ID field of the mutation.
func withDeviceInfoID(id uuid.UUID) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceInfo
		)
		m.oldValue = func(ctx context.Context) (*DeviceInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceInfo sets the old DeviceInfo of the mutation.
func withDeviceInfo(node *DeviceInfo) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		m.oldValue = func(context.Context) (*DeviceInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceInfo entities.
func (m *DeviceInfoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceInfoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceInfoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *DeviceInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DeviceInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *DeviceInfoMutation) ClearType() {
	m._type = nil
	m.clearedFields[deviceinfo.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *DeviceInfoMutation) TypeCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *DeviceInfoMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, deviceinfo.FieldType)
}

// SetOs sets the "os" field.
func (m *DeviceInfoMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *DeviceInfoMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldOs(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ClearOs clears the value of the "os" field.
func (m *DeviceInfoMutation) ClearOs() {
	m.os = nil
	m.clearedFields[deviceinfo.FieldOs] = struct{}{}
}

// OsCleared returns if the "os" field was cleared in this mutation.
func (m *DeviceInfoMutation) OsCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldOs]
	return ok
}

// ResetOs resets all changes to the "os" field.
func (m *DeviceInfoMutation) ResetOs() {
	m.os = nil
	delete(m.clearedFields, deviceinfo.FieldOs)
}

// SetBrowser sets the "browser" field.
func (m *DeviceInfoMutation) SetBrowser(s string) {
	m.browser = &s
}

// Browser returns the value of the "browser" field in the mutation.
func (m *DeviceInfoMutation) Browser() (r string, exists bool) {
	v := m.browser
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowser returns the old "browser" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldBrowser(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowser: %w", err)
	}
	return oldValue.Browser, nil
}

// ClearBrowser clears the value of the "browser" field.
func (m *DeviceInfoMutation) ClearBrowser() {
	m.browser = nil
	m.clearedFields[deviceinfo.FieldBrowser] = struct{}{}
}

// BrowserCleared returns if the "browser" field was cleared in this mutation.
func (m *DeviceInfoMutation) BrowserCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldBrowser]
	return ok
}

// ResetBrowser resets all changes to the "browser" field.
func (m *DeviceInfoMutation) ResetBrowser() {
	m.browser = nil
	delete(m.clearedFields, deviceinfo.FieldBrowser)
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *DeviceInfoMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *DeviceInfoMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *DeviceInfoMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *DeviceInfoMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *DeviceInfoMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *DeviceInfoMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *DeviceInfoMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// AddUpscaleIDs adds the "upscales" edge to the Upscale entity by ids.
func (m *DeviceInfoMutation) AddUpscaleIDs(ids ...uuid.UUID) {
	if m.upscales == nil {
		m.upscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscales[ids[i]] = struct{}{}
	}
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *DeviceInfoMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *DeviceInfoMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// RemoveUpscaleIDs removes the "upscales" edge to the Upscale entity by IDs.
func (m *DeviceInfoMutation) RemoveUpscaleIDs(ids ...uuid.UUID) {
	if m.removedupscales == nil {
		m.removedupscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscales, ids[i])
		m.removedupscales[ids[i]] = struct{}{}
	}
}

// RemovedUpscales returns the removed IDs of the "upscales" edge to the Upscale entity.
func (m *DeviceInfoMutation) RemovedUpscalesIDs() (ids []uuid.UUID) {
	for id := range m.removedupscales {
		ids = append(ids, id)
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
func (m *DeviceInfoMutation) UpscalesIDs() (ids []uuid.UUID) {
	for id := range m.upscales {
		ids = append(ids, id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *DeviceInfoMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
	m.removedupscales = nil
}

// Where appends a list predicates to the DeviceInfoMutation builder.
func (m *DeviceInfoMutation) Where(ps ...predicate.DeviceInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceInfo).
func (m *DeviceInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceInfoMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, deviceinfo.FieldType)
	}
	if m.os != nil {
		fields = append(fields, deviceinfo.FieldOs)
	}
	if m.browser != nil {
		fields = append(fields, deviceinfo.FieldBrowser)
	}
	if m.created_at != nil {
		fields = append(fields, deviceinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceinfo.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceinfo.FieldType:
		return m.GetType()
	case deviceinfo.FieldOs:
		return m.Os()
	case deviceinfo.FieldBrowser:
		return m.Browser()
	case deviceinfo.FieldCreatedAt:
		return m.CreatedAt()
	case deviceinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceinfo.FieldType:
		return m.OldType(ctx)
	case deviceinfo.FieldOs:
		return m.OldOs(ctx)
	case deviceinfo.FieldBrowser:
		return m.OldBrowser(ctx)
	case deviceinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deviceinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceinfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case deviceinfo.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case deviceinfo.FieldBrowser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowser(v)
		return nil
	case deviceinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deviceinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deviceinfo.FieldType) {
		fields = append(fields, deviceinfo.FieldType)
	}
	if m.FieldCleared(deviceinfo.FieldOs) {
		fields = append(fields, deviceinfo.FieldOs)
	}
	if m.FieldCleared(deviceinfo.FieldBrowser) {
		fields = append(fields, deviceinfo.FieldBrowser)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ClearField(name string) error {
	switch name {
	case deviceinfo.FieldType:
		m.ClearType()
		return nil
	case deviceinfo.FieldOs:
		m.ClearOs()
		return nil
	case deviceinfo.FieldBrowser:
		m.ClearBrowser()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ResetField(name string) error {
	switch name {
	case deviceinfo.FieldType:
		m.ResetType()
		return nil
	case deviceinfo.FieldOs:
		m.ResetOs()
		return nil
	case deviceinfo.FieldBrowser:
		m.ResetBrowser()
		return nil
	case deviceinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deviceinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.generations != nil {
		edges = append(edges, deviceinfo.EdgeGenerations)
	}
	if m.upscales != nil {
		edges = append(edges, deviceinfo.EdgeUpscales)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deviceinfo.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	case deviceinfo.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.upscales))
		for id := range m.upscales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgenerations != nil {
		edges = append(edges, deviceinfo.EdgeGenerations)
	}
	if m.removedupscales != nil {
		edges = append(edges, deviceinfo.EdgeUpscales)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deviceinfo.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	case deviceinfo.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.removedupscales))
		for id := range m.removedupscales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgenerations {
		edges = append(edges, deviceinfo.EdgeGenerations)
	}
	if m.clearedupscales {
		edges = append(edges, deviceinfo.EdgeUpscales)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case deviceinfo.EdgeGenerations:
		return m.clearedgenerations
	case deviceinfo.EdgeUpscales:
		return m.clearedupscales
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceInfoMutation) ResetEdge(name string) error {
	switch name {
	case deviceinfo.EdgeGenerations:
		m.ResetGenerations()
		return nil
	case deviceinfo.EdgeUpscales:
		m.ResetUpscales()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo edge %s", name)
}

// GenerationMutation represents an operation that mutates the Generation nodes in the graph.
type GenerationMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	width                     *int32
	addwidth                  *int32
	height                    *int32
	addheight                 *int32
	inference_steps           *int32
	addinference_steps        *int32
	guidance_scale            *float32
	addguidance_scale         *float32
	num_outputs               *int32
	addnum_outputs            *int32
	nsfw_count                *int32
	addnsfw_count             *int32
	seed                      *int
	addseed                   *int
	status                    *generation.Status
	failure_reason            *string
	country_code              *string
	init_image_url            *string
	submit_to_gallery         *bool
	started_at                *time.Time
	completed_at              *time.Time
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	device_info               *uuid.UUID
	cleareddevice_info        bool
	scheduler                 *uuid.UUID
	clearedscheduler          bool
	prompt                    *uuid.UUID
	clearedprompt             bool
	negative_prompt           *uuid.UUID
	clearednegative_prompt    bool
	generation_model          *uuid.UUID
	clearedgeneration_model   bool
	user                      *uuid.UUID
	cleareduser               bool
	generation_outputs        map[uuid.UUID]struct{}
	removedgeneration_outputs map[uuid.UUID]struct{}
	clearedgeneration_outputs bool
	done                      bool
	oldValue                  func(context.Context) (*Generation, error)
	predicates                []predicate.Generation
}

var _ ent.Mutation = (*GenerationMutation)(nil)

// generationOption allows management of the mutation configuration using functional options.
type generationOption func(*GenerationMutation)

// newGenerationMutation creates new mutation for the Generation entity.
func newGenerationMutation(c config, op Op, opts ...generationOption) *GenerationMutation {
	m := &GenerationMutation{
		config:        c,
		op:            op,
		typ:           TypeGeneration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenerationID sets the ID field of the mutation.
func withGenerationID(id uuid.UUID) generationOption {
	return func(m *GenerationMutation) {
		var (
			err   error
			once  sync.Once
			value *Generation
		)
		m.oldValue = func(ctx context.Context) (*Generation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Generation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGeneration sets the old Generation of the mutation.
func withGeneration(node *Generation) generationOption {
	return func(m *GenerationMutation) {
		m.oldValue = func(context.Context) (*Generation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenerationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenerationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Generation entities.
func (m *GenerationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenerationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenerationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Generation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWidth sets the "width" field.
func (m *GenerationMutation) SetWidth(i int32) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *GenerationMutation) Width() (r int32, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldWidth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *GenerationMutation) AddWidth(i int32) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *GenerationMutation) AddedWidth() (r int32, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *GenerationMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *GenerationMutation) SetHeight(i int32) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *GenerationMutation) Height() (r int32, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldHeight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *GenerationMutation) AddHeight(i int32) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *GenerationMutation) AddedHeight() (r int32, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *GenerationMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetInferenceSteps sets the "inference_steps" field.
func (m *GenerationMutation) SetInferenceSteps(i int32) {
	m.inference_steps = &i
	m.addinference_steps = nil
}

// InferenceSteps returns the value of the "inference_steps" field in the mutation.
func (m *GenerationMutation) InferenceSteps() (r int32, exists bool) {
	v := m.inference_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldInferenceSteps returns the old "inference_steps" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldInferenceSteps(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInferenceSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInferenceSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInferenceSteps: %w", err)
	}
	return oldValue.InferenceSteps, nil
}

// AddInferenceSteps adds i to the "inference_steps" field.
func (m *GenerationMutation) AddInferenceSteps(i int32) {
	if m.addinference_steps != nil {
		*m.addinference_steps += i
	} else {
		m.addinference_steps = &i
	}
}

// AddedInferenceSteps returns the value that was added to the "inference_steps" field in this mutation.
func (m *GenerationMutation) AddedInferenceSteps() (r int32, exists bool) {
	v := m.addinference_steps
	if v == nil {
		return
	}
	return *v, true
}

// ResetInferenceSteps resets all changes to the "inference_steps" field.
func (m *GenerationMutation) ResetInferenceSteps() {
	m.inference_steps = nil
	m.addinference_steps = nil
}

// SetGuidanceScale sets the "guidance_scale" field.
func (m *GenerationMutation) SetGuidanceScale(f float32) {
	m.guidance_scale = &f
	m.addguidance_scale = nil
}

// GuidanceScale returns the value of the "guidance_scale" field in the mutation.
func (m *GenerationMutation) GuidanceScale() (r float32, exists bool) {
	v := m.guidance_scale
	if v == nil {
		return
	}
	return *v, true
}

// OldGuidanceScale returns the old "guidance_scale" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldGuidanceScale(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuidanceScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuidanceScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuidanceScale: %w", err)
	}
	return oldValue.GuidanceScale, nil
}

// AddGuidanceScale adds f to the "guidance_scale" field.
func (m *GenerationMutation) AddGuidanceScale(f float32) {
	if m.addguidance_scale != nil {
		*m.addguidance_scale += f
	} else {
		m.addguidance_scale = &f
	}
}

// AddedGuidanceScale returns the value that was added to the "guidance_scale" field in this mutation.
func (m *GenerationMutation) AddedGuidanceScale() (r float32, exists bool) {
	v := m.addguidance_scale
	if v == nil {
		return
	}
	return *v, true
}

// ResetGuidanceScale resets all changes to the "guidance_scale" field.
func (m *GenerationMutation) ResetGuidanceScale() {
	m.guidance_scale = nil
	m.addguidance_scale = nil
}

// SetNumOutputs sets the "num_outputs" field.
func (m *GenerationMutation) SetNumOutputs(i int32) {
	m.num_outputs = &i
	m.addnum_outputs = nil
}

// NumOutputs returns the value of the "num_outputs" field in the mutation.
func (m *GenerationMutation) NumOutputs() (r int32, exists bool) {
	v := m.num_outputs
	if v == nil {
		return
	}
	return *v, true
}

// OldNumOutputs returns the old "num_outputs" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldNumOutputs(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumOutputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumOutputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumOutputs: %w", err)
	}
	return oldValue.NumOutputs, nil
}

// AddNumOutputs adds i to the "num_outputs" field.
func (m *GenerationMutation) AddNumOutputs(i int32) {
	if m.addnum_outputs != nil {
		*m.addnum_outputs += i
	} else {
		m.addnum_outputs = &i
	}
}

// AddedNumOutputs returns the value that was added to the "num_outputs" field in this mutation.
func (m *GenerationMutation) AddedNumOutputs() (r int32, exists bool) {
	v := m.addnum_outputs
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumOutputs resets all changes to the "num_outputs" field.
func (m *GenerationMutation) ResetNumOutputs() {
	m.num_outputs = nil
	m.addnum_outputs = nil
}

// SetNsfwCount sets the "nsfw_count" field.
func (m *GenerationMutation) SetNsfwCount(i int32) {
	m.nsfw_count = &i
	m.addnsfw_count = nil
}

// NsfwCount returns the value of the "nsfw_count" field in the mutation.
func (m *GenerationMutation) NsfwCount() (r int32, exists bool) {
	v := m.nsfw_count
	if v == nil {
		return
	}
	return *v, true
}

// OldNsfwCount returns the old "nsfw_count" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldNsfwCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNsfwCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNsfwCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNsfwCount: %w", err)
	}
	return oldValue.NsfwCount, nil
}

// AddNsfwCount adds i to the "nsfw_count" field.
func (m *GenerationMutation) AddNsfwCount(i int32) {
	if m.addnsfw_count != nil {
		*m.addnsfw_count += i
	} else {
		m.addnsfw_count = &i
	}
}

// AddedNsfwCount returns the value that was added to the "nsfw_count" field in this mutation.
func (m *GenerationMutation) AddedNsfwCount() (r int32, exists bool) {
	v := m.addnsfw_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetNsfwCount resets all changes to the "nsfw_count" field.
func (m *GenerationMutation) ResetNsfwCount() {
	m.nsfw_count = nil
	m.addnsfw_count = nil
}

// SetSeed sets the "seed" field.
func (m *GenerationMutation) SetSeed(i int) {
	m.seed = &i
	m.addseed = nil
}

// Seed returns the value of the "seed" field in the mutation.
func (m *GenerationMutation) Seed() (r int, exists bool) {
	v := m.seed
	if v == nil {
		return
	}
	return *v, true
}

// OldSeed returns the old "seed" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldSeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeed: %w", err)
	}
	return oldValue.Seed, nil
}

// AddSeed adds i to the "seed" field.
func (m *GenerationMutation) AddSeed(i int) {
	if m.addseed != nil {
		*m.addseed += i
	} else {
		m.addseed = &i
	}
}

// AddedSeed returns the value that was added to the "seed" field in this mutation.
func (m *GenerationMutation) AddedSeed() (r int, exists bool) {
	v := m.addseed
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeed resets all changes to the "seed" field.
func (m *GenerationMutation) ResetSeed() {
	m.seed = nil
	m.addseed = nil
}

// SetStatus sets the "status" field.
func (m *GenerationMutation) SetStatus(ge generation.Status) {
	m.status = &ge
}

// Status returns the value of the "status" field in the mutation.
func (m *GenerationMutation) Status() (r generation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldStatus(ctx context.Context) (v generation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GenerationMutation) ResetStatus() {
	m.status = nil
}

// SetFailureReason sets the "failure_reason" field.
func (m *GenerationMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *GenerationMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldFailureReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *GenerationMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[generation.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *GenerationMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[generation.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *GenerationMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, generation.FieldFailureReason)
}

// SetCountryCode sets the "country_code" field.
func (m *GenerationMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *GenerationMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldCountryCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ClearCountryCode clears the value of the "country_code" field.
func (m *GenerationMutation) ClearCountryCode() {
	m.country_code = nil
	m.clearedFields[generation.FieldCountryCode] = struct{}{}
}

// CountryCodeCleared returns if the "country_code" field was cleared in this mutation.
func (m *GenerationMutation) CountryCodeCleared() bool {
	_, ok := m.clearedFields[generation.FieldCountryCode]
	return ok
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *GenerationMutation) ResetCountryCode() {
	m.country_code = nil
	delete(m.clearedFields, generation.FieldCountryCode)
}

// SetInitImageURL sets the "init_image_url" field.
func (m *GenerationMutation) SetInitImageURL(s string) {
	m.init_image_url = &s
}

// InitImageURL returns the value of the "init_image_url" field in the mutation.
func (m *GenerationMutation) InitImageURL() (r string, exists bool) {
	v := m.init_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInitImageURL returns the old "init_image_url" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldInitImageURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitImageURL: %w", err)
	}
	return oldValue.InitImageURL, nil
}

// ClearInitImageURL clears the value of the "init_image_url" field.
func (m *GenerationMutation) ClearInitImageURL() {
	m.init_image_url = nil
	m.clearedFields[generation.FieldInitImageURL] = struct{}{}
}

// InitImageURLCleared returns if the "init_image_url" field was cleared in this mutation.
func (m *GenerationMutation) InitImageURLCleared() bool {
	_, ok := m.clearedFields[generation.FieldInitImageURL]
	return ok
}

// ResetInitImageURL resets all changes to the "init_image_url" field.
func (m *GenerationMutation) ResetInitImageURL() {
	m.init_image_url = nil
	delete(m.clearedFields, generation.FieldInitImageURL)
}

// SetSubmitToGallery sets the "submit_to_gallery" field.
func (m *GenerationMutation) SetSubmitToGallery(b bool) {
	m.submit_to_gallery = &b
}

// SubmitToGallery returns the value of the "submit_to_gallery" field in the mutation.
func (m *GenerationMutation) SubmitToGallery() (r bool, exists bool) {
	v := m.submit_to_gallery
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmitToGallery returns the old "submit_to_gallery" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldSubmitToGallery(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmitToGallery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmitToGallery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmitToGallery: %w", err)
	}
	return oldValue.SubmitToGallery, nil
}

// ResetSubmitToGallery resets all changes to the "submit_to_gallery" field.
func (m *GenerationMutation) ResetSubmitToGallery() {
	m.submit_to_gallery = nil
}

// SetPromptID sets the "prompt_id" field.
func (m *GenerationMutation) SetPromptID(u uuid.UUID) {
	m.prompt = &u
}

// PromptID returns the value of the "prompt_id" field in the mutation.
func (m *GenerationMutation) PromptID() (r uuid.UUID, exists bool) {
	v := m.prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptID returns the old "prompt_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldPromptID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptID: %w", err)
	}
	return oldValue.PromptID, nil
}

// ClearPromptID clears the value of the "prompt_id" field.
func (m *GenerationMutation) ClearPromptID() {
	m.prompt = nil
	m.clearedFields[generation.FieldPromptID] = struct{}{}
}

// PromptIDCleared returns if the "prompt_id" field was cleared in this mutation.
func (m *GenerationMutation) PromptIDCleared() bool {
	_, ok := m.clearedFields[generation.FieldPromptID]
	return ok
}

// ResetPromptID resets all changes to the "prompt_id" field.
func (m *GenerationMutation) ResetPromptID() {
	m.prompt = nil
	delete(m.clearedFields, generation.FieldPromptID)
}

// SetNegativePromptID sets the "negative_prompt_id" field.
func (m *GenerationMutation) SetNegativePromptID(u uuid.UUID) {
	m.negative_prompt = &u
}

// NegativePromptID returns the value of the "negative_prompt_id" field in the mutation.
func (m *GenerationMutation) NegativePromptID() (r uuid.UUID, exists bool) {
	v := m.negative_prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldNegativePromptID returns the old "negative_prompt_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldNegativePromptID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNegativePromptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNegativePromptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNegativePromptID: %w", err)
	}
	return oldValue.NegativePromptID, nil
}

// ClearNegativePromptID clears the value of the "negative_prompt_id" field.
func (m *GenerationMutation) ClearNegativePromptID() {
	m.negative_prompt = nil
	m.clearedFields[generation.FieldNegativePromptID] = struct{}{}
}

// NegativePromptIDCleared returns if the "negative_prompt_id" field was cleared in this mutation.
func (m *GenerationMutation) NegativePromptIDCleared() bool {
	_, ok := m.clearedFields[generation.FieldNegativePromptID]
	return ok
}

// ResetNegativePromptID resets all changes to the "negative_prompt_id" field.
func (m *GenerationMutation) ResetNegativePromptID() {
	m.negative_prompt = nil
	delete(m.clearedFields, generation.FieldNegativePromptID)
}

// SetModelID sets the "model_id" field.
func (m *GenerationMutation) SetModelID(u uuid.UUID) {
	m.generation_model = &u
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *GenerationMutation) ModelID() (r uuid.UUID, exists bool) {
	v := m.generation_model
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldModelID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *GenerationMutation) ResetModelID() {
	m.generation_model = nil
}

// SetSchedulerID sets the "scheduler_id" field.
func (m *GenerationMutation) SetSchedulerID(u uuid.UUID) {
	m.scheduler = &u
}

// SchedulerID returns the value of the "scheduler_id" field in the mutation.
func (m *GenerationMutation) SchedulerID() (r uuid.UUID, exists bool) {
	v := m.scheduler
	if v == nil {
		return
	}
	return *v, true
}

// OldSchedulerID returns the old "scheduler_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldSchedulerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchedulerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchedulerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchedulerID: %w", err)
	}
	return oldValue.SchedulerID, nil
}

// ResetSchedulerID resets all changes to the "scheduler_id" field.
func (m *GenerationMutation) ResetSchedulerID() {
	m.scheduler = nil
}

// SetUserID sets the "user_id" field.
func (m *GenerationMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GenerationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GenerationMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceInfoID sets the "device_info_id" field.
func (m *GenerationMutation) SetDeviceInfoID(u uuid.UUID) {
	m.device_info = &u
}

// DeviceInfoID returns the value of the "device_info_id" field in the mutation.
func (m *GenerationMutation) DeviceInfoID() (r uuid.UUID, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfoID returns the old "device_info_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldDeviceInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfoID: %w", err)
	}
	return oldValue.DeviceInfoID, nil
}

// ResetDeviceInfoID resets all changes to the "device_info_id" field.
func (m *GenerationMutation) ResetDeviceInfoID() {
	m.device_info = nil
}

// SetStartedAt sets the "started_at" field.
func (m *GenerationMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *GenerationMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *GenerationMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[generation.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *GenerationMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[generation.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *GenerationMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, generation.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *GenerationMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *GenerationMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *GenerationMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[generation.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *GenerationMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[generation.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *GenerationMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, generation.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *GenerationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GenerationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GenerationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GenerationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GenerationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GenerationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearDeviceInfo clears the "device_info" edge to the DeviceInfo entity.
func (m *GenerationMutation) ClearDeviceInfo() {
	m.cleareddevice_info = true
}

// DeviceInfoCleared reports if the "device_info" edge to the DeviceInfo entity was cleared.
func (m *GenerationMutation) DeviceInfoCleared() bool {
	return m.cleareddevice_info
}

// DeviceInfoIDs returns the "device_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceInfoID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) DeviceInfoIDs() (ids []uuid.UUID) {
	if id := m.device_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeviceInfo resets all changes to the "device_info" edge.
func (m *GenerationMutation) ResetDeviceInfo() {
	m.device_info = nil
	m.cleareddevice_info = false
}

// ClearScheduler clears the "scheduler" edge to the Scheduler entity.
func (m *GenerationMutation) ClearScheduler() {
	m.clearedscheduler = true
}

// SchedulerCleared reports if the "scheduler" edge to the Scheduler entity was cleared.
func (m *GenerationMutation) SchedulerCleared() bool {
	return m.clearedscheduler
}

// SchedulerIDs returns the "scheduler" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchedulerID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) SchedulerIDs() (ids []uuid.UUID) {
	if id := m.scheduler; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScheduler resets all changes to the "scheduler" edge.
func (m *GenerationMutation) ResetScheduler() {
	m.scheduler = nil
	m.clearedscheduler = false
}

// ClearPrompt clears the "prompt" edge to the Prompt entity.
func (m *GenerationMutation) ClearPrompt() {
	m.clearedprompt = true
}

// PromptCleared reports if the "prompt" edge to the Prompt entity was cleared.
func (m *GenerationMutation) PromptCleared() bool {
	return m.PromptIDCleared() || m.clearedprompt
}

// PromptIDs returns the "prompt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PromptID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) PromptIDs() (ids []uuid.UUID) {
	if id := m.prompt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrompt resets all changes to the "prompt" edge.
func (m *GenerationMutation) ResetPrompt() {
	m.prompt = nil
	m.clearedprompt = false
}

// ClearNegativePrompt clears the "negative_prompt" edge to the NegativePrompt entity.
func (m *GenerationMutation) ClearNegativePrompt() {
	m.clearednegative_prompt = true
}

// NegativePromptCleared reports if the "negative_prompt" edge to the NegativePrompt entity was cleared.
func (m *GenerationMutation) NegativePromptCleared() bool {
	return m.NegativePromptIDCleared() || m.clearednegative_prompt
}

// NegativePromptIDs returns the "negative_prompt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NegativePromptID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) NegativePromptIDs() (ids []uuid.UUID) {
	if id := m.negative_prompt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNegativePrompt resets all changes to the "negative_prompt" edge.
func (m *GenerationMutation) ResetNegativePrompt() {
	m.negative_prompt = nil
	m.clearednegative_prompt = false
}

// SetGenerationModelID sets the "generation_model" edge to the GenerationModel entity by id.
func (m *GenerationMutation) SetGenerationModelID(id uuid.UUID) {
	m.generation_model = &id
}

// ClearGenerationModel clears the "generation_model" edge to the GenerationModel entity.
func (m *GenerationMutation) ClearGenerationModel() {
	m.clearedgeneration_model = true
}

// GenerationModelCleared reports if the "generation_model" edge to the GenerationModel entity was cleared.
func (m *GenerationMutation) GenerationModelCleared() bool {
	return m.clearedgeneration_model
}

// GenerationModelID returns the "generation_model" edge ID in the mutation.
func (m *GenerationMutation) GenerationModelID() (id uuid.UUID, exists bool) {
	if m.generation_model != nil {
		return *m.generation_model, true
	}
	return
}

// GenerationModelIDs returns the "generation_model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenerationModelID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) GenerationModelIDs() (ids []uuid.UUID) {
	if id := m.generation_model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenerationModel resets all changes to the "generation_model" edge.
func (m *GenerationMutation) ResetGenerationModel() {
	m.generation_model = nil
	m.clearedgeneration_model = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *GenerationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *GenerationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *GenerationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddGenerationOutputIDs adds the "generation_outputs" edge to the GenerationOutput entity by ids.
func (m *GenerationMutation) AddGenerationOutputIDs(ids ...uuid.UUID) {
	if m.generation_outputs == nil {
		m.generation_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generation_outputs[ids[i]] = struct{}{}
	}
}

// ClearGenerationOutputs clears the "generation_outputs" edge to the GenerationOutput entity.
func (m *GenerationMutation) ClearGenerationOutputs() {
	m.clearedgeneration_outputs = true
}

// GenerationOutputsCleared reports if the "generation_outputs" edge to the GenerationOutput entity was cleared.
func (m *GenerationMutation) GenerationOutputsCleared() bool {
	return m.clearedgeneration_outputs
}

// RemoveGenerationOutputIDs removes the "generation_outputs" edge to the GenerationOutput entity by IDs.
func (m *GenerationMutation) RemoveGenerationOutputIDs(ids ...uuid.UUID) {
	if m.removedgeneration_outputs == nil {
		m.removedgeneration_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generation_outputs, ids[i])
		m.removedgeneration_outputs[ids[i]] = struct{}{}
	}
}

// RemovedGenerationOutputs returns the removed IDs of the "generation_outputs" edge to the GenerationOutput entity.
func (m *GenerationMutation) RemovedGenerationOutputsIDs() (ids []uuid.UUID) {
	for id := range m.removedgeneration_outputs {
		ids = append(ids, id)
	}
	return
}

// GenerationOutputsIDs returns the "generation_outputs" edge IDs in the mutation.
func (m *GenerationMutation) GenerationOutputsIDs() (ids []uuid.UUID) {
	for id := range m.generation_outputs {
		ids = append(ids, id)
	}
	return
}

// ResetGenerationOutputs resets all changes to the "generation_outputs" edge.
func (m *GenerationMutation) ResetGenerationOutputs() {
	m.generation_outputs = nil
	m.clearedgeneration_outputs = false
	m.removedgeneration_outputs = nil
}

// Where appends a list predicates to the GenerationMutation builder.
func (m *GenerationMutation) Where(ps ...predicate.Generation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GenerationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GenerationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Generation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GenerationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GenerationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Generation).
func (m *GenerationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenerationMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.width != nil {
		fields = append(fields, generation.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, generation.FieldHeight)
	}
	if m.inference_steps != nil {
		fields = append(fields, generation.FieldInferenceSteps)
	}
	if m.guidance_scale != nil {
		fields = append(fields, generation.FieldGuidanceScale)
	}
	if m.num_outputs != nil {
		fields = append(fields, generation.FieldNumOutputs)
	}
	if m.nsfw_count != nil {
		fields = append(fields, generation.FieldNsfwCount)
	}
	if m.seed != nil {
		fields = append(fields, generation.FieldSeed)
	}
	if m.status != nil {
		fields = append(fields, generation.FieldStatus)
	}
	if m.failure_reason != nil {
		fields = append(fields, generation.FieldFailureReason)
	}
	if m.country_code != nil {
		fields = append(fields, generation.FieldCountryCode)
	}
	if m.init_image_url != nil {
		fields = append(fields, generation.FieldInitImageURL)
	}
	if m.submit_to_gallery != nil {
		fields = append(fields, generation.FieldSubmitToGallery)
	}
	if m.prompt != nil {
		fields = append(fields, generation.FieldPromptID)
	}
	if m.negative_prompt != nil {
		fields = append(fields, generation.FieldNegativePromptID)
	}
	if m.generation_model != nil {
		fields = append(fields, generation.FieldModelID)
	}
	if m.scheduler != nil {
		fields = append(fields, generation.FieldSchedulerID)
	}
	if m.user != nil {
		fields = append(fields, generation.FieldUserID)
	}
	if m.device_info != nil {
		fields = append(fields, generation.FieldDeviceInfoID)
	}
	if m.started_at != nil {
		fields = append(fields, generation.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, generation.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, generation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenerationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generation.FieldWidth:
		return m.Width()
	case generation.FieldHeight:
		return m.Height()
	case generation.FieldInferenceSteps:
		return m.InferenceSteps()
	case generation.FieldGuidanceScale:
		return m.GuidanceScale()
	case generation.FieldNumOutputs:
		return m.NumOutputs()
	case generation.FieldNsfwCount:
		return m.NsfwCount()
	case generation.FieldSeed:
		return m.Seed()
	case generation.FieldStatus:
		return m.Status()
	case generation.FieldFailureReason:
		return m.FailureReason()
	case generation.FieldCountryCode:
		return m.CountryCode()
	case generation.FieldInitImageURL:
		return m.InitImageURL()
	case generation.FieldSubmitToGallery:
		return m.SubmitToGallery()
	case generation.FieldPromptID:
		return m.PromptID()
	case generation.FieldNegativePromptID:
		return m.NegativePromptID()
	case generation.FieldModelID:
		return m.ModelID()
	case generation.FieldSchedulerID:
		return m.SchedulerID()
	case generation.FieldUserID:
		return m.UserID()
	case generation.FieldDeviceInfoID:
		return m.DeviceInfoID()
	case generation.FieldStartedAt:
		return m.StartedAt()
	case generation.FieldCompletedAt:
		return m.CompletedAt()
	case generation.FieldCreatedAt:
		return m.CreatedAt()
	case generation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenerationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generation.FieldWidth:
		return m.OldWidth(ctx)
	case generation.FieldHeight:
		return m.OldHeight(ctx)
	case generation.FieldInferenceSteps:
		return m.OldInferenceSteps(ctx)
	case generation.FieldGuidanceScale:
		return m.OldGuidanceScale(ctx)
	case generation.FieldNumOutputs:
		return m.OldNumOutputs(ctx)
	case generation.FieldNsfwCount:
		return m.OldNsfwCount(ctx)
	case generation.FieldSeed:
		return m.OldSeed(ctx)
	case generation.FieldStatus:
		return m.OldStatus(ctx)
	case generation.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case generation.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case generation.FieldInitImageURL:
		return m.OldInitImageURL(ctx)
	case generation.FieldSubmitToGallery:
		return m.OldSubmitToGallery(ctx)
	case generation.FieldPromptID:
		return m.OldPromptID(ctx)
	case generation.FieldNegativePromptID:
		return m.OldNegativePromptID(ctx)
	case generation.FieldModelID:
		return m.OldModelID(ctx)
	case generation.FieldSchedulerID:
		return m.OldSchedulerID(ctx)
	case generation.FieldUserID:
		return m.OldUserID(ctx)
	case generation.FieldDeviceInfoID:
		return m.OldDeviceInfoID(ctx)
	case generation.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case generation.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case generation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Generation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generation.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case generation.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case generation.FieldInferenceSteps:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInferenceSteps(v)
		return nil
	case generation.FieldGuidanceScale:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuidanceScale(v)
		return nil
	case generation.FieldNumOutputs:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumOutputs(v)
		return nil
	case generation.FieldNsfwCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNsfwCount(v)
		return nil
	case generation.FieldSeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeed(v)
		return nil
	case generation.FieldStatus:
		v, ok := value.(generation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case generation.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case generation.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case generation.FieldInitImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitImageURL(v)
		return nil
	case generation.FieldSubmitToGallery:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmitToGallery(v)
		return nil
	case generation.FieldPromptID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptID(v)
		return nil
	case generation.FieldNegativePromptID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNegativePromptID(v)
		return nil
	case generation.FieldModelID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case generation.FieldSchedulerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchedulerID(v)
		return nil
	case generation.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case generation.FieldDeviceInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfoID(v)
		return nil
	case generation.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case generation.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case generation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Generation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenerationMutation) AddedFields() []string {
	var fields []string
	if m.addwidth != nil {
		fields = append(fields, generation.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, generation.FieldHeight)
	}
	if m.addinference_steps != nil {
		fields = append(fields, generation.FieldInferenceSteps)
	}
	if m.addguidance_scale != nil {
		fields = append(fields, generation.FieldGuidanceScale)
	}
	if m.addnum_outputs != nil {
		fields = append(fields, generation.FieldNumOutputs)
	}
	if m.addnsfw_count != nil {
		fields = append(fields, generation.FieldNsfwCount)
	}
	if m.addseed != nil {
		fields = append(fields, generation.FieldSeed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenerationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case generation.FieldWidth:
		return m.AddedWidth()
	case generation.FieldHeight:
		return m.AddedHeight()
	case generation.FieldInferenceSteps:
		return m.AddedInferenceSteps()
	case generation.FieldGuidanceScale:
		return m.AddedGuidanceScale()
	case generation.FieldNumOutputs:
		return m.AddedNumOutputs()
	case generation.FieldNsfwCount:
		return m.AddedNsfwCount()
	case generation.FieldSeed:
		return m.AddedSeed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case generation.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case generation.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case generation.FieldInferenceSteps:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInferenceSteps(v)
		return nil
	case generation.FieldGuidanceScale:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGuidanceScale(v)
		return nil
	case generation.FieldNumOutputs:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumOutputs(v)
		return nil
	case generation.FieldNsfwCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNsfwCount(v)
		return nil
	case generation.FieldSeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeed(v)
		return nil
	}
	return fmt.Errorf("unknown Generation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenerationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(generation.FieldFailureReason) {
		fields = append(fields, generation.FieldFailureReason)
	}
	if m.FieldCleared(generation.FieldCountryCode) {
		fields = append(fields, generation.FieldCountryCode)
	}
	if m.FieldCleared(generation.FieldInitImageURL) {
		fields = append(fields, generation.FieldInitImageURL)
	}
	if m.FieldCleared(generation.FieldPromptID) {
		fields = append(fields, generation.FieldPromptID)
	}
	if m.FieldCleared(generation.FieldNegativePromptID) {
		fields = append(fields, generation.FieldNegativePromptID)
	}
	if m.FieldCleared(generation.FieldStartedAt) {
		fields = append(fields, generation.FieldStartedAt)
	}
	if m.FieldCleared(generation.FieldCompletedAt) {
		fields = append(fields, generation.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenerationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenerationMutation) ClearField(name string) error {
	switch name {
	case generation.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	case generation.FieldCountryCode:
		m.ClearCountryCode()
		return nil
	case generation.FieldInitImageURL:
		m.ClearInitImageURL()
		return nil
	case generation.FieldPromptID:
		m.ClearPromptID()
		return nil
	case generation.FieldNegativePromptID:
		m.ClearNegativePromptID()
		return nil
	case generation.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case generation.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Generation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenerationMutation) ResetField(name string) error {
	switch name {
	case generation.FieldWidth:
		m.ResetWidth()
		return nil
	case generation.FieldHeight:
		m.ResetHeight()
		return nil
	case generation.FieldInferenceSteps:
		m.ResetInferenceSteps()
		return nil
	case generation.FieldGuidanceScale:
		m.ResetGuidanceScale()
		return nil
	case generation.FieldNumOutputs:
		m.ResetNumOutputs()
		return nil
	case generation.FieldNsfwCount:
		m.ResetNsfwCount()
		return nil
	case generation.FieldSeed:
		m.ResetSeed()
		return nil
	case generation.FieldStatus:
		m.ResetStatus()
		return nil
	case generation.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case generation.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case generation.FieldInitImageURL:
		m.ResetInitImageURL()
		return nil
	case generation.FieldSubmitToGallery:
		m.ResetSubmitToGallery()
		return nil
	case generation.FieldPromptID:
		m.ResetPromptID()
		return nil
	case generation.FieldNegativePromptID:
		m.ResetNegativePromptID()
		return nil
	case generation.FieldModelID:
		m.ResetModelID()
		return nil
	case generation.FieldSchedulerID:
		m.ResetSchedulerID()
		return nil
	case generation.FieldUserID:
		m.ResetUserID()
		return nil
	case generation.FieldDeviceInfoID:
		m.ResetDeviceInfoID()
		return nil
	case generation.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case generation.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case generation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Generation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenerationMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.device_info != nil {
		edges = append(edges, generation.EdgeDeviceInfo)
	}
	if m.scheduler != nil {
		edges = append(edges, generation.EdgeScheduler)
	}
	if m.prompt != nil {
		edges = append(edges, generation.EdgePrompt)
	}
	if m.negative_prompt != nil {
		edges = append(edges, generation.EdgeNegativePrompt)
	}
	if m.generation_model != nil {
		edges = append(edges, generation.EdgeGenerationModel)
	}
	if m.user != nil {
		edges = append(edges, generation.EdgeUser)
	}
	if m.generation_outputs != nil {
		edges = append(edges, generation.EdgeGenerationOutputs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenerationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generation.EdgeDeviceInfo:
		if id := m.device_info; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeScheduler:
		if id := m.scheduler; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgePrompt:
		if id := m.prompt; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeNegativePrompt:
		if id := m.negative_prompt; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeGenerationModel:
		if id := m.generation_model; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeGenerationOutputs:
		ids := make([]ent.Value, 0, len(m.generation_outputs))
		for id := range m.generation_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenerationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedgeneration_outputs != nil {
		edges = append(edges, generation.EdgeGenerationOutputs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenerationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case generation.EdgeGenerationOutputs:
		ids := make([]ent.Value, 0, len(m.removedgeneration_outputs))
		for id := range m.removedgeneration_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenerationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleareddevice_info {
		edges = append(edges, generation.EdgeDeviceInfo)
	}
	if m.clearedscheduler {
		edges = append(edges, generation.EdgeScheduler)
	}
	if m.clearedprompt {
		edges = append(edges, generation.EdgePrompt)
	}
	if m.clearednegative_prompt {
		edges = append(edges, generation.EdgeNegativePrompt)
	}
	if m.clearedgeneration_model {
		edges = append(edges, generation.EdgeGenerationModel)
	}
	if m.cleareduser {
		edges = append(edges, generation.EdgeUser)
	}
	if m.clearedgeneration_outputs {
		edges = append(edges, generation.EdgeGenerationOutputs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenerationMutation) EdgeCleared(name string) bool {
	switch name {
	case generation.EdgeDeviceInfo:
		return m.cleareddevice_info
	case generation.EdgeScheduler:
		return m.clearedscheduler
	case generation.EdgePrompt:
		return m.clearedprompt
	case generation.EdgeNegativePrompt:
		return m.clearednegative_prompt
	case generation.EdgeGenerationModel:
		return m.clearedgeneration_model
	case generation.EdgeUser:
		return m.cleareduser
	case generation.EdgeGenerationOutputs:
		return m.clearedgeneration_outputs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenerationMutation) ClearEdge(name string) error {
	switch name {
	case generation.EdgeDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case generation.EdgeScheduler:
		m.ClearScheduler()
		return nil
	case generation.EdgePrompt:
		m.ClearPrompt()
		return nil
	case generation.EdgeNegativePrompt:
		m.ClearNegativePrompt()
		return nil
	case generation.EdgeGenerationModel:
		m.ClearGenerationModel()
		return nil
	case generation.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Generation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenerationMutation) ResetEdge(name string) error {
	switch name {
	case generation.EdgeDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case generation.EdgeScheduler:
		m.ResetScheduler()
		return nil
	case generation.EdgePrompt:
		m.ResetPrompt()
		return nil
	case generation.EdgeNegativePrompt:
		m.ResetNegativePrompt()
		return nil
	case generation.EdgeGenerationModel:
		m.ResetGenerationModel()
		return nil
	case generation.EdgeUser:
		m.ResetUser()
		return nil
	case generation.EdgeGenerationOutputs:
		m.ResetGenerationOutputs()
		return nil
	}
	return fmt.Errorf("unknown Generation edge %s", name)
}

// GenerationModelMutation represents an operation that mutates the GenerationModel nodes in the graph.
type GenerationModelMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	name_in_worker     *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	done               bool
	oldValue           func(context.Context) (*GenerationModel, error)
	predicates         []predicate.GenerationModel
}

var _ ent.Mutation = (*GenerationModelMutation)(nil)

// generationmodelOption allows management of the mutation configuration using functional options.
type generationmodelOption func(*GenerationModelMutation)

// newGenerationModelMutation creates new mutation for the GenerationModel entity.
func newGenerationModelMutation(c config, op Op, opts ...generationmodelOption) *GenerationModelMutation {
	m := &GenerationModelMutation{
		config:        c,
		op:            op,
		typ:           TypeGenerationModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenerationModelID sets the ID field of the mutation.
func withGenerationModelID(id uuid.UUID) generationmodelOption {
	return func(m *GenerationModelMutation) {
		var (
			err   error
			once  sync.Once
			value *GenerationModel
		)
		m.oldValue = func(ctx context.Context) (*GenerationModel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GenerationModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGenerationModel sets the old GenerationModel of the mutation.
func withGenerationModel(node *GenerationModel) generationmodelOption {
	return func(m *GenerationModelMutation) {
		m.oldValue = func(context.Context) (*GenerationModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenerationModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenerationModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GenerationModel entities.
func (m *GenerationModelMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenerationModelMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenerationModelMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GenerationModel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameInWorker sets the "name_in_worker" field.
func (m *GenerationModelMutation) SetNameInWorker(s string) {
	m.name_in_worker = &s
}

// NameInWorker returns the value of the "name_in_worker" field in the mutation.
func (m *GenerationModelMutation) NameInWorker() (r string, exists bool) {
	v := m.name_in_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldNameInWorker returns the old "name_in_worker" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldNameInWorker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameInWorker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameInWorker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameInWorker: %w", err)
	}
	return oldValue.NameInWorker, nil
}

// ResetNameInWorker resets all changes to the "name_in_worker" field.
func (m *GenerationModelMutation) ResetNameInWorker() {
	m.name_in_worker = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GenerationModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GenerationModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GenerationModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GenerationModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GenerationModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GenerationModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *GenerationModelMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *GenerationModelMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *GenerationModelMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *GenerationModelMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *GenerationModelMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *GenerationModelMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *GenerationModelMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// Where appends a list predicates to the GenerationModelMutation builder.
func (m *GenerationModelMutation) Where(ps ...predicate.GenerationModel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GenerationModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GenerationModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GenerationModel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GenerationModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GenerationModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GenerationModel).
func (m *GenerationModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenerationModelMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name_in_worker != nil {
		fields = append(fields, generationmodel.FieldNameInWorker)
	}
	if m.created_at != nil {
		fields = append(fields, generationmodel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generationmodel.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenerationModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generationmodel.FieldNameInWorker:
		return m.NameInWorker()
	case generationmodel.FieldCreatedAt:
		return m.CreatedAt()
	case generationmodel.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenerationModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generationmodel.FieldNameInWorker:
		return m.OldNameInWorker(ctx)
	case generationmodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generationmodel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GenerationModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generationmodel.FieldNameInWorker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameInWorker(v)
		return nil
	case generationmodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generationmodel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GenerationModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenerationModelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenerationModelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GenerationModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenerationModelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenerationModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenerationModelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GenerationModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenerationModelMutation) ResetField(name string) error {
	switch name {
	case generationmodel.FieldNameInWorker:
		m.ResetNameInWorker()
		return nil
	case generationmodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generationmodel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GenerationModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenerationModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.generations != nil {
		edges = append(edges, generationmodel.EdgeGenerations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenerationModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generationmodel.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenerationModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgenerations != nil {
		edges = append(edges, generationmodel.EdgeGenerations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenerationModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case generationmodel.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenerationModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenerations {
		edges = append(edges, generationmodel.EdgeGenerations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenerationModelMutation) EdgeCleared(name string) bool {
	switch name {
	case generationmodel.EdgeGenerations:
		return m.clearedgenerations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenerationModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GenerationModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenerationModelMutation) ResetEdge(name string) error {
	switch name {
	case generationmodel.EdgeGenerations:
		m.ResetGenerations()
		return nil
	}
	return fmt.Errorf("unknown GenerationModel edge %s", name)
}

// GenerationOutputMutation represents an operation that mutates the GenerationOutput nodes in the graph.
type GenerationOutputMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	image_path             *string
	upscaled_image_path    *string
	gallery_status         *generationoutput.GalleryStatus
	deleted_at             *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	generations            *uuid.UUID
	clearedgenerations     bool
	upscale_outputs        *uuid.UUID
	clearedupscale_outputs bool
	done                   bool
	oldValue               func(context.Context) (*GenerationOutput, error)
	predicates             []predicate.GenerationOutput
}

var _ ent.Mutation = (*GenerationOutputMutation)(nil)

// generationoutputOption allows management of the mutation configuration using functional options.
type generationoutputOption func(*GenerationOutputMutation)

// newGenerationOutputMutation creates new mutation for the GenerationOutput entity.
func newGenerationOutputMutation(c config, op Op, opts ...generationoutputOption) *GenerationOutputMutation {
	m := &GenerationOutputMutation{
		config:        c,
		op:            op,
		typ:           TypeGenerationOutput,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenerationOutputID sets the ID field of the mutation.
func withGenerationOutputID(id uuid.UUID) generationoutputOption {
	return func(m *GenerationOutputMutation) {
		var (
			err   error
			once  sync.Once
			value *GenerationOutput
		)
		m.oldValue = func(ctx context.Context) (*GenerationOutput, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GenerationOutput.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGenerationOutput sets the old GenerationOutput of the mutation.
func withGenerationOutput(node *GenerationOutput) generationoutputOption {
	return func(m *GenerationOutputMutation) {
		m.oldValue = func(context.Context) (*GenerationOutput, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenerationOutputMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenerationOutputMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GenerationOutput entities.
func (m *GenerationOutputMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenerationOutputMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenerationOutputMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GenerationOutput.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImagePath sets the "image_path" field.
func (m *GenerationOutputMutation) SetImagePath(s string) {
	m.image_path = &s
}

// ImagePath returns the value of the "image_path" field in the mutation.
func (m *GenerationOutputMutation) ImagePath() (r string, exists bool) {
	v := m.image_path
	if v == nil {
		return
	}
	return *v, true
}

// OldImagePath returns the old "image_path" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldImagePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImagePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImagePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImagePath: %w", err)
	}
	return oldValue.ImagePath, nil
}

// ResetImagePath resets all changes to the "image_path" field.
func (m *GenerationOutputMutation) ResetImagePath() {
	m.image_path = nil
}

// SetUpscaledImagePath sets the "upscaled_image_path" field.
func (m *GenerationOutputMutation) SetUpscaledImagePath(s string) {
	m.upscaled_image_path = &s
}

// UpscaledImagePath returns the value of the "upscaled_image_path" field in the mutation.
func (m *GenerationOutputMutation) UpscaledImagePath() (r string, exists bool) {
	v := m.upscaled_image_path
	if v == nil {
		return
	}
	return *v, true
}

// OldUpscaledImagePath returns the old "upscaled_image_path" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldUpscaledImagePath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpscaledImagePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpscaledImagePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpscaledImagePath: %w", err)
	}
	return oldValue.UpscaledImagePath, nil
}

// ClearUpscaledImagePath clears the value of the "upscaled_image_path" field.
func (m *GenerationOutputMutation) ClearUpscaledImagePath() {
	m.upscaled_image_path = nil
	m.clearedFields[generationoutput.FieldUpscaledImagePath] = struct{}{}
}

// UpscaledImagePathCleared returns if the "upscaled_image_path" field was cleared in this mutation.
func (m *GenerationOutputMutation) UpscaledImagePathCleared() bool {
	_, ok := m.clearedFields[generationoutput.FieldUpscaledImagePath]
	return ok
}

// ResetUpscaledImagePath resets all changes to the "upscaled_image_path" field.
func (m *GenerationOutputMutation) ResetUpscaledImagePath() {
	m.upscaled_image_path = nil
	delete(m.clearedFields, generationoutput.FieldUpscaledImagePath)
}

// SetGalleryStatus sets the "gallery_status" field.
func (m *GenerationOutputMutation) SetGalleryStatus(gs generationoutput.GalleryStatus) {
	m.gallery_status = &gs
}

// GalleryStatus returns the value of the "gallery_status" field in the mutation.
func (m *GenerationOutputMutation) GalleryStatus() (r generationoutput.GalleryStatus, exists bool) {
	v := m.gallery_status
	if v == nil {
		return
	}
	return *v, true
}

// OldGalleryStatus returns the old "gallery_status" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldGalleryStatus(ctx context.Context) (v generationoutput.GalleryStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGalleryStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGalleryStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGalleryStatus: %w", err)
	}
	return oldValue.GalleryStatus, nil
}

// ResetGalleryStatus resets all changes to the "gallery_status" field.
func (m *GenerationOutputMutation) ResetGalleryStatus() {
	m.gallery_status = nil
}

// SetGenerationID sets the "generation_id" field.
func (m *GenerationOutputMutation) SetGenerationID(u uuid.UUID) {
	m.generations = &u
}

// GenerationID returns the value of the "generation_id" field in the mutation.
func (m *GenerationOutputMutation) GenerationID() (r uuid.UUID, exists bool) {
	v := m.generations
	if v == nil {
		return
	}
	return *v, true
}

// OldGenerationID returns the old "generation_id" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldGenerationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenerationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenerationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenerationID: %w", err)
	}
	return oldValue.GenerationID, nil
}

// ResetGenerationID resets all changes to the "generation_id" field.
func (m *GenerationOutputMutation) ResetGenerationID() {
	m.generations = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GenerationOutputMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GenerationOutputMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GenerationOutputMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[generationoutput.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GenerationOutputMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[generationoutput.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GenerationOutputMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, generationoutput.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *GenerationOutputMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GenerationOutputMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GenerationOutputMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GenerationOutputMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GenerationOutputMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GenerationOutputMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGenerationsID sets the "generations" edge to the Generation entity by id.
func (m *GenerationOutputMutation) SetGenerationsID(id uuid.UUID) {
	m.generations = &id
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *GenerationOutputMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *GenerationOutputMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// GenerationsID returns the "generations" edge ID in the mutation.
func (m *GenerationOutputMutation) GenerationsID() (id uuid.UUID, exists bool) {
	if m.generations != nil {
		return *m.generations, true
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenerationsID instead. It exists only for internal usage by the builders.
func (m *GenerationOutputMutation) GenerationsIDs() (ids []uuid.UUID) {
	if id := m.generations; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *GenerationOutputMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
}

// SetUpscaleOutputsID sets the "upscale_outputs" edge to the UpscaleOutput entity by id.
func (m *GenerationOutputMutation) SetUpscaleOutputsID(id uuid.UUID) {
	m.upscale_outputs = &id
}

// ClearUpscaleOutputs clears the "upscale_outputs" edge to the UpscaleOutput entity.
func (m *GenerationOutputMutation) ClearUpscaleOutputs() {
	m.clearedupscale_outputs = true
}

// UpscaleOutputsCleared reports if the "upscale_outputs" edge to the UpscaleOutput entity was cleared.
func (m *GenerationOutputMutation) UpscaleOutputsCleared() bool {
	return m.clearedupscale_outputs
}

// UpscaleOutputsID returns the "upscale_outputs" edge ID in the mutation.
func (m *GenerationOutputMutation) UpscaleOutputsID() (id uuid.UUID, exists bool) {
	if m.upscale_outputs != nil {
		return *m.upscale_outputs, true
	}
	return
}

// UpscaleOutputsIDs returns the "upscale_outputs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpscaleOutputsID instead. It exists only for internal usage by the builders.
func (m *GenerationOutputMutation) UpscaleOutputsIDs() (ids []uuid.UUID) {
	if id := m.upscale_outputs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpscaleOutputs resets all changes to the "upscale_outputs" edge.
func (m *GenerationOutputMutation) ResetUpscaleOutputs() {
	m.upscale_outputs = nil
	m.clearedupscale_outputs = false
}

// Where appends a list predicates to the GenerationOutputMutation builder.
func (m *GenerationOutputMutation) Where(ps ...predicate.GenerationOutput) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GenerationOutputMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GenerationOutputMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GenerationOutput, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GenerationOutputMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GenerationOutputMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GenerationOutput).
func (m *GenerationOutputMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenerationOutputMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.image_path != nil {
		fields = append(fields, generationoutput.FieldImagePath)
	}
	if m.upscaled_image_path != nil {
		fields = append(fields, generationoutput.FieldUpscaledImagePath)
	}
	if m.gallery_status != nil {
		fields = append(fields, generationoutput.FieldGalleryStatus)
	}
	if m.generations != nil {
		fields = append(fields, generationoutput.FieldGenerationID)
	}
	if m.deleted_at != nil {
		fields = append(fields, generationoutput.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, generationoutput.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generationoutput.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenerationOutputMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generationoutput.FieldImagePath:
		return m.ImagePath()
	case generationoutput.FieldUpscaledImagePath:
		return m.UpscaledImagePath()
	case generationoutput.FieldGalleryStatus:
		return m.GalleryStatus()
	case generationoutput.FieldGenerationID:
		return m.GenerationID()
	case generationoutput.FieldDeletedAt:
		return m.DeletedAt()
	case generationoutput.FieldCreatedAt:
		return m.CreatedAt()
	case generationoutput.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenerationOutputMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generationoutput.FieldImagePath:
		return m.OldImagePath(ctx)
	case generationoutput.FieldUpscaledImagePath:
		return m.OldUpscaledImagePath(ctx)
	case generationoutput.FieldGalleryStatus:
		return m.OldGalleryStatus(ctx)
	case generationoutput.FieldGenerationID:
		return m.OldGenerationID(ctx)
	case generationoutput.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case generationoutput.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generationoutput.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GenerationOutput field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationOutputMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generationoutput.FieldImagePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImagePath(v)
		return nil
	case generationoutput.FieldUpscaledImagePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpscaledImagePath(v)
		return nil
	case generationoutput.FieldGalleryStatus:
		v, ok := value.(generationoutput.GalleryStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGalleryStatus(v)
		return nil
	case generationoutput.FieldGenerationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenerationID(v)
		return nil
	case generationoutput.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case generationoutput.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generationoutput.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenerationOutputMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenerationOutputMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationOutputMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GenerationOutput numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenerationOutputMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(generationoutput.FieldUpscaledImagePath) {
		fields = append(fields, generationoutput.FieldUpscaledImagePath)
	}
	if m.FieldCleared(generationoutput.FieldDeletedAt) {
		fields = append(fields, generationoutput.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenerationOutputMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenerationOutputMutation) ClearField(name string) error {
	switch name {
	case generationoutput.FieldUpscaledImagePath:
		m.ClearUpscaledImagePath()
		return nil
	case generationoutput.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenerationOutputMutation) ResetField(name string) error {
	switch name {
	case generationoutput.FieldImagePath:
		m.ResetImagePath()
		return nil
	case generationoutput.FieldUpscaledImagePath:
		m.ResetUpscaledImagePath()
		return nil
	case generationoutput.FieldGalleryStatus:
		m.ResetGalleryStatus()
		return nil
	case generationoutput.FieldGenerationID:
		m.ResetGenerationID()
		return nil
	case generationoutput.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case generationoutput.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generationoutput.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenerationOutputMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.generations != nil {
		edges = append(edges, generationoutput.EdgeGenerations)
	}
	if m.upscale_outputs != nil {
		edges = append(edges, generationoutput.EdgeUpscaleOutputs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenerationOutputMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generationoutput.EdgeGenerations:
		if id := m.generations; id != nil {
			return []ent.Value{*id}
		}
	case generationoutput.EdgeUpscaleOutputs:
		if id := m.upscale_outputs; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenerationOutputMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenerationOutputMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenerationOutputMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgenerations {
		edges = append(edges, generationoutput.EdgeGenerations)
	}
	if m.clearedupscale_outputs {
		edges = append(edges, generationoutput.EdgeUpscaleOutputs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenerationOutputMutation) EdgeCleared(name string) bool {
	switch name {
	case generationoutput.EdgeGenerations:
		return m.clearedgenerations
	case generationoutput.EdgeUpscaleOutputs:
		return m.clearedupscale_outputs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenerationOutputMutation) ClearEdge(name string) error {
	switch name {
	case generationoutput.EdgeGenerations:
		m.ClearGenerations()
		return nil
	case generationoutput.EdgeUpscaleOutputs:
		m.ClearUpscaleOutputs()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenerationOutputMutation) ResetEdge(name string) error {
	switch name {
	case generationoutput.EdgeGenerations:
		m.ResetGenerations()
		return nil
	case generationoutput.EdgeUpscaleOutputs:
		m.ResetUpscaleOutputs()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput edge %s", name)
}

// NegativePromptMutation represents an operation that mutates the NegativePrompt nodes in the graph.
type NegativePromptMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	text               *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	done               bool
	oldValue           func(context.Context) (*NegativePrompt, error)
	predicates         []predicate.NegativePrompt
}

var _ ent.Mutation = (*NegativePromptMutation)(nil)

// negativepromptOption allows management of the mutation configuration using functional options.
type negativepromptOption func(*NegativePromptMutation)

// newNegativePromptMutation creates new mutation for the NegativePrompt entity.
func newNegativePromptMutation(c config, op Op, opts ...negativepromptOption) *NegativePromptMutation {
	m := &NegativePromptMutation{
		config:        c,
		op:            op,
		typ:           TypeNegativePrompt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNegativePromptID sets the ID field of the mutation.
func withNegativePromptID(id uuid.UUID) negativepromptOption {
	return func(m *NegativePromptMutation) {
		var (
			err   error
			once  sync.Once
			value *NegativePrompt
		)
		m.oldValue = func(ctx context.Context) (*NegativePrompt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NegativePrompt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNegativePrompt sets the old NegativePrompt of the mutation.
func withNegativePrompt(node *NegativePrompt) negativepromptOption {
	return func(m *NegativePromptMutation) {
		m.oldValue = func(context.Context) (*NegativePrompt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NegativePromptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NegativePromptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NegativePrompt entities.
func (m *NegativePromptMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NegativePromptMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NegativePromptMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NegativePrompt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *NegativePromptMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *NegativePromptMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the NegativePrompt entity.
// If the NegativePrompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NegativePromptMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *NegativePromptMutation) ResetText() {
	m.text = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NegativePromptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NegativePromptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NegativePrompt entity.
// If the NegativePrompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NegativePromptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NegativePromptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NegativePromptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NegativePromptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NegativePrompt entity.
// If the NegativePrompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NegativePromptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NegativePromptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *NegativePromptMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *NegativePromptMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *NegativePromptMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *NegativePromptMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *NegativePromptMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *NegativePromptMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *NegativePromptMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// Where appends a list predicates to the NegativePromptMutation builder.
func (m *NegativePromptMutation) Where(ps ...predicate.NegativePrompt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NegativePromptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NegativePromptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NegativePrompt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NegativePromptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NegativePromptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NegativePrompt).
func (m *NegativePromptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NegativePromptMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.text != nil {
		fields = append(fields, negativeprompt.FieldText)
	}
	if m.created_at != nil {
		fields = append(fields, negativeprompt.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, negativeprompt.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NegativePromptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case negativeprompt.FieldText:
		return m.Text()
	case negativeprompt.FieldCreatedAt:
		return m.CreatedAt()
	case negativeprompt.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NegativePromptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case negativeprompt.FieldText:
		return m.OldText(ctx)
	case negativeprompt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case negativeprompt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NegativePrompt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NegativePromptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case negativeprompt.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case negativeprompt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case negativeprompt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NegativePrompt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NegativePromptMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NegativePromptMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NegativePromptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NegativePrompt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NegativePromptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NegativePromptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NegativePromptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NegativePrompt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NegativePromptMutation) ResetField(name string) error {
	switch name {
	case negativeprompt.FieldText:
		m.ResetText()
		return nil
	case negativeprompt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case negativeprompt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NegativePrompt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NegativePromptMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.generations != nil {
		edges = append(edges, negativeprompt.EdgeGenerations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NegativePromptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case negativeprompt.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NegativePromptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgenerations != nil {
		edges = append(edges, negativeprompt.EdgeGenerations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NegativePromptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case negativeprompt.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NegativePromptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenerations {
		edges = append(edges, negativeprompt.EdgeGenerations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NegativePromptMutation) EdgeCleared(name string) bool {
	switch name {
	case negativeprompt.EdgeGenerations:
		return m.clearedgenerations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NegativePromptMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NegativePrompt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NegativePromptMutation) ResetEdge(name string) error {
	switch name {
	case negativeprompt.EdgeGenerations:
		m.ResetGenerations()
		return nil
	}
	return fmt.Errorf("unknown NegativePrompt edge %s", name)
}

// PromptMutation represents an operation that mutates the Prompt nodes in the graph.
type PromptMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	text               *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	done               bool
	oldValue           func(context.Context) (*Prompt, error)
	predicates         []predicate.Prompt
}

var _ ent.Mutation = (*PromptMutation)(nil)

// promptOption allows management of the mutation configuration using functional options.
type promptOption func(*PromptMutation)

// newPromptMutation creates new mutation for the Prompt entity.
func newPromptMutation(c config, op Op, opts ...promptOption) *PromptMutation {
	m := &PromptMutation{
		config:        c,
		op:            op,
		typ:           TypePrompt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromptID sets the ID field of the mutation.
func withPromptID(id uuid.UUID) promptOption {
	return func(m *PromptMutation) {
		var (
			err   error
			once  sync.Once
			value *Prompt
		)
		m.oldValue = func(ctx context.Context) (*Prompt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prompt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrompt sets the old Prompt of the mutation.
func withPrompt(node *Prompt) promptOption {
	return func(m *PromptMutation) {
		m.oldValue = func(context.Context) (*Prompt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Prompt entities.
func (m *PromptMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromptMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromptMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Prompt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *PromptMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *PromptMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *PromptMutation) ResetText() {
	m.text = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PromptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *PromptMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *PromptMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *PromptMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *PromptMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *PromptMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *PromptMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *PromptMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// Where appends a list predicates to the PromptMutation builder.
func (m *PromptMutation) Where(ps ...predicate.Prompt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Prompt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Prompt).
func (m *PromptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromptMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.text != nil {
		fields = append(fields, prompt.FieldText)
	}
	if m.created_at != nil {
		fields = append(fields, prompt.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, prompt.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prompt.FieldText:
		return m.Text()
	case prompt.FieldCreatedAt:
		return m.CreatedAt()
	case prompt.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prompt.FieldText:
		return m.OldText(ctx)
	case prompt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prompt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Prompt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prompt.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case prompt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prompt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromptMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromptMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Prompt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prompt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromptMutation) ResetField(name string) error {
	switch name {
	case prompt.FieldText:
		m.ResetText()
		return nil
	case prompt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prompt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromptMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.generations != nil {
		edges = append(edges, prompt.EdgeGenerations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgenerations != nil {
		edges = append(edges, prompt.EdgeGenerations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenerations {
		edges = append(edges, prompt.EdgeGenerations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromptMutation) EdgeCleared(name string) bool {
	switch name {
	case prompt.EdgeGenerations:
		return m.clearedgenerations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromptMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prompt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromptMutation) ResetEdge(name string) error {
	switch name {
	case prompt.EdgeGenerations:
		m.ResetGenerations()
		return nil
	}
	return fmt.Errorf("unknown Prompt edge %s", name)
}

// SchedulerMutation represents an operation that mutates the Scheduler nodes in the graph.
type SchedulerMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	name_in_worker     *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	done               bool
	oldValue           func(context.Context) (*Scheduler, error)
	predicates         []predicate.Scheduler
}

var _ ent.Mutation = (*SchedulerMutation)(nil)

// schedulerOption allows management of the mutation configuration using functional options.
type schedulerOption func(*SchedulerMutation)

// newSchedulerMutation creates new mutation for the Scheduler entity.
func newSchedulerMutation(c config, op Op, opts ...schedulerOption) *SchedulerMutation {
	m := &SchedulerMutation{
		config:        c,
		op:            op,
		typ:           TypeScheduler,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchedulerID sets the ID field of the mutation.
func withSchedulerID(id uuid.UUID) schedulerOption {
	return func(m *SchedulerMutation) {
		var (
			err   error
			once  sync.Once
			value *Scheduler
		)
		m.oldValue = func(ctx context.Context) (*Scheduler, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scheduler.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheduler sets the old Scheduler of the mutation.
func withScheduler(node *Scheduler) schedulerOption {
	return func(m *SchedulerMutation) {
		m.oldValue = func(context.Context) (*Scheduler, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchedulerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchedulerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Scheduler entities.
func (m *SchedulerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchedulerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchedulerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Scheduler.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameInWorker sets the "name_in_worker" field.
func (m *SchedulerMutation) SetNameInWorker(s string) {
	m.name_in_worker = &s
}

// NameInWorker returns the value of the "name_in_worker" field in the mutation.
func (m *SchedulerMutation) NameInWorker() (r string, exists bool) {
	v := m.name_in_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldNameInWorker returns the old "name_in_worker" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldNameInWorker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameInWorker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameInWorker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameInWorker: %w", err)
	}
	return oldValue.NameInWorker, nil
}

// ResetNameInWorker resets all changes to the "name_in_worker" field.
func (m *SchedulerMutation) ResetNameInWorker() {
	m.name_in_worker = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SchedulerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SchedulerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SchedulerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SchedulerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SchedulerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SchedulerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *SchedulerMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *SchedulerMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *SchedulerMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *SchedulerMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *SchedulerMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *SchedulerMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *SchedulerMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// Where appends a list predicates to the SchedulerMutation builder.
func (m *SchedulerMutation) Where(ps ...predicate.Scheduler) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchedulerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchedulerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Scheduler, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchedulerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchedulerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Scheduler).
func (m *SchedulerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchedulerMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name_in_worker != nil {
		fields = append(fields, scheduler.FieldNameInWorker)
	}
	if m.created_at != nil {
		fields = append(fields, scheduler.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, scheduler.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchedulerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scheduler.FieldNameInWorker:
		return m.NameInWorker()
	case scheduler.FieldCreatedAt:
		return m.CreatedAt()
	case scheduler.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchedulerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scheduler.FieldNameInWorker:
		return m.OldNameInWorker(ctx)
	case scheduler.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case scheduler.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Scheduler field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchedulerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scheduler.FieldNameInWorker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameInWorker(v)
		return nil
	case scheduler.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case scheduler.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Scheduler field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchedulerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchedulerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchedulerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Scheduler numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchedulerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchedulerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchedulerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Scheduler nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchedulerMutation) ResetField(name string) error {
	switch name {
	case scheduler.FieldNameInWorker:
		m.ResetNameInWorker()
		return nil
	case scheduler.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case scheduler.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Scheduler field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchedulerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.generations != nil {
		edges = append(edges, scheduler.EdgeGenerations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchedulerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scheduler.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchedulerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgenerations != nil {
		edges = append(edges, scheduler.EdgeGenerations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchedulerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case scheduler.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchedulerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenerations {
		edges = append(edges, scheduler.EdgeGenerations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchedulerMutation) EdgeCleared(name string) bool {
	switch name {
	case scheduler.EdgeGenerations:
		return m.clearedgenerations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchedulerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Scheduler unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchedulerMutation) ResetEdge(name string) error {
	switch name {
	case scheduler.EdgeGenerations:
		m.ResetGenerations()
		return nil
	}
	return fmt.Errorf("unknown Scheduler edge %s", name)
}

// UpscaleMutation represents an operation that mutates the Upscale nodes in the graph.
type UpscaleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	width                  *int32
	addwidth               *int32
	height                 *int32
	addheight              *int32
	scale                  *int32
	addscale               *int32
	country_code           *string
	status                 *upscale.Status
	failure_reason         *string
	started_at             *time.Time
	completed_at           *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	user                   *uuid.UUID
	cleareduser            bool
	device_info            *uuid.UUID
	cleareddevice_info     bool
	upscale_models         *uuid.UUID
	clearedupscale_models  bool
	upscale_outputs        map[uuid.UUID]struct{}
	removedupscale_outputs map[uuid.UUID]struct{}
	clearedupscale_outputs bool
	done                   bool
	oldValue               func(context.Context) (*Upscale, error)
	predicates             []predicate.Upscale
}

var _ ent.Mutation = (*UpscaleMutation)(nil)

// upscaleOption allows management of the mutation configuration using functional options.
type upscaleOption func(*UpscaleMutation)

// newUpscaleMutation creates new mutation for the Upscale entity.
func newUpscaleMutation(c config, op Op, opts ...upscaleOption) *UpscaleMutation {
	m := &UpscaleMutation{
		config:        c,
		op:            op,
		typ:           TypeUpscale,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpscaleID sets the ID field of the mutation.
func withUpscaleID(id uuid.UUID) upscaleOption {
	return func(m *UpscaleMutation) {
		var (
			err   error
			once  sync.Once
			value *Upscale
		)
		m.oldValue = func(ctx context.Context) (*Upscale, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Upscale.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpscale sets the old Upscale of the mutation.
func withUpscale(node *Upscale) upscaleOption {
	return func(m *UpscaleMutation) {
		m.oldValue = func(context.Context) (*Upscale, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpscaleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpscaleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Upscale entities.
func (m *UpscaleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpscaleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpscaleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Upscale.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWidth sets the "width" field.
func (m *UpscaleMutation) SetWidth(i int32) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *UpscaleMutation) Width() (r int32, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldWidth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *UpscaleMutation) AddWidth(i int32) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *UpscaleMutation) AddedWidth() (r int32, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *UpscaleMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *UpscaleMutation) SetHeight(i int32) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *UpscaleMutation) Height() (r int32, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldHeight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *UpscaleMutation) AddHeight(i int32) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *UpscaleMutation) AddedHeight() (r int32, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *UpscaleMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetScale sets the "scale" field.
func (m *UpscaleMutation) SetScale(i int32) {
	m.scale = &i
	m.addscale = nil
}

// Scale returns the value of the "scale" field in the mutation.
func (m *UpscaleMutation) Scale() (r int32, exists bool) {
	v := m.scale
	if v == nil {
		return
	}
	return *v, true
}

// OldScale returns the old "scale" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldScale(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScale: %w", err)
	}
	return oldValue.Scale, nil
}

// AddScale adds i to the "scale" field.
func (m *UpscaleMutation) AddScale(i int32) {
	if m.addscale != nil {
		*m.addscale += i
	} else {
		m.addscale = &i
	}
}

// AddedScale returns the value that was added to the "scale" field in this mutation.
func (m *UpscaleMutation) AddedScale() (r int32, exists bool) {
	v := m.addscale
	if v == nil {
		return
	}
	return *v, true
}

// ResetScale resets all changes to the "scale" field.
func (m *UpscaleMutation) ResetScale() {
	m.scale = nil
	m.addscale = nil
}

// SetCountryCode sets the "country_code" field.
func (m *UpscaleMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *UpscaleMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldCountryCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ClearCountryCode clears the value of the "country_code" field.
func (m *UpscaleMutation) ClearCountryCode() {
	m.country_code = nil
	m.clearedFields[upscale.FieldCountryCode] = struct{}{}
}

// CountryCodeCleared returns if the "country_code" field was cleared in this mutation.
func (m *UpscaleMutation) CountryCodeCleared() bool {
	_, ok := m.clearedFields[upscale.FieldCountryCode]
	return ok
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *UpscaleMutation) ResetCountryCode() {
	m.country_code = nil
	delete(m.clearedFields, upscale.FieldCountryCode)
}

// SetStatus sets the "status" field.
func (m *UpscaleMutation) SetStatus(u upscale.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UpscaleMutation) Status() (r upscale.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldStatus(ctx context.Context) (v upscale.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UpscaleMutation) ResetStatus() {
	m.status = nil
}

// SetFailureReason sets the "failure_reason" field.
func (m *UpscaleMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *UpscaleMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldFailureReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *UpscaleMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[upscale.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *UpscaleMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[upscale.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *UpscaleMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, upscale.FieldFailureReason)
}

// SetUserID sets the "user_id" field.
func (m *UpscaleMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UpscaleMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UpscaleMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceInfoID sets the "device_info_id" field.
func (m *UpscaleMutation) SetDeviceInfoID(u uuid.UUID) {
	m.device_info = &u
}

// DeviceInfoID returns the value of the "device_info_id" field in the mutation.
func (m *UpscaleMutation) DeviceInfoID() (r uuid.UUID, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfoID returns the old "device_info_id" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldDeviceInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfoID: %w", err)
	}
	return oldValue.DeviceInfoID, nil
}

// ResetDeviceInfoID resets all changes to the "device_info_id" field.
func (m *UpscaleMutation) ResetDeviceInfoID() {
	m.device_info = nil
}

// SetModelID sets the "model_id" field.
func (m *UpscaleMutation) SetModelID(u uuid.UUID) {
	m.upscale_models = &u
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *UpscaleMutation) ModelID() (r uuid.UUID, exists bool) {
	v := m.upscale_models
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldModelID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *UpscaleMutation) ResetModelID() {
	m.upscale_models = nil
}

// SetStartedAt sets the "started_at" field.
func (m *UpscaleMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *UpscaleMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *UpscaleMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[upscale.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *UpscaleMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[upscale.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *UpscaleMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, upscale.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *UpscaleMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *UpscaleMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *UpscaleMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[upscale.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *UpscaleMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[upscale.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *UpscaleMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, upscale.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UpscaleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UpscaleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UpscaleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UpscaleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UpscaleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UpscaleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UpscaleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UpscaleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UpscaleMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UpscaleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearDeviceInfo clears the "device_info" edge to the DeviceInfo entity.
func (m *UpscaleMutation) ClearDeviceInfo() {
	m.cleareddevice_info = true
}

// DeviceInfoCleared reports if the "device_info" edge to the DeviceInfo entity was cleared.
func (m *UpscaleMutation) DeviceInfoCleared() bool {
	return m.cleareddevice_info
}

// DeviceInfoIDs returns the "device_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceInfoID instead. It exists only for internal usage by the builders.
func (m *UpscaleMutation) DeviceInfoIDs() (ids []uuid.UUID) {
	if id := m.device_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeviceInfo resets all changes to the "device_info" edge.
func (m *UpscaleMutation) ResetDeviceInfo() {
	m.device_info = nil
	m.cleareddevice_info = false
}

// SetUpscaleModelsID sets the "upscale_models" edge to the UpscaleModel entity by id.
func (m *UpscaleMutation) SetUpscaleModelsID(id uuid.UUID) {
	m.upscale_models = &id
}

// ClearUpscaleModels clears the "upscale_models" edge to the UpscaleModel entity.
func (m *UpscaleMutation) ClearUpscaleModels() {
	m.clearedupscale_models = true
}

// UpscaleModelsCleared reports if the "upscale_models" edge to the UpscaleModel entity was cleared.
func (m *UpscaleMutation) UpscaleModelsCleared() bool {
	return m.clearedupscale_models
}

// UpscaleModelsID returns the "upscale_models" edge ID in the mutation.
func (m *UpscaleMutation) UpscaleModelsID() (id uuid.UUID, exists bool) {
	if m.upscale_models != nil {
		return *m.upscale_models, true
	}
	return
}

// UpscaleModelsIDs returns the "upscale_models" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpscaleModelsID instead. It exists only for internal usage by the builders.
func (m *UpscaleMutation) UpscaleModelsIDs() (ids []uuid.UUID) {
	if id := m.upscale_models; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpscaleModels resets all changes to the "upscale_models" edge.
func (m *UpscaleMutation) ResetUpscaleModels() {
	m.upscale_models = nil
	m.clearedupscale_models = false
}

// AddUpscaleOutputIDs adds the "upscale_outputs" edge to the UpscaleOutput entity by ids.
func (m *UpscaleMutation) AddUpscaleOutputIDs(ids ...uuid.UUID) {
	if m.upscale_outputs == nil {
		m.upscale_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscale_outputs[ids[i]] = struct{}{}
	}
}

// ClearUpscaleOutputs clears the "upscale_outputs" edge to the UpscaleOutput entity.
func (m *UpscaleMutation) ClearUpscaleOutputs() {
	m.clearedupscale_outputs = true
}

// UpscaleOutputsCleared reports if the "upscale_outputs" edge to the UpscaleOutput entity was cleared.
func (m *UpscaleMutation) UpscaleOutputsCleared() bool {
	return m.clearedupscale_outputs
}

// RemoveUpscaleOutputIDs removes the "upscale_outputs" edge to the UpscaleOutput entity by IDs.
func (m *UpscaleMutation) RemoveUpscaleOutputIDs(ids ...uuid.UUID) {
	if m.removedupscale_outputs == nil {
		m.removedupscale_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscale_outputs, ids[i])
		m.removedupscale_outputs[ids[i]] = struct{}{}
	}
}

// RemovedUpscaleOutputs returns the removed IDs of the "upscale_outputs" edge to the UpscaleOutput entity.
func (m *UpscaleMutation) RemovedUpscaleOutputsIDs() (ids []uuid.UUID) {
	for id := range m.removedupscale_outputs {
		ids = append(ids, id)
	}
	return
}

// UpscaleOutputsIDs returns the "upscale_outputs" edge IDs in the mutation.
func (m *UpscaleMutation) UpscaleOutputsIDs() (ids []uuid.UUID) {
	for id := range m.upscale_outputs {
		ids = append(ids, id)
	}
	return
}

// ResetUpscaleOutputs resets all changes to the "upscale_outputs" edge.
func (m *UpscaleMutation) ResetUpscaleOutputs() {
	m.upscale_outputs = nil
	m.clearedupscale_outputs = false
	m.removedupscale_outputs = nil
}

// Where appends a list predicates to the UpscaleMutation builder.
func (m *UpscaleMutation) Where(ps ...predicate.Upscale) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpscaleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpscaleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Upscale, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpscaleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpscaleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Upscale).
func (m *UpscaleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpscaleMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.width != nil {
		fields = append(fields, upscale.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, upscale.FieldHeight)
	}
	if m.scale != nil {
		fields = append(fields, upscale.FieldScale)
	}
	if m.country_code != nil {
		fields = append(fields, upscale.FieldCountryCode)
	}
	if m.status != nil {
		fields = append(fields, upscale.FieldStatus)
	}
	if m.failure_reason != nil {
		fields = append(fields, upscale.FieldFailureReason)
	}
	if m.user != nil {
		fields = append(fields, upscale.FieldUserID)
	}
	if m.device_info != nil {
		fields = append(fields, upscale.FieldDeviceInfoID)
	}
	if m.upscale_models != nil {
		fields = append(fields, upscale.FieldModelID)
	}
	if m.started_at != nil {
		fields = append(fields, upscale.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, upscale.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, upscale.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, upscale.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpscaleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upscale.FieldWidth:
		return m.Width()
	case upscale.FieldHeight:
		return m.Height()
	case upscale.FieldScale:
		return m.Scale()
	case upscale.FieldCountryCode:
		return m.CountryCode()
	case upscale.FieldStatus:
		return m.Status()
	case upscale.FieldFailureReason:
		return m.FailureReason()
	case upscale.FieldUserID:
		return m.UserID()
	case upscale.FieldDeviceInfoID:
		return m.DeviceInfoID()
	case upscale.FieldModelID:
		return m.ModelID()
	case upscale.FieldStartedAt:
		return m.StartedAt()
	case upscale.FieldCompletedAt:
		return m.CompletedAt()
	case upscale.FieldCreatedAt:
		return m.CreatedAt()
	case upscale.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpscaleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upscale.FieldWidth:
		return m.OldWidth(ctx)
	case upscale.FieldHeight:
		return m.OldHeight(ctx)
	case upscale.FieldScale:
		return m.OldScale(ctx)
	case upscale.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case upscale.FieldStatus:
		return m.OldStatus(ctx)
	case upscale.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case upscale.FieldUserID:
		return m.OldUserID(ctx)
	case upscale.FieldDeviceInfoID:
		return m.OldDeviceInfoID(ctx)
	case upscale.FieldModelID:
		return m.OldModelID(ctx)
	case upscale.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case upscale.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case upscale.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case upscale.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Upscale field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upscale.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case upscale.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case upscale.FieldScale:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScale(v)
		return nil
	case upscale.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case upscale.FieldStatus:
		v, ok := value.(upscale.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case upscale.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case upscale.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case upscale.FieldDeviceInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfoID(v)
		return nil
	case upscale.FieldModelID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case upscale.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case upscale.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case upscale.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case upscale.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Upscale field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpscaleMutation) AddedFields() []string {
	var fields []string
	if m.addwidth != nil {
		fields = append(fields, upscale.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, upscale.FieldHeight)
	}
	if m.addscale != nil {
		fields = append(fields, upscale.FieldScale)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpscaleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upscale.FieldWidth:
		return m.AddedWidth()
	case upscale.FieldHeight:
		return m.AddedHeight()
	case upscale.FieldScale:
		return m.AddedScale()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upscale.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case upscale.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case upscale.FieldScale:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScale(v)
		return nil
	}
	return fmt.Errorf("unknown Upscale numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpscaleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upscale.FieldCountryCode) {
		fields = append(fields, upscale.FieldCountryCode)
	}
	if m.FieldCleared(upscale.FieldFailureReason) {
		fields = append(fields, upscale.FieldFailureReason)
	}
	if m.FieldCleared(upscale.FieldStartedAt) {
		fields = append(fields, upscale.FieldStartedAt)
	}
	if m.FieldCleared(upscale.FieldCompletedAt) {
		fields = append(fields, upscale.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpscaleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpscaleMutation) ClearField(name string) error {
	switch name {
	case upscale.FieldCountryCode:
		m.ClearCountryCode()
		return nil
	case upscale.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	case upscale.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case upscale.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Upscale nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpscaleMutation) ResetField(name string) error {
	switch name {
	case upscale.FieldWidth:
		m.ResetWidth()
		return nil
	case upscale.FieldHeight:
		m.ResetHeight()
		return nil
	case upscale.FieldScale:
		m.ResetScale()
		return nil
	case upscale.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case upscale.FieldStatus:
		m.ResetStatus()
		return nil
	case upscale.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case upscale.FieldUserID:
		m.ResetUserID()
		return nil
	case upscale.FieldDeviceInfoID:
		m.ResetDeviceInfoID()
		return nil
	case upscale.FieldModelID:
		m.ResetModelID()
		return nil
	case upscale.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case upscale.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case upscale.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case upscale.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Upscale field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpscaleMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, upscale.EdgeUser)
	}
	if m.device_info != nil {
		edges = append(edges, upscale.EdgeDeviceInfo)
	}
	if m.upscale_models != nil {
		edges = append(edges, upscale.EdgeUpscaleModels)
	}
	if m.upscale_outputs != nil {
		edges = append(edges, upscale.EdgeUpscaleOutputs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpscaleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case upscale.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case upscale.EdgeDeviceInfo:
		if id := m.device_info; id != nil {
			return []ent.Value{*id}
		}
	case upscale.EdgeUpscaleModels:
		if id := m.upscale_models; id != nil {
			return []ent.Value{*id}
		}
	case upscale.EdgeUpscaleOutputs:
		ids := make([]ent.Value, 0, len(m.upscale_outputs))
		for id := range m.upscale_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpscaleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedupscale_outputs != nil {
		edges = append(edges, upscale.EdgeUpscaleOutputs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpscaleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case upscale.EdgeUpscaleOutputs:
		ids := make([]ent.Value, 0, len(m.removedupscale_outputs))
		for id := range m.removedupscale_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpscaleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, upscale.EdgeUser)
	}
	if m.cleareddevice_info {
		edges = append(edges, upscale.EdgeDeviceInfo)
	}
	if m.clearedupscale_models {
		edges = append(edges, upscale.EdgeUpscaleModels)
	}
	if m.clearedupscale_outputs {
		edges = append(edges, upscale.EdgeUpscaleOutputs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpscaleMutation) EdgeCleared(name string) bool {
	switch name {
	case upscale.EdgeUser:
		return m.cleareduser
	case upscale.EdgeDeviceInfo:
		return m.cleareddevice_info
	case upscale.EdgeUpscaleModels:
		return m.clearedupscale_models
	case upscale.EdgeUpscaleOutputs:
		return m.clearedupscale_outputs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpscaleMutation) ClearEdge(name string) error {
	switch name {
	case upscale.EdgeUser:
		m.ClearUser()
		return nil
	case upscale.EdgeDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case upscale.EdgeUpscaleModels:
		m.ClearUpscaleModels()
		return nil
	}
	return fmt.Errorf("unknown Upscale unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpscaleMutation) ResetEdge(name string) error {
	switch name {
	case upscale.EdgeUser:
		m.ResetUser()
		return nil
	case upscale.EdgeDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case upscale.EdgeUpscaleModels:
		m.ResetUpscaleModels()
		return nil
	case upscale.EdgeUpscaleOutputs:
		m.ResetUpscaleOutputs()
		return nil
	}
	return fmt.Errorf("unknown Upscale edge %s", name)
}

// UpscaleModelMutation represents an operation that mutates the UpscaleModel nodes in the graph.
type UpscaleModelMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name_in_worker  *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	upscales        map[uuid.UUID]struct{}
	removedupscales map[uuid.UUID]struct{}
	clearedupscales bool
	done            bool
	oldValue        func(context.Context) (*UpscaleModel, error)
	predicates      []predicate.UpscaleModel
}

var _ ent.Mutation = (*UpscaleModelMutation)(nil)

// upscalemodelOption allows management of the mutation configuration using functional options.
type upscalemodelOption func(*UpscaleModelMutation)

// newUpscaleModelMutation creates new mutation for the UpscaleModel entity.
func newUpscaleModelMutation(c config, op Op, opts ...upscalemodelOption) *UpscaleModelMutation {
	m := &UpscaleModelMutation{
		config:        c,
		op:            op,
		typ:           TypeUpscaleModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpscaleModelID sets the ID field of the mutation.
func withUpscaleModelID(id uuid.UUID) upscalemodelOption {
	return func(m *UpscaleModelMutation) {
		var (
			err   error
			once  sync.Once
			value *UpscaleModel
		)
		m.oldValue = func(ctx context.Context) (*UpscaleModel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpscaleModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpscaleModel sets the old UpscaleModel of the mutation.
func withUpscaleModel(node *UpscaleModel) upscalemodelOption {
	return func(m *UpscaleModelMutation) {
		m.oldValue = func(context.Context) (*UpscaleModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpscaleModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpscaleModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpscaleModel entities.
func (m *UpscaleModelMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpscaleModelMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpscaleModelMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpscaleModel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameInWorker sets the "name_in_worker" field.
func (m *UpscaleModelMutation) SetNameInWorker(s string) {
	m.name_in_worker = &s
}

// NameInWorker returns the value of the "name_in_worker" field in the mutation.
func (m *UpscaleModelMutation) NameInWorker() (r string, exists bool) {
	v := m.name_in_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldNameInWorker returns the old "name_in_worker" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldNameInWorker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameInWorker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameInWorker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameInWorker: %w", err)
	}
	return oldValue.NameInWorker, nil
}

// ResetNameInWorker resets all changes to the "name_in_worker" field.
func (m *UpscaleModelMutation) ResetNameInWorker() {
	m.name_in_worker = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UpscaleModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UpscaleModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UpscaleModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UpscaleModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UpscaleModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UpscaleModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUpscaleIDs adds the "upscales" edge to the Upscale entity by ids.
func (m *UpscaleModelMutation) AddUpscaleIDs(ids ...uuid.UUID) {
	if m.upscales == nil {
		m.upscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscales[ids[i]] = struct{}{}
	}
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *UpscaleModelMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *UpscaleModelMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// RemoveUpscaleIDs removes the "upscales" edge to the Upscale entity by IDs.
func (m *UpscaleModelMutation) RemoveUpscaleIDs(ids ...uuid.UUID) {
	if m.removedupscales == nil {
		m.removedupscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscales, ids[i])
		m.removedupscales[ids[i]] = struct{}{}
	}
}

// RemovedUpscales returns the removed IDs of the "upscales" edge to the Upscale entity.
func (m *UpscaleModelMutation) RemovedUpscalesIDs() (ids []uuid.UUID) {
	for id := range m.removedupscales {
		ids = append(ids, id)
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
func (m *UpscaleModelMutation) UpscalesIDs() (ids []uuid.UUID) {
	for id := range m.upscales {
		ids = append(ids, id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *UpscaleModelMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
	m.removedupscales = nil
}

// Where appends a list predicates to the UpscaleModelMutation builder.
func (m *UpscaleModelMutation) Where(ps ...predicate.UpscaleModel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpscaleModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpscaleModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpscaleModel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpscaleModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpscaleModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpscaleModel).
func (m *UpscaleModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpscaleModelMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name_in_worker != nil {
		fields = append(fields, upscalemodel.FieldNameInWorker)
	}
	if m.created_at != nil {
		fields = append(fields, upscalemodel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, upscalemodel.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpscaleModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upscalemodel.FieldNameInWorker:
		return m.NameInWorker()
	case upscalemodel.FieldCreatedAt:
		return m.CreatedAt()
	case upscalemodel.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpscaleModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upscalemodel.FieldNameInWorker:
		return m.OldNameInWorker(ctx)
	case upscalemodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case upscalemodel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpscaleModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upscalemodel.FieldNameInWorker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameInWorker(v)
		return nil
	case upscalemodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case upscalemodel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpscaleModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpscaleModelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpscaleModelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UpscaleModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpscaleModelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpscaleModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpscaleModelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UpscaleModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpscaleModelMutation) ResetField(name string) error {
	switch name {
	case upscalemodel.FieldNameInWorker:
		m.ResetNameInWorker()
		return nil
	case upscalemodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case upscalemodel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UpscaleModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpscaleModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.upscales != nil {
		edges = append(edges, upscalemodel.EdgeUpscales)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpscaleModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case upscalemodel.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.upscales))
		for id := range m.upscales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpscaleModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedupscales != nil {
		edges = append(edges, upscalemodel.EdgeUpscales)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpscaleModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case upscalemodel.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.removedupscales))
		for id := range m.removedupscales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpscaleModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedupscales {
		edges = append(edges, upscalemodel.EdgeUpscales)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpscaleModelMutation) EdgeCleared(name string) bool {
	switch name {
	case upscalemodel.EdgeUpscales:
		return m.clearedupscales
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpscaleModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UpscaleModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpscaleModelMutation) ResetEdge(name string) error {
	switch name {
	case upscalemodel.EdgeUpscales:
		m.ResetUpscales()
		return nil
	}
	return fmt.Errorf("unknown UpscaleModel edge %s", name)
}

// UpscaleOutputMutation represents an operation that mutates the UpscaleOutput nodes in the graph.
type UpscaleOutputMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	image_path               *string
	input_image_url          *string
	deleted_at               *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	upscales                 *uuid.UUID
	clearedupscales          bool
	generation_output        *uuid.UUID
	clearedgeneration_output bool
	done                     bool
	oldValue                 func(context.Context) (*UpscaleOutput, error)
	predicates               []predicate.UpscaleOutput
}

var _ ent.Mutation = (*UpscaleOutputMutation)(nil)

// upscaleoutputOption allows management of the mutation configuration using functional options.
type upscaleoutputOption func(*UpscaleOutputMutation)

// newUpscaleOutputMutation creates new mutation for the UpscaleOutput entity.
func newUpscaleOutputMutation(c config, op Op, opts ...upscaleoutputOption) *UpscaleOutputMutation {
	m := &UpscaleOutputMutation{
		config:        c,
		op:            op,
		typ:           TypeUpscaleOutput,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpscaleOutputID sets the ID field of the mutation.
func withUpscaleOutputID(id uuid.UUID) upscaleoutputOption {
	return func(m *UpscaleOutputMutation) {
		var (
			err   error
			once  sync.Once
			value *UpscaleOutput
		)
		m.oldValue = func(ctx context.Context) (*UpscaleOutput, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpscaleOutput.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpscaleOutput sets the old UpscaleOutput of the mutation.
func withUpscaleOutput(node *UpscaleOutput) upscaleoutputOption {
	return func(m *UpscaleOutputMutation) {
		m.oldValue = func(context.Context) (*UpscaleOutput, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpscaleOutputMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpscaleOutputMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpscaleOutput entities.
func (m *UpscaleOutputMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpscaleOutputMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpscaleOutputMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpscaleOutput.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImagePath sets the "image_path" field.
func (m *UpscaleOutputMutation) SetImagePath(s string) {
	m.image_path = &s
}

// ImagePath returns the value of the "image_path" field in the mutation.
func (m *UpscaleOutputMutation) ImagePath() (r string, exists bool) {
	v := m.image_path
	if v == nil {
		return
	}
	return *v, true
}

// OldImagePath returns the old "image_path" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldImagePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImagePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImagePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImagePath: %w", err)
	}
	return oldValue.ImagePath, nil
}

// ResetImagePath resets all changes to the "image_path" field.
func (m *UpscaleOutputMutation) ResetImagePath() {
	m.image_path = nil
}

// SetInputImageURL sets the "input_image_url" field.
func (m *UpscaleOutputMutation) SetInputImageURL(s string) {
	m.input_image_url = &s
}

// InputImageURL returns the value of the "input_image_url" field in the mutation.
func (m *UpscaleOutputMutation) InputImageURL() (r string, exists bool) {
	v := m.input_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInputImageURL returns the old "input_image_url" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldInputImageURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputImageURL: %w", err)
	}
	return oldValue.InputImageURL, nil
}

// ClearInputImageURL clears the value of the "input_image_url" field.
func (m *UpscaleOutputMutation) ClearInputImageURL() {
	m.input_image_url = nil
	m.clearedFields[upscaleoutput.FieldInputImageURL] = struct{}{}
}

// InputImageURLCleared returns if the "input_image_url" field was cleared in this mutation.
func (m *UpscaleOutputMutation) InputImageURLCleared() bool {
	_, ok := m.clearedFields[upscaleoutput.FieldInputImageURL]
	return ok
}

// ResetInputImageURL resets all changes to the "input_image_url" field.
func (m *UpscaleOutputMutation) ResetInputImageURL() {
	m.input_image_url = nil
	delete(m.clearedFields, upscaleoutput.FieldInputImageURL)
}

// SetUpscaleID sets the "upscale_id" field.
func (m *UpscaleOutputMutation) SetUpscaleID(u uuid.UUID) {
	m.upscales = &u
}

// UpscaleID returns the value of the "upscale_id" field in the mutation.
func (m *UpscaleOutputMutation) UpscaleID() (r uuid.UUID, exists bool) {
	v := m.upscales
	if v == nil {
		return
	}
	return *v, true
}

// OldUpscaleID returns the old "upscale_id" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldUpscaleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpscaleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpscaleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpscaleID: %w", err)
	}
	return oldValue.UpscaleID, nil
}

// ResetUpscaleID resets all changes to the "upscale_id" field.
func (m *UpscaleOutputMutation) ResetUpscaleID() {
	m.upscales = nil
}

// SetGenerationOutputID sets the "generation_output_id" field.
func (m *UpscaleOutputMutation) SetGenerationOutputID(u uuid.UUID) {
	m.generation_output = &u
}

// GenerationOutputID returns the value of the "generation_output_id" field in the mutation.
func (m *UpscaleOutputMutation) GenerationOutputID() (r uuid.UUID, exists bool) {
	v := m.generation_output
	if v == nil {
		return
	}
	return *v, true
}

// OldGenerationOutputID returns the old "generation_output_id" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldGenerationOutputID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenerationOutputID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenerationOutputID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenerationOutputID: %w", err)
	}
	return oldValue.GenerationOutputID, nil
}

// ClearGenerationOutputID clears the value of the "generation_output_id" field.
func (m *UpscaleOutputMutation) ClearGenerationOutputID() {
	m.generation_output = nil
	m.clearedFields[upscaleoutput.FieldGenerationOutputID] = struct{}{}
}

// GenerationOutputIDCleared returns if the "generation_output_id" field was cleared in this mutation.
func (m *UpscaleOutputMutation) GenerationOutputIDCleared() bool {
	_, ok := m.clearedFields[upscaleoutput.FieldGenerationOutputID]
	return ok
}

// ResetGenerationOutputID resets all changes to the "generation_output_id" field.
func (m *UpscaleOutputMutation) ResetGenerationOutputID() {
	m.generation_output = nil
	delete(m.clearedFields, upscaleoutput.FieldGenerationOutputID)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UpscaleOutputMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UpscaleOutputMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UpscaleOutputMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[upscaleoutput.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UpscaleOutputMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[upscaleoutput.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UpscaleOutputMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, upscaleoutput.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UpscaleOutputMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UpscaleOutputMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UpscaleOutputMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UpscaleOutputMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UpscaleOutputMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UpscaleOutputMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpscalesID sets the "upscales" edge to the Upscale entity by id.
func (m *UpscaleOutputMutation) SetUpscalesID(id uuid.UUID) {
	m.upscales = &id
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *UpscaleOutputMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *UpscaleOutputMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// UpscalesID returns the "upscales" edge ID in the mutation.
func (m *UpscaleOutputMutation) UpscalesID() (id uuid.UUID, exists bool) {
	if m.upscales != nil {
		return *m.upscales, true
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpscalesID instead. It exists only for internal usage by the builders.
func (m *UpscaleOutputMutation) UpscalesIDs() (ids []uuid.UUID) {
	if id := m.upscales; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *UpscaleOutputMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
}

// ClearGenerationOutput clears the "generation_output" edge to the GenerationOutput entity.
func (m *UpscaleOutputMutation) ClearGenerationOutput() {
	m.clearedgeneration_output = true
}

// GenerationOutputCleared reports if the "generation_output" edge to the GenerationOutput entity was cleared.
func (m *UpscaleOutputMutation) GenerationOutputCleared() bool {
	return m.GenerationOutputIDCleared() || m.clearedgeneration_output
}

// GenerationOutputIDs returns the "generation_output" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenerationOutputID instead. It exists only for internal usage by the builders.
func (m *UpscaleOutputMutation) GenerationOutputIDs() (ids []uuid.UUID) {
	if id := m.generation_output; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenerationOutput resets all changes to the "generation_output" edge.
func (m *UpscaleOutputMutation) ResetGenerationOutput() {
	m.generation_output = nil
	m.clearedgeneration_output = false
}

// Where appends a list predicates to the UpscaleOutputMutation builder.
func (m *UpscaleOutputMutation) Where(ps ...predicate.UpscaleOutput) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpscaleOutputMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpscaleOutputMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpscaleOutput, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpscaleOutputMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpscaleOutputMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpscaleOutput).
func (m *UpscaleOutputMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpscaleOutputMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.image_path != nil {
		fields = append(fields, upscaleoutput.FieldImagePath)
	}
	if m.input_image_url != nil {
		fields = append(fields, upscaleoutput.FieldInputImageURL)
	}
	if m.upscales != nil {
		fields = append(fields, upscaleoutput.FieldUpscaleID)
	}
	if m.generation_output != nil {
		fields = append(fields, upscaleoutput.FieldGenerationOutputID)
	}
	if m.deleted_at != nil {
		fields = append(fields, upscaleoutput.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, upscaleoutput.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, upscaleoutput.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpscaleOutputMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upscaleoutput.FieldImagePath:
		return m.ImagePath()
	case upscaleoutput.FieldInputImageURL:
		return m.InputImageURL()
	case upscaleoutput.FieldUpscaleID:
		return m.UpscaleID()
	case upscaleoutput.FieldGenerationOutputID:
		return m.GenerationOutputID()
	case upscaleoutput.FieldDeletedAt:
		return m.DeletedAt()
	case upscaleoutput.FieldCreatedAt:
		return m.CreatedAt()
	case upscaleoutput.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpscaleOutputMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upscaleoutput.FieldImagePath:
		return m.OldImagePath(ctx)
	case upscaleoutput.FieldInputImageURL:
		return m.OldInputImageURL(ctx)
	case upscaleoutput.FieldUpscaleID:
		return m.OldUpscaleID(ctx)
	case upscaleoutput.FieldGenerationOutputID:
		return m.OldGenerationOutputID(ctx)
	case upscaleoutput.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case upscaleoutput.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case upscaleoutput.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpscaleOutput field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleOutputMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upscaleoutput.FieldImagePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImagePath(v)
		return nil
	case upscaleoutput.FieldInputImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputImageURL(v)
		return nil
	case upscaleoutput.FieldUpscaleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpscaleID(v)
		return nil
	case upscaleoutput.FieldGenerationOutputID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenerationOutputID(v)
		return nil
	case upscaleoutput.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case upscaleoutput.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case upscaleoutput.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpscaleOutputMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpscaleOutputMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleOutputMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UpscaleOutput numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpscaleOutputMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upscaleoutput.FieldInputImageURL) {
		fields = append(fields, upscaleoutput.FieldInputImageURL)
	}
	if m.FieldCleared(upscaleoutput.FieldGenerationOutputID) {
		fields = append(fields, upscaleoutput.FieldGenerationOutputID)
	}
	if m.FieldCleared(upscaleoutput.FieldDeletedAt) {
		fields = append(fields, upscaleoutput.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpscaleOutputMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpscaleOutputMutation) ClearField(name string) error {
	switch name {
	case upscaleoutput.FieldInputImageURL:
		m.ClearInputImageURL()
		return nil
	case upscaleoutput.FieldGenerationOutputID:
		m.ClearGenerationOutputID()
		return nil
	case upscaleoutput.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpscaleOutputMutation) ResetField(name string) error {
	switch name {
	case upscaleoutput.FieldImagePath:
		m.ResetImagePath()
		return nil
	case upscaleoutput.FieldInputImageURL:
		m.ResetInputImageURL()
		return nil
	case upscaleoutput.FieldUpscaleID:
		m.ResetUpscaleID()
		return nil
	case upscaleoutput.FieldGenerationOutputID:
		m.ResetGenerationOutputID()
		return nil
	case upscaleoutput.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case upscaleoutput.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case upscaleoutput.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpscaleOutputMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.upscales != nil {
		edges = append(edges, upscaleoutput.EdgeUpscales)
	}
	if m.generation_output != nil {
		edges = append(edges, upscaleoutput.EdgeGenerationOutput)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpscaleOutputMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case upscaleoutput.EdgeUpscales:
		if id := m.upscales; id != nil {
			return []ent.Value{*id}
		}
	case upscaleoutput.EdgeGenerationOutput:
		if id := m.generation_output; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpscaleOutputMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpscaleOutputMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpscaleOutputMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedupscales {
		edges = append(edges, upscaleoutput.EdgeUpscales)
	}
	if m.clearedgeneration_output {
		edges = append(edges, upscaleoutput.EdgeGenerationOutput)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpscaleOutputMutation) EdgeCleared(name string) bool {
	switch name {
	case upscaleoutput.EdgeUpscales:
		return m.clearedupscales
	case upscaleoutput.EdgeGenerationOutput:
		return m.clearedgeneration_output
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpscaleOutputMutation) ClearEdge(name string) error {
	switch name {
	case upscaleoutput.EdgeUpscales:
		m.ClearUpscales()
		return nil
	case upscaleoutput.EdgeGenerationOutput:
		m.ClearGenerationOutput()
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpscaleOutputMutation) ResetEdge(name string) error {
	switch name {
	case upscaleoutput.EdgeUpscales:
		m.ResetUpscales()
		return nil
	case upscaleoutput.EdgeGenerationOutput:
		m.ResetGenerationOutput()
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	email              *string
	stripe_customer_id *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	user_roles         map[uuid.UUID]struct{}
	removeduser_roles  map[uuid.UUID]struct{}
	cleareduser_roles  bool
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	upscales           map[uuid.UUID]struct{}
	removedupscales    map[uuid.UUID]struct{}
	clearedupscales    bool
	credits            map[uuid.UUID]struct{}
	removedcredits     map[uuid.UUID]struct{}
	clearedcredits     bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *UserMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *UserMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStripeCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *UserMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *UserMutation) AddUserRoleIDs(ids ...uuid.UUID) {
	if m.user_roles == nil {
		m.user_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *UserMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *UserMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveUserRoleIDs(ids ...uuid.UUID) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *UserMutation) RemovedUserRolesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *UserMutation) UserRolesIDs() (ids []uuid.UUID) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *UserMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *UserMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *UserMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *UserMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *UserMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *UserMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *UserMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *UserMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// AddUpscaleIDs adds the "upscales" edge to the Upscale entity by ids.
func (m *UserMutation) AddUpscaleIDs(ids ...uuid.UUID) {
	if m.upscales == nil {
		m.upscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscales[ids[i]] = struct{}{}
	}
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *UserMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *UserMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// RemoveUpscaleIDs removes the "upscales" edge to the Upscale entity by IDs.
func (m *UserMutation) RemoveUpscaleIDs(ids ...uuid.UUID) {
	if m.removedupscales == nil {
		m.removedupscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscales, ids[i])
		m.removedupscales[ids[i]] = struct{}{}
	}
}

// RemovedUpscales returns the removed IDs of the "upscales" edge to the Upscale entity.
func (m *UserMutation) RemovedUpscalesIDs() (ids []uuid.UUID) {
	for id := range m.removedupscales {
		ids = append(ids, id)
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
func (m *UserMutation) UpscalesIDs() (ids []uuid.UUID) {
	for id := range m.upscales {
		ids = append(ids, id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *UserMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
	m.removedupscales = nil
}

// AddCreditIDs adds the "credits" edge to the Credit entity by ids.
func (m *UserMutation) AddCreditIDs(ids ...uuid.UUID) {
	if m.credits == nil {
		m.credits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.credits[ids[i]] = struct{}{}
	}
}

// ClearCredits clears the "credits" edge to the Credit entity.
func (m *UserMutation) ClearCredits() {
	m.clearedcredits = true
}

// CreditsCleared reports if the "credits" edge to the Credit entity was cleared.
func (m *UserMutation) CreditsCleared() bool {
	return m.clearedcredits
}

// RemoveCreditIDs removes the "credits" edge to the Credit entity by IDs.
func (m *UserMutation) RemoveCreditIDs(ids ...uuid.UUID) {
	if m.removedcredits == nil {
		m.removedcredits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.credits, ids[i])
		m.removedcredits[ids[i]] = struct{}{}
	}
}

// RemovedCredits returns the removed IDs of the "credits" edge to the Credit entity.
func (m *UserMutation) RemovedCreditsIDs() (ids []uuid.UUID) {
	for id := range m.removedcredits {
		ids = append(ids, id)
	}
	return
}

// CreditsIDs returns the "credits" edge IDs in the mutation.
func (m *UserMutation) CreditsIDs() (ids []uuid.UUID) {
	for id := range m.credits {
		ids = append(ids, id)
	}
	return
}

// ResetCredits resets all changes to the "credits" edge.
func (m *UserMutation) ResetCredits() {
	m.credits = nil
	m.clearedcredits = false
	m.removedcredits = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, user.FieldStripeCustomerID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	if m.generations != nil {
		edges = append(edges, user.EdgeGenerations)
	}
	if m.upscales != nil {
		edges = append(edges, user.EdgeUpscales)
	}
	if m.credits != nil {
		edges = append(edges, user.EdgeCredits)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.upscales))
		for id := range m.upscales {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredits:
		ids := make([]ent.Value, 0, len(m.credits))
		for id := range m.credits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeduser_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	if m.removedgenerations != nil {
		edges = append(edges, user.EdgeGenerations)
	}
	if m.removedupscales != nil {
		edges = append(edges, user.EdgeUpscales)
	}
	if m.removedcredits != nil {
		edges = append(edges, user.EdgeCredits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.removedupscales))
		for id := range m.removedupscales {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredits:
		ids := make([]ent.Value, 0, len(m.removedcredits))
		for id := range m.removedcredits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser_roles {
		edges = append(edges, user.EdgeUserRoles)
	}
	if m.clearedgenerations {
		edges = append(edges, user.EdgeGenerations)
	}
	if m.clearedupscales {
		edges = append(edges, user.EdgeUpscales)
	}
	if m.clearedcredits {
		edges = append(edges, user.EdgeCredits)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserRoles:
		return m.cleareduser_roles
	case user.EdgeGenerations:
		return m.clearedgenerations
	case user.EdgeUpscales:
		return m.clearedupscales
	case user.EdgeCredits:
		return m.clearedcredits
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	case user.EdgeGenerations:
		m.ResetGenerations()
		return nil
	case user.EdgeUpscales:
		m.ResetUpscales()
		return nil
	case user.EdgeCredits:
		m.ResetCredits()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	role_name     *userrole.RoleName
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	users         *uuid.UUID
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*UserRole, error)
	predicates    []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id uuid.UUID) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserRole entities.
func (m *UserRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserRoleMutation) SetUserID(u uuid.UUID) {
	m.users = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRoleMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRoleMutation) ResetUserID() {
	m.users = nil
}

// SetRoleName sets the "role_name" field.
func (m *UserRoleMutation) SetRoleName(un userrole.RoleName) {
	m.role_name = &un
}

// RoleName returns the value of the "role_name" field in the mutation.
func (m *UserRoleMutation) RoleName() (r userrole.RoleName, exists bool) {
	v := m.role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "role_name" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRoleName(ctx context.Context) (v userrole.RoleName, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ResetRoleName resets all changes to the "role_name" field.
func (m *UserRoleMutation) ResetRoleName() {
	m.role_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *UserRoleMutation) SetUsersID(id uuid.UUID) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *UserRoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *UserRoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *UserRoleMutation) UsersID() (id uuid.UUID, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UsersIDs() (ids []uuid.UUID) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *UserRoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.users != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	if m.role_name != nil {
		fields = append(fields, userrole.FieldRoleName)
	}
	if m.created_at != nil {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldUserID:
		return m.UserID()
	case userrole.FieldRoleName:
		return m.RoleName()
	case userrole.FieldCreatedAt:
		return m.CreatedAt()
	case userrole.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldUserID:
		return m.OldUserID(ctx)
	case userrole.FieldRoleName:
		return m.OldRoleName(ctx)
	case userrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userrole.FieldRoleName:
		v, ok := value.(userrole.RoleName)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	case userrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldUserID:
		m.ResetUserID()
		return nil
	case userrole.FieldRoleName:
		m.ResetRoleName()
		return nil
	case userrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, userrole.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, userrole.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}
